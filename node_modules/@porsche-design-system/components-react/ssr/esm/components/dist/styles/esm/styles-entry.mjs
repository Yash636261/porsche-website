function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

var _typeof$1 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isBrowser = (typeof window === "undefined" ? "undefined" : _typeof$1(window)) === "object" && (typeof document === "undefined" ? "undefined" : _typeof$1(document)) === 'object' && document.nodeType === 9;

function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}

function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : String(i);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

var plainObjectConstrurctor = {}.constructor;
function cloneStyle(style) {
  if (style == null || typeof style !== 'object') return style;
  if (Array.isArray(style)) return style.map(cloneStyle);
  if (style.constructor !== plainObjectConstrurctor) return style;
  var newStyle = {};

  for (var name in style) {
    newStyle[name] = cloneStyle(style[name]);
  }

  return newStyle;
}

/**
 * Create a rule instance.
 */

function createRule(name, decl, options) {
  if (name === void 0) {
    name = 'unnamed';
  }

  var jss = options.jss;
  var declCopy = cloneStyle(decl);
  var rule = jss.plugins.onCreateRule(name, declCopy, options);
  if (rule) return rule; // It is an at-rule and it has no instance.

  if (name[0] === '@') ;

  return null;
}

var join$1 = function join(value, by) {
  var result = '';

  for (var i = 0; i < value.length; i++) {
    // Remove !important from the value, it will be readded later.
    if (value[i] === '!important') break;
    if (result) result += by;
    result += value[i];
  }

  return result;
};
/**
 * Converts JSS array value to a CSS string.
 *
 * `margin: [['5px', '10px']]` > `margin: 5px 10px;`
 * `border: ['1px', '2px']` > `border: 1px, 2px;`
 * `margin: [['5px', '10px'], '!important']` > `margin: 5px 10px !important;`
 * `color: ['red', !important]` > `color: red !important;`
 */


var toCssValue = function toCssValue(value) {
  if (!Array.isArray(value)) return value;
  var cssValue = ''; // Support space separated values via `[['5px', '10px']]`.

  if (Array.isArray(value[0])) {
    for (var i = 0; i < value.length; i++) {
      if (value[i] === '!important') break;
      if (cssValue) cssValue += ', ';
      cssValue += join$1(value[i], ' ');
    }
  } else cssValue = join$1(value, ', '); // Add !important, because it was ignored.


  if (value[value.length - 1] === '!important') {
    cssValue += ' !important';
  }

  return cssValue;
};

function getWhitespaceSymbols(options) {
  if (options && options.format === false) {
    return {
      linebreak: '',
      space: ''
    };
  }

  return {
    linebreak: '\n',
    space: ' '
  };
}

/**
 * Indent a string.
 * http://jsperf.com/array-join-vs-for
 */

function indentStr(str, indent) {
  var result = '';

  for (var index = 0; index < indent; index++) {
    result += '  ';
  }

  return result + str;
}
/**
 * Converts a Rule to CSS string.
 */


function toCss(selector, style, options) {
  if (options === void 0) {
    options = {};
  }

  var result = '';
  if (!style) return result;
  var _options = options,
      _options$indent = _options.indent,
      indent = _options$indent === void 0 ? 0 : _options$indent;
  var fallbacks = style.fallbacks;

  if (options.format === false) {
    indent = -Infinity;
  }

  var _getWhitespaceSymbols = getWhitespaceSymbols(options),
      linebreak = _getWhitespaceSymbols.linebreak,
      space = _getWhitespaceSymbols.space;

  if (selector) indent++; // Apply fallbacks first.

  if (fallbacks) {
    // Array syntax {fallbacks: [{prop: value}]}
    if (Array.isArray(fallbacks)) {
      for (var index = 0; index < fallbacks.length; index++) {
        var fallback = fallbacks[index];

        for (var prop in fallback) {
          var value = fallback[prop];

          if (value != null) {
            if (result) result += linebreak;
            result += indentStr(prop + ":" + space + toCssValue(value) + ";", indent);
          }
        }
      }
    } else {
      // Object syntax {fallbacks: {prop: value}}
      for (var _prop in fallbacks) {
        var _value = fallbacks[_prop];

        if (_value != null) {
          if (result) result += linebreak;
          result += indentStr(_prop + ":" + space + toCssValue(_value) + ";", indent);
        }
      }
    }
  }

  for (var _prop2 in style) {
    var _value2 = style[_prop2];

    if (_value2 != null && _prop2 !== 'fallbacks') {
      if (result) result += linebreak;
      result += indentStr(_prop2 + ":" + space + toCssValue(_value2) + ";", indent);
    }
  } // Allow empty style in this case, because properties will be added dynamically.


  if (!result && !options.allowEmpty) return result; // When rule is being stringified before selector was defined.

  if (!selector) return result;
  indent--;
  if (result) result = "" + linebreak + result + linebreak;
  return indentStr("" + selector + space + "{" + result, indent) + indentStr('}', indent);
}

var escapeRegex = /([[\].#*$><+~=|^:(),"'`\s])/g;
var nativeEscape = typeof CSS !== 'undefined' && CSS.escape;
var escape = (function (str) {
  return nativeEscape ? nativeEscape(str) : str.replace(escapeRegex, '\\$1');
});

var BaseStyleRule =
/*#__PURE__*/
function () {
  function BaseStyleRule(key, style, options) {
    this.type = 'style';
    this.isProcessed = false;
    var sheet = options.sheet,
        Renderer = options.Renderer;
    this.key = key;
    this.options = options;
    this.style = style;
    if (sheet) this.renderer = sheet.renderer;else if (Renderer) this.renderer = new Renderer();
  }
  /**
   * Get or set a style property.
   */


  var _proto = BaseStyleRule.prototype;

  _proto.prop = function prop(name, value, options) {
    // It's a getter.
    if (value === undefined) return this.style[name]; // Don't do anything if the value has not changed.

    var force = options ? options.force : false;
    if (!force && this.style[name] === value) return this;
    var newValue = value;

    if (!options || options.process !== false) {
      newValue = this.options.jss.plugins.onChangeValue(value, name, this);
    }

    var isEmpty = newValue == null || newValue === false;
    var isDefined = name in this.style; // Value is empty and wasn't defined before.

    if (isEmpty && !isDefined && !force) return this; // We are going to remove this value.

    var remove = isEmpty && isDefined;
    if (remove) delete this.style[name];else this.style[name] = newValue; // Renderable is defined if StyleSheet option `link` is true.

    if (this.renderable && this.renderer) {
      if (remove) this.renderer.removeProperty(this.renderable, name);else this.renderer.setProperty(this.renderable, name, newValue);
      return this;
    }

    var sheet = this.options.sheet;

    if (sheet && sheet.attached) ;

    return this;
  };

  return BaseStyleRule;
}();
var StyleRule =
/*#__PURE__*/
function (_BaseStyleRule) {
  _inheritsLoose(StyleRule, _BaseStyleRule);

  function StyleRule(key, style, options) {
    var _this;

    _this = _BaseStyleRule.call(this, key, style, options) || this;
    var selector = options.selector,
        scoped = options.scoped,
        sheet = options.sheet,
        generateId = options.generateId;

    if (selector) {
      _this.selectorText = selector;
    } else if (scoped !== false) {
      _this.id = generateId(_assertThisInitialized(_assertThisInitialized(_this)), sheet);
      _this.selectorText = "." + escape(_this.id);
    }

    return _this;
  }
  /**
   * Set selector string.
   * Attention: use this with caution. Most browsers didn't implement
   * selectorText setter, so this may result in rerendering of entire Style Sheet.
   */


  var _proto2 = StyleRule.prototype;

  /**
   * Apply rule to an element inline.
   */
  _proto2.applyTo = function applyTo(renderable) {
    var renderer = this.renderer;

    if (renderer) {
      var json = this.toJSON();

      for (var prop in json) {
        renderer.setProperty(renderable, prop, json[prop]);
      }
    }

    return this;
  }
  /**
   * Returns JSON representation of the rule.
   * Fallbacks are not supported.
   * Useful for inline styles.
   */
  ;

  _proto2.toJSON = function toJSON() {
    var json = {};

    for (var prop in this.style) {
      var value = this.style[prop];
      if (typeof value !== 'object') json[prop] = value;else if (Array.isArray(value)) json[prop] = toCssValue(value);
    }

    return json;
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto2.toString = function toString(options) {
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;
    var opts = link ? _extends({}, options, {
      allowEmpty: true
    }) : options;
    return toCss(this.selectorText, this.style, opts);
  };

  _createClass(StyleRule, [{
    key: "selector",
    set: function set(selector) {
      if (selector === this.selectorText) return;
      this.selectorText = selector;
      var renderer = this.renderer,
          renderable = this.renderable;
      if (!renderable || !renderer) return;
      var hasChanged = renderer.setSelector(renderable, selector); // If selector setter is not implemented, rerender the rule.

      if (!hasChanged) {
        renderer.replaceRule(renderable, this);
      }
    }
    /**
     * Get selector string.
     */
    ,
    get: function get() {
      return this.selectorText;
    }
  }]);

  return StyleRule;
}(BaseStyleRule);
var pluginStyleRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    if (key[0] === '@' || options.parent && options.parent.type === 'keyframes') {
      return null;
    }

    return new StyleRule(key, style, options);
  }
};

var defaultToStringOptions = {
  indent: 1,
  children: true
};
var atRegExp = /@([\w-]+)/;
/**
 * Conditional rule for @media, @supports
 */

var ConditionalRule =
/*#__PURE__*/
function () {
  function ConditionalRule(key, styles, options) {
    this.type = 'conditional';
    this.isProcessed = false;
    this.key = key;
    var atMatch = key.match(atRegExp);
    this.at = atMatch ? atMatch[1] : 'unknown'; // Key might contain a unique suffix in case the `name` passed by user was duplicate.

    this.query = options.name || "@" + this.at;
    this.options = options;
    this.rules = new RuleList(_extends({}, options, {
      parent: this
    }));

    for (var name in styles) {
      this.rules.add(name, styles[name]);
    }

    this.rules.process();
  }
  /**
   * Get a rule.
   */


  var _proto = ConditionalRule.prototype;

  _proto.getRule = function getRule(name) {
    return this.rules.get(name);
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Create and register rule, run plugins.
   */
  ;

  _proto.addRule = function addRule(name, style, options) {
    var rule = this.rules.add(name, style, options);
    if (!rule) return null;
    this.options.jss.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Replace rule, run plugins.
   */
  ;

  _proto.replaceRule = function replaceRule(name, style, options) {
    var newRule = this.rules.replace(name, style, options);
    if (newRule) this.options.jss.plugins.onProcessRule(newRule);
    return newRule;
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    if (options === void 0) {
      options = defaultToStringOptions;
    }

    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;

    if (options.indent == null) options.indent = defaultToStringOptions.indent;
    if (options.children == null) options.children = defaultToStringOptions.children;

    if (options.children === false) {
      return this.query + " {}";
    }

    var children = this.rules.toString(options);
    return children ? this.query + " {" + linebreak + children + linebreak + "}" : '';
  };

  return ConditionalRule;
}();
var keyRegExp = /@container|@media|@supports\s+/;
var pluginConditionalRule = {
  onCreateRule: function onCreateRule(key, styles, options) {
    return keyRegExp.test(key) ? new ConditionalRule(key, styles, options) : null;
  }
};

var defaultToStringOptions$1 = {
  indent: 1,
  children: true
};
var nameRegExp = /@keyframes\s+([\w-]+)/;
/**
 * Rule for @keyframes
 */

var KeyframesRule =
/*#__PURE__*/
function () {
  function KeyframesRule(key, frames, options) {
    this.type = 'keyframes';
    this.at = '@keyframes';
    this.isProcessed = false;
    var nameMatch = key.match(nameRegExp);

    if (nameMatch && nameMatch[1]) {
      this.name = nameMatch[1];
    } else {
      this.name = 'noname';
    }

    this.key = this.type + "-" + this.name;
    this.options = options;
    var scoped = options.scoped,
        sheet = options.sheet,
        generateId = options.generateId;
    this.id = scoped === false ? this.name : escape(generateId(this, sheet));
    this.rules = new RuleList(_extends({}, options, {
      parent: this
    }));

    for (var name in frames) {
      this.rules.add(name, frames[name], _extends({}, options, {
        parent: this
      }));
    }

    this.rules.process();
  }
  /**
   * Generates a CSS string.
   */


  var _proto = KeyframesRule.prototype;

  _proto.toString = function toString(options) {
    if (options === void 0) {
      options = defaultToStringOptions$1;
    }

    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;

    if (options.indent == null) options.indent = defaultToStringOptions$1.indent;
    if (options.children == null) options.children = defaultToStringOptions$1.children;

    if (options.children === false) {
      return this.at + " " + this.id + " {}";
    }

    var children = this.rules.toString(options);
    if (children) children = "" + linebreak + children + linebreak;
    return this.at + " " + this.id + " {" + children + "}";
  };

  return KeyframesRule;
}();
var keyRegExp$1 = /@keyframes\s+/;
var refRegExp$1 = /\$([\w-]+)/g;

var findReferencedKeyframe = function findReferencedKeyframe(val, keyframes) {
  if (typeof val === 'string') {
    return val.replace(refRegExp$1, function (match, name) {
      if (name in keyframes) {
        return keyframes[name];
      }
      return match;
    });
  }

  return val;
};
/**
 * Replace the reference for a animation name.
 */


var replaceRef = function replaceRef(style, prop, keyframes) {
  var value = style[prop];
  var refKeyframe = findReferencedKeyframe(value, keyframes);

  if (refKeyframe !== value) {
    style[prop] = refKeyframe;
  }
};

var pluginKeyframesRule = {
  onCreateRule: function onCreateRule(key, frames, options) {
    return typeof key === 'string' && keyRegExp$1.test(key) ? new KeyframesRule(key, frames, options) : null;
  },
  // Animation name ref replacer.
  onProcessStyle: function onProcessStyle(style, rule, sheet) {
    if (rule.type !== 'style' || !sheet) return style;
    if ('animation-name' in style) replaceRef(style, 'animation-name', sheet.keyframes);
    if ('animation' in style) replaceRef(style, 'animation', sheet.keyframes);
    return style;
  },
  onChangeValue: function onChangeValue(val, prop, rule) {
    var sheet = rule.options.sheet;

    if (!sheet) {
      return val;
    }

    switch (prop) {
      case 'animation':
        return findReferencedKeyframe(val, sheet.keyframes);

      case 'animation-name':
        return findReferencedKeyframe(val, sheet.keyframes);

      default:
        return val;
    }
  }
};

var KeyframeRule =
/*#__PURE__*/
function (_BaseStyleRule) {
  _inheritsLoose(KeyframeRule, _BaseStyleRule);

  function KeyframeRule() {
    return _BaseStyleRule.apply(this, arguments) || this;
  }

  var _proto = KeyframeRule.prototype;

  /**
   * Generates a CSS string.
   */
  _proto.toString = function toString(options) {
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;
    var opts = link ? _extends({}, options, {
      allowEmpty: true
    }) : options;
    return toCss(this.key, this.style, opts);
  };

  return KeyframeRule;
}(BaseStyleRule);
var pluginKeyframeRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    if (options.parent && options.parent.type === 'keyframes') {
      return new KeyframeRule(key, style, options);
    }

    return null;
  }
};

var FontFaceRule =
/*#__PURE__*/
function () {
  function FontFaceRule(key, style, options) {
    this.type = 'font-face';
    this.at = '@font-face';
    this.isProcessed = false;
    this.key = key;
    this.style = style;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */


  var _proto = FontFaceRule.prototype;

  _proto.toString = function toString(options) {
    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;

    if (Array.isArray(this.style)) {
      var str = '';

      for (var index = 0; index < this.style.length; index++) {
        str += toCss(this.at, this.style[index]);
        if (this.style[index + 1]) str += linebreak;
      }

      return str;
    }

    return toCss(this.at, this.style, options);
  };

  return FontFaceRule;
}();
var keyRegExp$2 = /@font-face/;
var pluginFontFaceRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    return keyRegExp$2.test(key) ? new FontFaceRule(key, style, options) : null;
  }
};

var ViewportRule =
/*#__PURE__*/
function () {
  function ViewportRule(key, style, options) {
    this.type = 'viewport';
    this.at = '@viewport';
    this.isProcessed = false;
    this.key = key;
    this.style = style;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */


  var _proto = ViewportRule.prototype;

  _proto.toString = function toString(options) {
    return toCss(this.key, this.style, options);
  };

  return ViewportRule;
}();
var pluginViewportRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    return key === '@viewport' || key === '@-ms-viewport' ? new ViewportRule(key, style, options) : null;
  }
};

var SimpleRule =
/*#__PURE__*/
function () {
  function SimpleRule(key, value, options) {
    this.type = 'simple';
    this.isProcessed = false;
    this.key = key;
    this.value = value;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */
  // eslint-disable-next-line no-unused-vars


  var _proto = SimpleRule.prototype;

  _proto.toString = function toString(options) {
    if (Array.isArray(this.value)) {
      var str = '';

      for (var index = 0; index < this.value.length; index++) {
        str += this.key + " " + this.value[index] + ";";
        if (this.value[index + 1]) str += '\n';
      }

      return str;
    }

    return this.key + " " + this.value + ";";
  };

  return SimpleRule;
}();
var keysMap = {
  '@charset': true,
  '@import': true,
  '@namespace': true
};
var pluginSimpleRule = {
  onCreateRule: function onCreateRule(key, value, options) {
    return key in keysMap ? new SimpleRule(key, value, options) : null;
  }
};

var plugins = [pluginStyleRule, pluginConditionalRule, pluginKeyframesRule, pluginKeyframeRule, pluginFontFaceRule, pluginViewportRule, pluginSimpleRule];

var defaultUpdateOptions = {
  process: true
};
var forceUpdateOptions = {
  force: true,
  process: true
  /**
   * Contains rules objects and allows adding/removing etc.
   * Is used for e.g. by `StyleSheet` or `ConditionalRule`.
   */

};

var RuleList =
/*#__PURE__*/
function () {
  // Rules registry for access by .get() method.
  // It contains the same rule registered by name and by selector.
  // Original styles object.
  // Used to ensure correct rules order.
  function RuleList(options) {
    this.map = {};
    this.raw = {};
    this.index = [];
    this.counter = 0;
    this.options = options;
    this.classes = options.classes;
    this.keyframes = options.keyframes;
  }
  /**
   * Create and register rule.
   *
   * Will not render after Style Sheet was rendered the first time.
   */


  var _proto = RuleList.prototype;

  _proto.add = function add(name, decl, ruleOptions) {
    var _this$options = this.options,
        parent = _this$options.parent,
        sheet = _this$options.sheet,
        jss = _this$options.jss,
        Renderer = _this$options.Renderer,
        generateId = _this$options.generateId,
        scoped = _this$options.scoped;

    var options = _extends({
      classes: this.classes,
      parent: parent,
      sheet: sheet,
      jss: jss,
      Renderer: Renderer,
      generateId: generateId,
      scoped: scoped,
      name: name,
      keyframes: this.keyframes,
      selector: undefined
    }, ruleOptions); // When user uses .createStyleSheet(), duplicate names are not possible, but
    // `sheet.addRule()` opens the door for any duplicate rule name. When this happens
    // we need to make the key unique within this RuleList instance scope.


    var key = name;

    if (name in this.raw) {
      key = name + "-d" + this.counter++;
    } // We need to save the original decl before creating the rule
    // because cache plugin needs to use it as a key to return a cached rule.


    this.raw[key] = decl;

    if (key in this.classes) {
      // E.g. rules inside of @media container
      options.selector = "." + escape(this.classes[key]);
    }

    var rule = createRule(key, decl, options);
    if (!rule) return null;
    this.register(rule);
    var index = options.index === undefined ? this.index.length : options.index;
    this.index.splice(index, 0, rule);
    return rule;
  }
  /**
   * Replace rule.
   * Create a new rule and remove old one instead of overwriting
   * because we want to invoke onCreateRule hook to make plugins work.
   */
  ;

  _proto.replace = function replace(name, decl, ruleOptions) {
    var oldRule = this.get(name);
    var oldIndex = this.index.indexOf(oldRule);

    if (oldRule) {
      this.remove(oldRule);
    }

    var options = ruleOptions;
    if (oldIndex !== -1) options = _extends({}, ruleOptions, {
      index: oldIndex
    });
    return this.add(name, decl, options);
  }
  /**
   * Get a rule by name or selector.
   */
  ;

  _proto.get = function get(nameOrSelector) {
    return this.map[nameOrSelector];
  }
  /**
   * Delete a rule.
   */
  ;

  _proto.remove = function remove(rule) {
    this.unregister(rule);
    delete this.raw[rule.key];
    this.index.splice(this.index.indexOf(rule), 1);
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.index.indexOf(rule);
  }
  /**
   * Run `onProcessRule()` plugins on every rule.
   */
  ;

  _proto.process = function process() {
    var plugins = this.options.jss.plugins; // We need to clone array because if we modify the index somewhere else during a loop
    // we end up with very hard-to-track-down side effects.

    this.index.slice(0).forEach(plugins.onProcessRule, plugins);
  }
  /**
   * Register a rule in `.map`, `.classes` and `.keyframes` maps.
   */
  ;

  _proto.register = function register(rule) {
    this.map[rule.key] = rule;

    if (rule instanceof StyleRule) {
      this.map[rule.selector] = rule;
      if (rule.id) this.classes[rule.key] = rule.id;
    } else if (rule instanceof KeyframesRule && this.keyframes) {
      this.keyframes[rule.name] = rule.id;
    }
  }
  /**
   * Unregister a rule.
   */
  ;

  _proto.unregister = function unregister(rule) {
    delete this.map[rule.key];

    if (rule instanceof StyleRule) {
      delete this.map[rule.selector];
      delete this.classes[rule.key];
    } else if (rule instanceof KeyframesRule) {
      delete this.keyframes[rule.name];
    }
  }
  /**
   * Update the function values with a new data.
   */
  ;

  _proto.update = function update() {
    var name;
    var data;
    var options;

    if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {
      name = arguments.length <= 0 ? undefined : arguments[0];
      data = arguments.length <= 1 ? undefined : arguments[1];
      options = arguments.length <= 2 ? undefined : arguments[2];
    } else {
      data = arguments.length <= 0 ? undefined : arguments[0];
      options = arguments.length <= 1 ? undefined : arguments[1];
      name = null;
    }

    if (name) {
      this.updateOne(this.get(name), data, options);
    } else {
      for (var index = 0; index < this.index.length; index++) {
        this.updateOne(this.index[index], data, options);
      }
    }
  }
  /**
   * Execute plugins, update rule props.
   */
  ;

  _proto.updateOne = function updateOne(rule, data, options) {
    if (options === void 0) {
      options = defaultUpdateOptions;
    }

    var _this$options2 = this.options,
        plugins = _this$options2.jss.plugins,
        sheet = _this$options2.sheet; // It is a rules container like for e.g. ConditionalRule.

    if (rule.rules instanceof RuleList) {
      rule.rules.update(data, options);
      return;
    }

    var style = rule.style;
    plugins.onUpdate(data, rule, sheet, options); // We rely on a new `style` ref in case it was mutated during onUpdate hook.

    if (options.process && style && style !== rule.style) {
      // We need to run the plugins in case new `style` relies on syntax plugins.
      plugins.onProcessStyle(rule.style, rule, sheet); // Update and add props.

      for (var prop in rule.style) {
        var nextValue = rule.style[prop];
        var prevValue = style[prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.

        if (nextValue !== prevValue) {
          rule.prop(prop, nextValue, forceUpdateOptions);
        }
      } // Remove props.


      for (var _prop in style) {
        var _nextValue = rule.style[_prop];
        var _prevValue = style[_prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.

        if (_nextValue == null && _nextValue !== _prevValue) {
          rule.prop(_prop, null, forceUpdateOptions);
        }
      }
    }
  }
  /**
   * Convert rules to a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    var str = '';
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;

    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;

    for (var index = 0; index < this.index.length; index++) {
      var rule = this.index[index];
      var css = rule.toString(options); // No need to render an empty rule.

      if (!css && !link) continue;
      if (str) str += linebreak;
      str += css;
    }

    return str;
  };

  return RuleList;
}();

var StyleSheet =
/*#__PURE__*/
function () {
  function StyleSheet(styles, options) {
    this.attached = false;
    this.deployed = false;
    this.classes = {};
    this.keyframes = {};
    this.options = _extends({}, options, {
      sheet: this,
      parent: this,
      classes: this.classes,
      keyframes: this.keyframes
    });

    if (options.Renderer) {
      this.renderer = new options.Renderer(this);
    }

    this.rules = new RuleList(this.options);

    for (var name in styles) {
      this.rules.add(name, styles[name]);
    }

    this.rules.process();
  }
  /**
   * Attach renderable to the render tree.
   */


  var _proto = StyleSheet.prototype;

  _proto.attach = function attach() {
    if (this.attached) return this;
    if (this.renderer) this.renderer.attach();
    this.attached = true; // Order is important, because we can't use insertRule API if style element is not attached.

    if (!this.deployed) this.deploy();
    return this;
  }
  /**
   * Remove renderable from render tree.
   */
  ;

  _proto.detach = function detach() {
    if (!this.attached) return this;
    if (this.renderer) this.renderer.detach();
    this.attached = false;
    return this;
  }
  /**
   * Add a rule to the current stylesheet.
   * Will insert a rule also after the stylesheet has been rendered first time.
   */
  ;

  _proto.addRule = function addRule(name, decl, options) {
    var queue = this.queue; // Plugins can create rules.
    // In order to preserve the right order, we need to queue all `.addRule` calls,
    // which happen after the first `rules.add()` call.

    if (this.attached && !queue) this.queue = [];
    var rule = this.rules.add(name, decl, options);
    if (!rule) return null;
    this.options.jss.plugins.onProcessRule(rule);

    if (this.attached) {
      if (!this.deployed) return rule; // Don't insert rule directly if there is no stringified version yet.
      // It will be inserted all together when .attach is called.

      if (queue) queue.push(rule);else {
        this.insertRule(rule);

        if (this.queue) {
          this.queue.forEach(this.insertRule, this);
          this.queue = undefined;
        }
      }
      return rule;
    } // We can't add rules to a detached style node.
    // We will redeploy the sheet once user will attach it.


    this.deployed = false;
    return rule;
  }
  /**
   * Replace a rule in the current stylesheet.
   */
  ;

  _proto.replaceRule = function replaceRule(nameOrSelector, decl, options) {
    var oldRule = this.rules.get(nameOrSelector);
    if (!oldRule) return this.addRule(nameOrSelector, decl, options);
    var newRule = this.rules.replace(nameOrSelector, decl, options);

    if (newRule) {
      this.options.jss.plugins.onProcessRule(newRule);
    }

    if (this.attached) {
      if (!this.deployed) return newRule; // Don't replace / delete rule directly if there is no stringified version yet.
      // It will be inserted all together when .attach is called.

      if (this.renderer) {
        if (!newRule) {
          this.renderer.deleteRule(oldRule);
        } else if (oldRule.renderable) {
          this.renderer.replaceRule(oldRule.renderable, newRule);
        }
      }

      return newRule;
    } // We can't replace rules to a detached style node.
    // We will redeploy the sheet once user will attach it.


    this.deployed = false;
    return newRule;
  }
  /**
   * Insert rule into the StyleSheet
   */
  ;

  _proto.insertRule = function insertRule(rule) {
    if (this.renderer) {
      this.renderer.insertRule(rule);
    }
  }
  /**
   * Create and add rules.
   * Will render also after Style Sheet was rendered the first time.
   */
  ;

  _proto.addRules = function addRules(styles, options) {
    var added = [];

    for (var name in styles) {
      var rule = this.addRule(name, styles[name], options);
      if (rule) added.push(rule);
    }

    return added;
  }
  /**
   * Get a rule by name or selector.
   */
  ;

  _proto.getRule = function getRule(nameOrSelector) {
    return this.rules.get(nameOrSelector);
  }
  /**
   * Delete a rule by name.
   * Returns `true`: if rule has been deleted from the DOM.
   */
  ;

  _proto.deleteRule = function deleteRule(name) {
    var rule = typeof name === 'object' ? name : this.rules.get(name);

    if (!rule || // Style sheet was created without link: true and attached, in this case we
    // won't be able to remove the CSS rule from the DOM.
    this.attached && !rule.renderable) {
      return false;
    }

    this.rules.remove(rule);

    if (this.attached && rule.renderable && this.renderer) {
      return this.renderer.deleteRule(rule.renderable);
    }

    return true;
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Deploy pure CSS string to a renderable.
   */
  ;

  _proto.deploy = function deploy() {
    if (this.renderer) this.renderer.deploy();
    this.deployed = true;
    return this;
  }
  /**
   * Update the function values with a new data.
   */
  ;

  _proto.update = function update() {
    var _this$rules;

    (_this$rules = this.rules).update.apply(_this$rules, arguments);

    return this;
  }
  /**
   * Updates a single rule.
   */
  ;

  _proto.updateOne = function updateOne(rule, data, options) {
    this.rules.updateOne(rule, data, options);
    return this;
  }
  /**
   * Convert rules to a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    return this.rules.toString(options);
  };

  return StyleSheet;
}();

var PluginsRegistry =
/*#__PURE__*/
function () {
  function PluginsRegistry() {
    this.plugins = {
      internal: [],
      external: []
    };
    this.registry = {};
  }

  var _proto = PluginsRegistry.prototype;

  /**
   * Call `onCreateRule` hooks and return an object if returned by a hook.
   */
  _proto.onCreateRule = function onCreateRule(name, decl, options) {
    for (var i = 0; i < this.registry.onCreateRule.length; i++) {
      var rule = this.registry.onCreateRule[i](name, decl, options);
      if (rule) return rule;
    }

    return null;
  }
  /**
   * Call `onProcessRule` hooks.
   */
  ;

  _proto.onProcessRule = function onProcessRule(rule) {
    if (rule.isProcessed) return;
    var sheet = rule.options.sheet;

    for (var i = 0; i < this.registry.onProcessRule.length; i++) {
      this.registry.onProcessRule[i](rule, sheet);
    }

    if (rule.style) this.onProcessStyle(rule.style, rule, sheet);
    rule.isProcessed = true;
  }
  /**
   * Call `onProcessStyle` hooks.
   */
  ;

  _proto.onProcessStyle = function onProcessStyle(style, rule, sheet) {
    for (var i = 0; i < this.registry.onProcessStyle.length; i++) {
      rule.style = this.registry.onProcessStyle[i](rule.style, rule, sheet);
    }
  }
  /**
   * Call `onProcessSheet` hooks.
   */
  ;

  _proto.onProcessSheet = function onProcessSheet(sheet) {
    for (var i = 0; i < this.registry.onProcessSheet.length; i++) {
      this.registry.onProcessSheet[i](sheet);
    }
  }
  /**
   * Call `onUpdate` hooks.
   */
  ;

  _proto.onUpdate = function onUpdate(data, rule, sheet, options) {
    for (var i = 0; i < this.registry.onUpdate.length; i++) {
      this.registry.onUpdate[i](data, rule, sheet, options);
    }
  }
  /**
   * Call `onChangeValue` hooks.
   */
  ;

  _proto.onChangeValue = function onChangeValue(value, prop, rule) {
    var processedValue = value;

    for (var i = 0; i < this.registry.onChangeValue.length; i++) {
      processedValue = this.registry.onChangeValue[i](processedValue, prop, rule);
    }

    return processedValue;
  }
  /**
   * Register a plugin.
   */
  ;

  _proto.use = function use(newPlugin, options) {
    if (options === void 0) {
      options = {
        queue: 'external'
      };
    }

    var plugins = this.plugins[options.queue]; // Avoids applying same plugin twice, at least based on ref.

    if (plugins.indexOf(newPlugin) !== -1) {
      return;
    }

    plugins.push(newPlugin);
    this.registry = [].concat(this.plugins.external, this.plugins.internal).reduce(function (registry, plugin) {
      for (var name in plugin) {
        if (name in registry) {
          registry[name].push(plugin[name]);
        }
      }

      return registry;
    }, {
      onCreateRule: [],
      onProcessRule: [],
      onProcessStyle: [],
      onProcessSheet: [],
      onChangeValue: [],
      onUpdate: []
    });
  };

  return PluginsRegistry;
}();

/**
 * Sheets registry to access all instances in one place.
 */

var SheetsRegistry =
/*#__PURE__*/
function () {
  function SheetsRegistry() {
    this.registry = [];
  }

  var _proto = SheetsRegistry.prototype;

  /**
   * Register a Style Sheet.
   */
  _proto.add = function add(sheet) {
    var registry = this.registry;
    var index = sheet.options.index;
    if (registry.indexOf(sheet) !== -1) return;

    if (registry.length === 0 || index >= this.index) {
      registry.push(sheet);
      return;
    } // Find a position.


    for (var i = 0; i < registry.length; i++) {
      if (registry[i].options.index > index) {
        registry.splice(i, 0, sheet);
        return;
      }
    }
  }
  /**
   * Reset the registry.
   */
  ;

  _proto.reset = function reset() {
    this.registry = [];
  }
  /**
   * Remove a Style Sheet.
   */
  ;

  _proto.remove = function remove(sheet) {
    var index = this.registry.indexOf(sheet);
    this.registry.splice(index, 1);
  }
  /**
   * Convert all attached sheets to a CSS string.
   */
  ;

  _proto.toString = function toString(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        attached = _ref.attached,
        options = _objectWithoutPropertiesLoose(_ref, ["attached"]);

    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;

    var css = '';

    for (var i = 0; i < this.registry.length; i++) {
      var sheet = this.registry[i];

      if (attached != null && sheet.attached !== attached) {
        continue;
      }

      if (css) css += linebreak;
      css += sheet.toString(options);
    }

    return css;
  };

  _createClass(SheetsRegistry, [{
    key: "index",

    /**
     * Current highest index number.
     */
    get: function get() {
      return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;
    }
  }]);

  return SheetsRegistry;
}();

/**
 * This is a global sheets registry. Only DomRenderer will add sheets to it.
 * On the server one should use an own SheetsRegistry instance and add the
 * sheets to it, because you need to make sure to create a new registry for
 * each request in order to not leak sheets across requests.
 */

var sheets = new SheetsRegistry();

/* eslint-disable */

/**
 * Now that `globalThis` is available on most platforms
 * (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis#browser_compatibility)
 * we check for `globalThis` first. `globalThis` is necessary for jss
 * to run in Agoric's secure version of JavaScript (SES). Under SES,
 * `globalThis` exists, but `window`, `self`, and `Function('return
 * this')()` are all undefined for security reasons.
 *
 * https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
 */
var globalThis$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' && window.Math === Math ? window : typeof self !== 'undefined' && self.Math === Math ? self : Function('return this')();

var ns = '2f1acc6c3a606b082e5eef5e54414ffb';
if (globalThis$1[ns] == null) globalThis$1[ns] = 0; // Bundle may contain multiple JSS versions at the same time. In order to identify
// the current version with just one short number and use it for classes generation
// we use a counter. Also it is more accurate, because user can manually reevaluate
// the module.

var moduleId = globalThis$1[ns]++;
/**
 * Returns a function which generates unique class names based on counters.
 * When new generator function is created, rule counter is reseted.
 * We need to reset the rule counter for SSR for each request.
 */

var createGenerateId = function createGenerateId(options) {
  if (options === void 0) {
    options = {};
  }

  var ruleCounter = 0;

  var generateId = function generateId(rule, sheet) {
    ruleCounter += 1;

    var jssId = '';
    var prefix = '';

    if (sheet) {
      if (sheet.options.classNamePrefix) {
        prefix = sheet.options.classNamePrefix;
      }

      if (sheet.options.jss.id != null) {
        jssId = String(sheet.options.jss.id);
      }
    }

    if (options.minify) {
      // Using "c" because a number can't be the first char in a class name.
      return "" + (prefix || 'c') + moduleId + jssId + ruleCounter;
    }

    return prefix + rule.key + "-" + moduleId + (jssId ? "-" + jssId : '') + "-" + ruleCounter;
  };

  return generateId;
};

/**
 * Cache the value from the first time a function is called.
 */

var memoize = function memoize(fn) {
  var value;
  return function () {
    if (!value) value = fn();
    return value;
  };
};
/**
 * Get a style property value.
 */


var getPropertyValue = function getPropertyValue(cssRule, prop) {
  try {
    // Support CSSTOM.
    if (cssRule.attributeStyleMap) {
      return cssRule.attributeStyleMap.get(prop);
    }

    return cssRule.style.getPropertyValue(prop);
  } catch (err) {
    // IE may throw if property is unknown.
    return '';
  }
};
/**
 * Set a style property.
 */


var setProperty = function setProperty(cssRule, prop, value) {
  try {
    var cssValue = value;

    if (Array.isArray(value)) {
      cssValue = toCssValue(value);
    } // Support CSSTOM.


    if (cssRule.attributeStyleMap) {
      cssRule.attributeStyleMap.set(prop, cssValue);
    } else {
      var indexOfImportantFlag = cssValue ? cssValue.indexOf('!important') : -1;
      var cssValueWithoutImportantFlag = indexOfImportantFlag > -1 ? cssValue.substr(0, indexOfImportantFlag - 1) : cssValue;
      cssRule.style.setProperty(prop, cssValueWithoutImportantFlag, indexOfImportantFlag > -1 ? 'important' : '');
    }
  } catch (err) {
    // IE may throw if property is unknown.
    return false;
  }

  return true;
};
/**
 * Remove a style property.
 */


var removeProperty = function removeProperty(cssRule, prop) {
  try {
    // Support CSSTOM.
    if (cssRule.attributeStyleMap) {
      cssRule.attributeStyleMap.delete(prop);
    } else {
      cssRule.style.removeProperty(prop);
    }
  } catch (err) {
  }
};
/**
 * Set the selector.
 */


var setSelector = function setSelector(cssRule, selectorText) {
  cssRule.selectorText = selectorText; // Return false if setter was not successful.
  // Currently works in chrome only.

  return cssRule.selectorText === selectorText;
};
/**
 * Gets the `head` element upon the first call and caches it.
 * We assume it can't be null.
 */


var getHead = memoize(function () {
  return document.querySelector('head');
});
/**
 * Find attached sheet with an index higher than the passed one.
 */

function findHigherSheet(registry, options) {
  for (var i = 0; i < registry.length; i++) {
    var sheet = registry[i];

    if (sheet.attached && sheet.options.index > options.index && sheet.options.insertionPoint === options.insertionPoint) {
      return sheet;
    }
  }

  return null;
}
/**
 * Find attached sheet with the highest index.
 */


function findHighestSheet(registry, options) {
  for (var i = registry.length - 1; i >= 0; i--) {
    var sheet = registry[i];

    if (sheet.attached && sheet.options.insertionPoint === options.insertionPoint) {
      return sheet;
    }
  }

  return null;
}
/**
 * Find a comment with "jss" inside.
 */


function findCommentNode(text) {
  var head = getHead();

  for (var i = 0; i < head.childNodes.length; i++) {
    var node = head.childNodes[i];

    if (node.nodeType === 8 && node.nodeValue.trim() === text) {
      return node;
    }
  }

  return null;
}
/**
 * Find a node before which we can insert the sheet.
 */


function findPrevNode(options) {
  var registry = sheets.registry;

  if (registry.length > 0) {
    // Try to insert before the next higher sheet.
    var sheet = findHigherSheet(registry, options);

    if (sheet && sheet.renderer) {
      return {
        parent: sheet.renderer.element.parentNode,
        node: sheet.renderer.element
      };
    } // Otherwise insert after the last attached.


    sheet = findHighestSheet(registry, options);

    if (sheet && sheet.renderer) {
      return {
        parent: sheet.renderer.element.parentNode,
        node: sheet.renderer.element.nextSibling
      };
    }
  } // Try to find a comment placeholder if registry is empty.


  var insertionPoint = options.insertionPoint;

  if (insertionPoint && typeof insertionPoint === 'string') {
    var comment = findCommentNode(insertionPoint);

    if (comment) {
      return {
        parent: comment.parentNode,
        node: comment.nextSibling
      };
    } // If user specifies an insertion point and it can't be found in the document -
  }

  return false;
}
/**
 * Insert style element into the DOM.
 */


function insertStyle(style, options) {
  var insertionPoint = options.insertionPoint;
  var nextNode = findPrevNode(options);

  if (nextNode !== false && nextNode.parent) {
    nextNode.parent.insertBefore(style, nextNode.node);
    return;
  } // Works with iframes and any node types.


  if (insertionPoint && typeof insertionPoint.nodeType === 'number') {
    var insertionPointElement = insertionPoint;
    var parentNode = insertionPointElement.parentNode;
    if (parentNode) parentNode.insertBefore(style, insertionPointElement.nextSibling);
    return;
  }

  getHead().appendChild(style);
}
/**
 * Read jss nonce setting from the page if the user has set it.
 */


var getNonce = memoize(function () {
  var node = document.querySelector('meta[property="csp-nonce"]');
  return node ? node.getAttribute('content') : null;
});

var _insertRule = function insertRule(container, rule, index) {
  try {
    if ('insertRule' in container) {
      container.insertRule(rule, index);
    } // Keyframes rule.
    else if ('appendRule' in container) {
        container.appendRule(rule);
      }
  } catch (err) {
    return false;
  }

  return container.cssRules[index];
};

var getValidRuleInsertionIndex = function getValidRuleInsertionIndex(container, index) {
  var maxIndex = container.cssRules.length; // In case previous insertion fails, passed index might be wrong

  if (index === undefined || index > maxIndex) {
    // eslint-disable-next-line no-param-reassign
    return maxIndex;
  }

  return index;
};

var createStyle = function createStyle() {
  var el = document.createElement('style'); // Without it, IE will have a broken source order specificity if we
  // insert rules after we insert the style tag.
  // It seems to kick-off the source order specificity algorithm.

  el.textContent = '\n';
  return el;
};

var DomRenderer =
/*#__PURE__*/
function () {
  // Will be empty if link: true option is not set, because
  // it is only for use together with insertRule API.
  function DomRenderer(sheet) {
    this.getPropertyValue = getPropertyValue;
    this.setProperty = setProperty;
    this.removeProperty = removeProperty;
    this.setSelector = setSelector;
    this.hasInsertedRules = false;
    this.cssRules = [];
    // There is no sheet when the renderer is used from a standalone StyleRule.
    if (sheet) sheets.add(sheet);
    this.sheet = sheet;

    var _ref = this.sheet ? this.sheet.options : {},
        media = _ref.media,
        meta = _ref.meta,
        element = _ref.element;

    this.element = element || createStyle();
    this.element.setAttribute('data-jss', '');
    if (media) this.element.setAttribute('media', media);
    if (meta) this.element.setAttribute('data-meta', meta);
    var nonce = getNonce();
    if (nonce) this.element.setAttribute('nonce', nonce);
  }
  /**
   * Insert style element into render tree.
   */


  var _proto = DomRenderer.prototype;

  _proto.attach = function attach() {
    // In the case the element node is external and it is already in the DOM.
    if (this.element.parentNode || !this.sheet) return;
    insertStyle(this.element, this.sheet.options); // When rules are inserted using `insertRule` API, after `sheet.detach().attach()`
    // most browsers create a new CSSStyleSheet, except of all IEs.

    var deployed = Boolean(this.sheet && this.sheet.deployed);

    if (this.hasInsertedRules && deployed) {
      this.hasInsertedRules = false;
      this.deploy();
    }
  }
  /**
   * Remove style element from render tree.
   */
  ;

  _proto.detach = function detach() {
    if (!this.sheet) return;
    var parentNode = this.element.parentNode;
    if (parentNode) parentNode.removeChild(this.element); // In the most browsers, rules inserted using insertRule() API will be lost when style element is removed.
    // Though IE will keep them and we need a consistent behavior.

    if (this.sheet.options.link) {
      this.cssRules = [];
      this.element.textContent = '\n';
    }
  }
  /**
   * Inject CSS string into element.
   */
  ;

  _proto.deploy = function deploy() {
    var sheet = this.sheet;
    if (!sheet) return;

    if (sheet.options.link) {
      this.insertRules(sheet.rules);
      return;
    }

    this.element.textContent = "\n" + sheet.toString() + "\n";
  }
  /**
   * Insert RuleList into an element.
   */
  ;

  _proto.insertRules = function insertRules(rules, nativeParent) {
    for (var i = 0; i < rules.index.length; i++) {
      this.insertRule(rules.index[i], i, nativeParent);
    }
  }
  /**
   * Insert a rule into element.
   */
  ;

  _proto.insertRule = function insertRule(rule, index, nativeParent) {
    if (nativeParent === void 0) {
      nativeParent = this.element.sheet;
    }

    if (rule.rules) {
      var parent = rule;
      var latestNativeParent = nativeParent;

      if (rule.type === 'conditional' || rule.type === 'keyframes') {
        var _insertionIndex = getValidRuleInsertionIndex(nativeParent, index); // We need to render the container without children first.


        latestNativeParent = _insertRule(nativeParent, parent.toString({
          children: false
        }), _insertionIndex);

        if (latestNativeParent === false) {
          return false;
        }

        this.refCssRule(rule, _insertionIndex, latestNativeParent);
      }

      this.insertRules(parent.rules, latestNativeParent);
      return latestNativeParent;
    }

    var ruleStr = rule.toString();
    if (!ruleStr) return false;
    var insertionIndex = getValidRuleInsertionIndex(nativeParent, index);

    var nativeRule = _insertRule(nativeParent, ruleStr, insertionIndex);

    if (nativeRule === false) {
      return false;
    }

    this.hasInsertedRules = true;
    this.refCssRule(rule, insertionIndex, nativeRule);
    return nativeRule;
  };

  _proto.refCssRule = function refCssRule(rule, index, cssRule) {
    rule.renderable = cssRule; // We only want to reference the top level rules, deleteRule API doesn't support removing nested rules
    // like rules inside media queries or keyframes

    if (rule.options.parent instanceof StyleSheet) {
      this.cssRules.splice(index, 0, cssRule);
    }
  }
  /**
   * Delete a rule.
   */
  ;

  _proto.deleteRule = function deleteRule(cssRule) {
    var sheet = this.element.sheet;
    var index = this.indexOf(cssRule);
    if (index === -1) return false;
    sheet.deleteRule(index);
    this.cssRules.splice(index, 1);
    return true;
  }
  /**
   * Get index of a CSS Rule.
   */
  ;

  _proto.indexOf = function indexOf(cssRule) {
    return this.cssRules.indexOf(cssRule);
  }
  /**
   * Generate a new CSS rule and replace the existing one.
   */
  ;

  _proto.replaceRule = function replaceRule(cssRule, rule) {
    var index = this.indexOf(cssRule);
    if (index === -1) return false;
    this.element.sheet.deleteRule(index);
    this.cssRules.splice(index, 1);
    return this.insertRule(rule, index);
  }
  /**
   * Get all rules elements.
   */
  ;

  _proto.getRules = function getRules() {
    return this.element.sheet.cssRules;
  };

  return DomRenderer;
}();

var instanceCounter = 0;

var Jss =
/*#__PURE__*/
function () {
  function Jss(options) {
    this.id = instanceCounter++;
    this.version = "10.10.0";
    this.plugins = new PluginsRegistry();
    this.options = {
      id: {
        minify: false
      },
      createGenerateId: createGenerateId,
      Renderer: isBrowser ? DomRenderer : null,
      plugins: []
    };
    this.generateId = createGenerateId({
      minify: false
    });

    for (var i = 0; i < plugins.length; i++) {
      this.plugins.use(plugins[i], {
        queue: 'internal'
      });
    }

    this.setup(options);
  }
  /**
   * Prepares various options, applies plugins.
   * Should not be used twice on the same instance, because there is no plugins
   * deduplication logic.
   */


  var _proto = Jss.prototype;

  _proto.setup = function setup(options) {
    if (options === void 0) {
      options = {};
    }

    if (options.createGenerateId) {
      this.options.createGenerateId = options.createGenerateId;
    }

    if (options.id) {
      this.options.id = _extends({}, this.options.id, options.id);
    }

    if (options.createGenerateId || options.id) {
      this.generateId = this.options.createGenerateId(this.options.id);
    }

    if (options.insertionPoint != null) this.options.insertionPoint = options.insertionPoint;

    if ('Renderer' in options) {
      this.options.Renderer = options.Renderer;
    } // eslint-disable-next-line prefer-spread


    if (options.plugins) this.use.apply(this, options.plugins);
    return this;
  }
  /**
   * Create a Style Sheet.
   */
  ;

  _proto.createStyleSheet = function createStyleSheet(styles, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        index = _options.index;

    if (typeof index !== 'number') {
      index = sheets.index === 0 ? 0 : sheets.index + 1;
    }

    var sheet = new StyleSheet(styles, _extends({}, options, {
      jss: this,
      generateId: options.generateId || this.generateId,
      insertionPoint: this.options.insertionPoint,
      Renderer: this.options.Renderer,
      index: index
    }));
    this.plugins.onProcessSheet(sheet);
    return sheet;
  }
  /**
   * Detach the Style Sheet and remove it from the registry.
   */
  ;

  _proto.removeStyleSheet = function removeStyleSheet(sheet) {
    sheet.detach();
    sheets.remove(sheet);
    return this;
  }
  /**
   * Create a rule without a Style Sheet.
   * [Deprecated] will be removed in the next major version.
   */
  ;

  _proto.createRule = function createRule$1(name, style, options) {
    if (style === void 0) {
      style = {};
    }

    if (options === void 0) {
      options = {};
    }

    // Enable rule without name for inline styles.
    if (typeof name === 'object') {
      return this.createRule(undefined, name, style);
    }

    var ruleOptions = _extends({}, options, {
      name: name,
      jss: this,
      Renderer: this.options.Renderer
    });

    if (!ruleOptions.generateId) ruleOptions.generateId = this.generateId;
    if (!ruleOptions.classes) ruleOptions.classes = {};
    if (!ruleOptions.keyframes) ruleOptions.keyframes = {};

    var rule = createRule(name, style, ruleOptions);

    if (rule) this.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Register plugin. Passed function will be invoked with a rule instance.
   */
  ;

  _proto.use = function use() {
    var _this = this;

    for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
      plugins[_key] = arguments[_key];
    }

    plugins.forEach(function (plugin) {
      _this.plugins.use(plugin);
    });
    return this;
  };

  return Jss;
}();

var createJss = function createJss(options) {
  return new Jss(options);
};

/**
 * SheetsManager is like a WeakMap which is designed to count StyleSheet
 * instances and attach/detach automatically.
 * Used in react-jss.
 */

var SheetsManager =
/*#__PURE__*/
function () {
  function SheetsManager() {
    this.length = 0;
    this.sheets = new WeakMap();
  }

  var _proto = SheetsManager.prototype;

  _proto.get = function get(key) {
    var entry = this.sheets.get(key);
    return entry && entry.sheet;
  };

  _proto.add = function add(key, sheet) {
    if (this.sheets.has(key)) return;
    this.length++;
    this.sheets.set(key, {
      sheet: sheet,
      refs: 0
    });
  };

  _proto.manage = function manage(key) {
    var entry = this.sheets.get(key);

    if (entry) {
      if (entry.refs === 0) {
        entry.sheet.attach();
      }

      entry.refs++;
      return entry.sheet;
    }
    return undefined;
  };

  _proto.unmanage = function unmanage(key) {
    var entry = this.sheets.get(key);

    if (entry) {
      if (entry.refs > 0) {
        entry.refs--;
        if (entry.refs === 0) entry.sheet.detach();
      }
    }
  };

  _createClass(SheetsManager, [{
    key: "size",
    get: function get() {
      return this.length;
    }
  }]);

  return SheetsManager;
}();

/**
* Export a constant indicating if this browser has CSSTOM support.
* https://developers.google.com/web/updates/2018/03/cssom
*/
var hasCSSTOMSupport = typeof CSS === 'object' && CSS != null && 'number' in CSS;

/**
 * Extracts a styles object with only props that contain function values.
 */
function getDynamicStyles(styles) {
  var to = null;

  for (var key in styles) {
    var value = styles[key];
    var type = typeof value;

    if (type === 'function') {
      if (!to) to = {};
      to[key] = value;
    } else if (type === 'object' && value !== null && !Array.isArray(value)) {
      var extracted = getDynamicStyles(value);

      if (extracted) {
        if (!to) to = {};
        to[key] = extracted;
      }
    }
  }

  return to;
}

/**
 * A better abstraction over CSS.
 *
 * @copyright Oleg Isonen (Slobodskoi) / Isonen 2014-present
 * @website https://github.com/cssinjs/jss
 * @license MIT
 */
var index = createJss();

var jss_esm = /*#__PURE__*/Object.freeze({
  __proto__: null,
  RuleList: RuleList,
  SheetsManager: SheetsManager,
  SheetsRegistry: SheetsRegistry,
  create: createJss,
  createGenerateId: createGenerateId,
  createRule: createRule,
  default: index,
  getDynamicStyles: getDynamicStyles,
  hasCSSTOMSupport: hasCSSTOMSupport,
  sheets: sheets,
  toCssValue: toCssValue
});

var at = '@global';
var atPrefix = '@global ';

var GlobalContainerRule =
/*#__PURE__*/
function () {
  function GlobalContainerRule(key, styles, options) {
    this.type = 'global';
    this.at = at;
    this.isProcessed = false;
    this.key = key;
    this.options = options;
    this.rules = new RuleList(_extends({}, options, {
      parent: this
    }));

    for (var selector in styles) {
      this.rules.add(selector, styles[selector]);
    }

    this.rules.process();
  }
  /**
   * Get a rule.
   */


  var _proto = GlobalContainerRule.prototype;

  _proto.getRule = function getRule(name) {
    return this.rules.get(name);
  }
  /**
   * Create and register rule, run plugins.
   */
  ;

  _proto.addRule = function addRule(name, style, options) {
    var rule = this.rules.add(name, style, options);
    if (rule) this.options.jss.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Replace rule, run plugins.
   */
  ;

  _proto.replaceRule = function replaceRule(name, style, options) {
    var newRule = this.rules.replace(name, style, options);
    if (newRule) this.options.jss.plugins.onProcessRule(newRule);
    return newRule;
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    return this.rules.toString(options);
  };

  return GlobalContainerRule;
}();

var GlobalPrefixedRule =
/*#__PURE__*/
function () {
  function GlobalPrefixedRule(key, style, options) {
    this.type = 'global';
    this.at = at;
    this.isProcessed = false;
    this.key = key;
    this.options = options;
    var selector = key.substr(atPrefix.length);
    this.rule = options.jss.createRule(selector, style, _extends({}, options, {
      parent: this
    }));
  }

  var _proto2 = GlobalPrefixedRule.prototype;

  _proto2.toString = function toString(options) {
    return this.rule ? this.rule.toString(options) : '';
  };

  return GlobalPrefixedRule;
}();

var separatorRegExp$1 = /\s*,\s*/g;

function addScope(selector, scope) {
  var parts = selector.split(separatorRegExp$1);
  var scoped = '';

  for (var i = 0; i < parts.length; i++) {
    scoped += scope + " " + parts[i].trim();
    if (parts[i + 1]) scoped += ', ';
  }

  return scoped;
}

function handleNestedGlobalContainerRule(rule, sheet) {
  var options = rule.options,
      style = rule.style;
  var rules = style ? style[at] : null;
  if (!rules) return;

  for (var name in rules) {
    sheet.addRule(name, rules[name], _extends({}, options, {
      selector: addScope(name, rule.selector)
    }));
  }

  delete style[at];
}

function handlePrefixedGlobalRule(rule, sheet) {
  var options = rule.options,
      style = rule.style;

  for (var prop in style) {
    if (prop[0] !== '@' || prop.substr(0, at.length) !== at) continue;
    var selector = addScope(prop.substr(at.length), rule.selector);
    sheet.addRule(selector, style[prop], _extends({}, options, {
      selector: selector
    }));
    delete style[prop];
  }
}
/**
 * Convert nested rules to separate, remove them from original styles.
 */


function jssGlobal() {
  function onCreateRule(name, styles, options) {
    if (!name) return null;

    if (name === at) {
      return new GlobalContainerRule(name, styles, options);
    }

    if (name[0] === '@' && name.substr(0, atPrefix.length) === atPrefix) {
      return new GlobalPrefixedRule(name, styles, options);
    }

    var parent = options.parent;

    if (parent) {
      if (parent.type === 'global' || parent.options.parent && parent.options.parent.type === 'global') {
        options.scoped = false;
      }
    }

    if (!options.selector && options.scoped === false) {
      options.selector = name;
    }

    return null;
  }

  function onProcessRule(rule, sheet) {
    if (rule.type !== 'style' || !sheet) return;
    handleNestedGlobalContainerRule(rule, sheet);
    handlePrefixedGlobalRule(rule, sheet);
  }

  return {
    onCreateRule: onCreateRule,
    onProcessRule: onProcessRule
  };
}

var separatorRegExp = /\s*,\s*/g;
var parentRegExp = /&/g;
var refRegExp = /\$([\w-]+)/g;
/**
 * Convert nested rules to separate, remove them from original styles.
 */

function jssNested() {
  // Get a function to be used for $ref replacement.
  function getReplaceRef(container, sheet) {
    return function (match, key) {
      var rule = container.getRule(key) || sheet && sheet.getRule(key);

      if (rule) {
        return rule.selector;
      }
      return key;
    };
  }

  function replaceParentRefs(nestedProp, parentProp) {
    var parentSelectors = parentProp.split(separatorRegExp);
    var nestedSelectors = nestedProp.split(separatorRegExp);
    var result = '';

    for (var i = 0; i < parentSelectors.length; i++) {
      var parent = parentSelectors[i];

      for (var j = 0; j < nestedSelectors.length; j++) {
        var nested = nestedSelectors[j];
        if (result) result += ', '; // Replace all & by the parent or prefix & with the parent.

        result += nested.indexOf('&') !== -1 ? nested.replace(parentRegExp, parent) : parent + " " + nested;
      }
    }

    return result;
  }

  function getOptions(rule, container, prevOptions) {
    // Options has been already created, now we only increase index.
    if (prevOptions) return _extends({}, prevOptions, {
      index: prevOptions.index + 1
    });
    var nestingLevel = rule.options.nestingLevel;
    nestingLevel = nestingLevel === undefined ? 1 : nestingLevel + 1;

    var options = _extends({}, rule.options, {
      nestingLevel: nestingLevel,
      index: container.indexOf(rule) + 1 // We don't need the parent name to be set options for chlid.

    });

    delete options.name;
    return options;
  }

  function onProcessStyle(style, rule, sheet) {
    if (rule.type !== 'style') return style;
    var styleRule = rule;
    var container = styleRule.options.parent;
    var options;
    var replaceRef;

    for (var prop in style) {
      var isNested = prop.indexOf('&') !== -1;
      var isNestedConditional = prop[0] === '@';
      if (!isNested && !isNestedConditional) continue;
      options = getOptions(styleRule, container, options);

      if (isNested) {
        var selector = replaceParentRefs(prop, styleRule.selector); // Lazily create the ref replacer function just once for
        // all nested rules within the sheet.

        if (!replaceRef) replaceRef = getReplaceRef(container, sheet); // Replace all $refs.

        selector = selector.replace(refRegExp, replaceRef);
        var name = styleRule.key + "-" + prop;

        if ('replaceRule' in container) {
          // for backward compatibility
          container.replaceRule(name, style[prop], _extends({}, options, {
            selector: selector
          }));
        } else {
          container.addRule(name, style[prop], _extends({}, options, {
            selector: selector
          }));
        }
      } else if (isNestedConditional) {
        // Place conditional right after the parent rule to ensure right ordering.
        container.addRule(prop, {}, options).addRule(styleRule.key, style[prop], {
          selector: styleRule.selector
        });
      }

      delete style[prop];
    }

    return style;
  }

  return {
    onProcessStyle: onProcessStyle
  };
}

/* eslint-disable no-var, prefer-template */
var uppercasePattern = /[A-Z]/g;
var msPattern = /^ms-/;
var cache = {};

function toHyphenLower(match) {
  return '-' + match.toLowerCase()
}

function hyphenateStyleName(name) {
  if (cache.hasOwnProperty(name)) {
    return cache[name]
  }

  var hName = name.replace(uppercasePattern, toHyphenLower);
  return (cache[name] = msPattern.test(hName) ? '-' + hName : hName)
}

/**
 * Convert camel cased property names to dash separated.
 */

function convertCase(style) {
  var converted = {};

  for (var prop in style) {
    var key = prop.indexOf('--') === 0 ? prop : hyphenateStyleName(prop);
    converted[key] = style[prop];
  }

  if (style.fallbacks) {
    if (Array.isArray(style.fallbacks)) converted.fallbacks = style.fallbacks.map(convertCase);else converted.fallbacks = convertCase(style.fallbacks);
  }

  return converted;
}
/**
 * Allow camel cased property names by converting them back to dasherized.
 */


function camelCase() {
  function onProcessStyle(style) {
    if (Array.isArray(style)) {
      // Handle rules like @font-face, which can have multiple styles in an array
      for (var index = 0; index < style.length; index++) {
        style[index] = convertCase(style[index]);
      }

      return style;
    }

    return convertCase(style);
  }

  function onChangeValue(value, prop, rule) {
    if (prop.indexOf('--') === 0) {
      return value;
    }

    var hyphenatedProp = hyphenateStyleName(prop); // There was no camel case in place

    if (prop === hyphenatedProp) return value;
    rule.prop(hyphenatedProp, value); // Core will ignore that property value we set the proper one above.

    return null;
  }

  return {
    onProcessStyle: onProcessStyle,
    onChangeValue: onChangeValue
  };
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var _tslib$1 = {};

(function (exports) {

	Object.defineProperty(exports, '__esModule', { value: true });

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */

	exports.__assign = function () {
		exports.__assign =
			Object.assign ||
			function __assign(t) {
				for (var s, i = 1, n = arguments.length; i < n; i++) {
					s = arguments[i];
					for (var p in s)
						if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
				}
				return t;
			};
		return exports.__assign.apply(this, arguments);
	}; 
} (_tslib$1));

var require$$1 = /*@__PURE__*/getAugmentedNamespace(jss_esm);

/**
 * The custom `sort` method for
 * for the [`css-mqpacker`](https://www.npmjs.com/package/css-mqpacker) or
 * [`pleeease`](https://www.npmjs.com/package/pleeease) which using `css-mqpacker`
 * or, perhaps, something else ))
 *
 * @module sort-css-media-queries
 * @author Oleg Dutchenko <dutchenko.o.wezom@gmail.com>
 * @version 1.5.0
 */

// ----------------------------------------
// Private
// ----------------------------------------

const minMaxWidth = /(!?\(\s*min(-device-)?-width)(.|\n)+\(\s*max(-device)?-width/i;
const minWidth = /\(\s*min(-device)?-width/i;
const maxMinWidth = /(!?\(\s*max(-device)?-width)(.|\n)+\(\s*min(-device)?-width/i;
const maxWidth = /\(\s*max(-device)?-width/i;

const isMinWidth = _testQuery(minMaxWidth, maxMinWidth, minWidth);
const isMaxWidth = _testQuery(maxMinWidth, minMaxWidth, maxWidth);

const minMaxHeight = /(!?\(\s*min(-device)?-height)(.|\n)+\(\s*max(-device)?-height/i;
const minHeight = /\(\s*min(-device)?-height/i;
const maxMinHeight = /(!?\(\s*max(-device)?-height)(.|\n)+\(\s*min(-device)?-height/i;
const maxHeight = /\(\s*max(-device)?-height/i;

const isMinHeight = _testQuery(minMaxHeight, maxMinHeight, minHeight);
const isMaxHeight = _testQuery(maxMinHeight, minMaxHeight, maxHeight);

const isPrint = /print/i;
const isPrintOnly = /^print$/i;

const maxValue = Number.MAX_VALUE;

/**
 * Obtain the length of the media request in pixels.
 * Copy from original source `function inspectLength (length)`
 * {@link https://github.com/hail2u/node-css-mqpacker/blob/master/index.js#L58}
 * @private
 * @param {string} length
 * @return {number}
 */
function _getQueryLength (length) {
  length = /(-?\d*\.?\d+)(ch|em|ex|px|rem)/.exec(length);

  if (length === null) {
    return maxValue
  }

  let number = length[1];
  const unit = length[2];

  switch (unit) {
    case 'ch':
      number = parseFloat(number) * 8.8984375;
      break

    case 'em':
    case 'rem':
      number = parseFloat(number) * 16;
      break

    case 'ex':
      number = parseFloat(number) * 8.296875;
      break

    case 'px':
      number = parseFloat(number);
      break
  }

  return +number
}

/**
 * Wrapper for creating test functions
 * @private
 * @param {RegExp} doubleTestTrue
 * @param {RegExp} doubleTestFalse
 * @param {RegExp} singleTest
 * @return {Function}
 */
function _testQuery (doubleTestTrue, doubleTestFalse, singleTest) {
  /**
   * @param {string} query
   * @return {boolean}
   */
  return function (query) {
    if (doubleTestTrue.test(query)) {
      return true
    } else if (doubleTestFalse.test(query)) {
      return false
    }
    return singleTest.test(query)
  }
}

/**
 * @private
 * @param {string} a
 * @param {string} b
 * @return {number|null}
 */
function _testIsPrint (a, b) {
  const isPrintA = isPrint.test(a);
  const isPrintOnlyA = isPrintOnly.test(a);

  const isPrintB = isPrint.test(b);
  const isPrintOnlyB = isPrintOnly.test(b);

  if (isPrintA && isPrintB) {
    if (!isPrintOnlyA && isPrintOnlyB) {
      return 1
    }
    if (isPrintOnlyA && !isPrintOnlyB) {
      return -1
    }
    return a.localeCompare(b)
  }
  if (isPrintA) {
    return 1
  }
  if (isPrintB) {
    return -1
  }

  return null
}

// ----------------------------------------
// Public
// ----------------------------------------

/**
 * Sorting an array with media queries
 * according to the mobile-first methodology.
 * @param {string} a
 * @param {string} b
 * @return {number} 1 / 0 / -1
 */
function sortCSSmq$1 (a, b) {
  const testIsPrint = _testIsPrint(a, b);
  if (testIsPrint !== null) {
    return testIsPrint
  }

  const minA = isMinWidth(a) || isMinHeight(a);
  const maxA = isMaxWidth(a) || isMaxHeight(a);

  const minB = isMinWidth(b) || isMinHeight(b);
  const maxB = isMaxWidth(b) || isMaxHeight(b);

  if (minA && maxB) {
    return -1
  }
  if (maxA && minB) {
    return 1
  }

  let lengthA = _getQueryLength(a);
  let lengthB = _getQueryLength(b);

  if (lengthA === maxValue && lengthB === maxValue) {
    return a.localeCompare(b)
  } else if (lengthA === maxValue) {
    return 1
  } else if (lengthB === maxValue) {
    return -1
  }

  if (lengthA > lengthB) {
    if (maxA) {
      return -1
    }
    return 1
  }

  if (lengthA < lengthB) {
    if (maxA) {
      return 1
    }
    return -1
  }

  return a.localeCompare(b)
}

/**
 * Sorting an array with media queries
 * according to the desktop-first methodology.
 * @param {string} a
 * @param {string} b
 * @return {number} 1 / 0 / -1
 */
sortCSSmq$1.desktopFirst = function (a, b) {
  const testIsPrint = _testIsPrint(a, b);
  if (testIsPrint !== null) {
    return testIsPrint
  }

  const minA = isMinWidth(a) || isMinHeight(a);
  const maxA = isMaxWidth(a) || isMaxHeight(a);

  const minB = isMinWidth(b) || isMinHeight(b);
  const maxB = isMaxWidth(b) || isMaxHeight(b);

  if (minA && maxB) {
    return 1
  }
  if (maxA && minB) {
    return -1
  }

  const lengthA = _getQueryLength(a);
  const lengthB = _getQueryLength(b);

  if (lengthA === maxValue && lengthB === maxValue) {
    return a.localeCompare(b)
  } else if (lengthA === maxValue) {
    return 1
  } else if (lengthB === maxValue) {
    return -1
  }

  if (lengthA > lengthB) {
    if (maxA) {
      return -1
    }
    return 1
  }

  if (lengthA < lengthB) {
    if (maxA) {
      return 1
    }
    return -1
  }

  return -(a.localeCompare(b))
};

// ----------------------------------------
// Exports
// ----------------------------------------

var sortCssMediaQueries = sortCSSmq$1;

var _tslib = _tslib$1;
var jss$1 = require$$1;
var sortCSSmq = sortCssMediaQueries;

function _interopDefaultLegacy(e) {
	return e && typeof e === 'object' && 'default' in e ? e : { default: e };
}

var sortCSSmq__default = /*#__PURE__*/ _interopDefaultLegacy(sortCSSmq);

function isPlainObject(sample) {
	return (
		sample !== null && typeof sample === 'object' && Array.isArray(sample) === false
	);
}
var UN_QUERIED = '__UN_QUERIED';
function recursiveInnerAndGetQueries(pluginOptions, rules) {
	var queries = {
		groups: {},
		groupsSortNames: []
	};
	for (var index = 0; index < rules.length; index++) {
		var rule = rules[index];
		var query =
			rule.type === 'conditional' && typeof rule.query === 'string'
				? rule.query
				: UN_QUERIED;
		if (!queries.groups.hasOwnProperty(query)) {
			queries.groupsSortNames.push(query);
			queries.groups[query] = [];
		}
		queries.groups[query].push(index);
		// eslint-disable-next-line @typescript-eslint/no-use-before-define
		recursive(pluginOptions, rule);
	}
	queries.groupsSortNames.sort(function (a, b) {
		var aWeight = a === UN_QUERIED ? 0 : a.length;
		var bWeight = b === UN_QUERIED ? 0 : b.length;
		if (aWeight > 0 && bWeight > 0) {
			if (pluginOptions.desktopFirst) {
				return sortCSSmq__default['default'].desktopFirst(a, b);
			} else {
				return sortCSSmq__default['default'](a, b);
			}
		} else {
			return aWeight - bWeight;
		}
	});
	return queries;
}
function recursive(pluginOptions, data) {
	if (isPlainObject(data) && data.rules instanceof jss$1.RuleList) {
		data.rules.toString = function (options) {
			if (options === void 0) {
				options = {};
			}
			var str = '';
			var sheet = this.options.sheet;
			var link = sheet ? sheet.options.link : false;
			var _a = recursiveInnerAndGetQueries(pluginOptions, this.index),
				groups = _a.groups,
				groupsSortNames = _a.groupsSortNames;
			for (var i = 0; i < groupsSortNames.length; i++) {
				var groupName = groupsSortNames[i];
				var group = groups[groupsSortNames[i]];
				if (groupName !== UN_QUERIED && pluginOptions.combineMediaQueries) {
					str += '\n' + groupName + ' {';
					for (var i_1 = 0; i_1 < group.length; i_1++) {
						var rule = this.index[group[i_1]];
						var css = rule.rules.toString(
							_tslib.__assign(_tslib.__assign({}, options), {
								indent: (options.indent || 0) + 1
							})
						);
						if (!css && !link) continue;
						if (str) str += '\n';
						str += css;
					}
					str += '\n}\n';
				} else {
					for (var i_2 = 0; i_2 < group.length; i_2++) {
						var rule = this.index[group[i_2]];
						var css = rule.toString(options);
						if (!css && !link) continue;
						if (str) str += '\n';
						str += css;
					}
				}
			}
			return str;
		};
	}
}
function jssCombineAndSortMQ(options) {
	if (options === void 0) {
		options = {};
	}
	return {
		onProcessSheet: function (sheet) {
			recursive(options, sheet);
		}
	};
}

var dist = jssCombineAndSortMQ;

var jssPluginSortMediaQueries = /*@__PURE__*/getDefaultExportFromCjs(dist);

const isDisabledOrLoading = (disabled, loading) => {
    return disabled || loading;
};

const hasWindow = typeof window !== 'undefined';

const isHighContrastMode = hasWindow && window.matchMedia?.('(forced-colors: active)').matches;

const attributeMutationMap = new Map();
hasWindow &&
    new MutationObserver((mutations) => {
        mutations
            // reduce array to only entries that have really a changed value
            .filter((mutation) => mutation.oldValue !== mutation.target.getAttribute(mutation.attributeName))
            // remove duplicates so we execute callback only once per node
            .filter((mutation, idx, arr) => arr.findIndex((m) => m.target === mutation.target) === idx)
            .forEach((mutation) => attributeMutationMap.get(mutation.target)?.());
    });

const parseJSON = (prop) => {
    if (typeof prop === 'string') {
        try {
            // prop is potentially JSON parsable string, e.g. "{ base: 'block', l: 'inline' }" or "true" or "false"
            return JSON.parse(prop
                .replace(/'/g, '"') // convert single quotes to double quotes
                .replace(/[\s"]?([a-z]+)[\s"]?:([^//])/g, '"$1":$2') // wrap keys in double quotes if they don't have them but ignore potential urls
            );
        }
        catch {
            // prop is string, e.g. "block" or "inline"
            return prop;
        }
    }
    else {
        // prop is object, e.g. { base: 'block', l: 'inline' } or number, e.g. 123 or boolean, e.g. true
        return prop;
    }
};

const borderRadiusSmall = '4px';

const borderRadiusMedium = '8px';

const borderRadiusLarge = '12px';

const borderWidthBase = '2px';

const _dropShadowBackgroundColor = 'rgba(0, 0, 0, 0.16)';

const dropShadowLowStyle = {
    boxShadow: `0px 3px 8px ${_dropShadowBackgroundColor}`, // filter: drop-shadow() causes visual glitches in Firefox in combination with frostedGlassStyle
};

const dropShadowHighStyle = {
    boxShadow: `0px 8px 40px ${_dropShadowBackgroundColor}`, // filter: drop-shadow() causes visual glitches in Firefox in combination with frostedGlassStyle
};

const fontFamily = "'Porsche Next','Arial Narrow',Arial,'Heiti SC',SimHei,sans-serif";

const fontHyphenationStyle = {
    overflowWrap: 'break-word',
    hyphens: 'auto',
};

const fontLineHeight = 'calc(6px + 2.125ex)';

const fontSizeTextXXSmall = '.75rem';

const fontSizeTextXSmall = 'clamp(0.81rem, 0.23vw + 0.77rem, 0.88rem)';

const fontSizeTextSmall = '1rem';

const fontSizeTextMedium = 'clamp(1.13rem, 0.21vw + 1.08rem, 1.33rem)';

const fontSizeTextLarge = 'clamp(1.27rem, 0.51vw + 1.16rem, 1.78rem)';

const fontSizeTextXLarge = 'clamp(1.42rem, 0.94vw + 1.23rem, 2.37rem)';

const fontSizeText = {
    xxSmall: fontSizeTextXXSmall,
    xSmall: fontSizeTextXSmall,
    small: fontSizeTextSmall,
    medium: fontSizeTextMedium,
    large: fontSizeTextLarge,
    xLarge: fontSizeTextXLarge,
};

const fontSizeHeadingSmall = fontSizeTextSmall;

const fontSizeHeadingMedium = fontSizeTextMedium;

const fontSizeHeadingLarge = fontSizeTextLarge;

const fontSizeHeadingXLarge = fontSizeTextXLarge;

const fontSizeHeadingXXLarge = 'clamp(1.6rem, 1.56vw + 1.29rem, 3.16rem)';

const fontSizeDisplaySmall = 'clamp(1.8rem, 2.41vw + 1.32rem, 4.21rem)';

const fontSizeDisplayMedium = 'clamp(2.03rem, 3.58vw + 1.31rem, 5.61rem)';

const fontSizeDisplayLarge = 'clamp(2.28rem, 5.2vw + 1.24rem, 7.48rem)';

const fontWeightRegular = 400;

const fontWeightSemiBold = 600;

const fontWeightBold = 700;

const fontStyleNormal = 'normal';

const fontVariant = 'normal';

const backdropFilter = 'blur(32px)';
const frostedGlassStyle = {
    WebkitBackdropFilter: backdropFilter,
    backdropFilter,
};

const _gradient = 'rgba(31,31,31,0.9) 0%,' +
    'rgba(31,31,31,0.9) 20%,' +
    'rgba(31,31,31,0.852589) 26.67%,' +
    'rgba(32,32,32,0.768225) 33.33%,' +
    'rgba(33,33,33,0.668116) 40%,' +
    'rgba(34,34,34,0.557309) 46.67%,' +
    'rgba(35,35,35,0.442691) 53.33%,' +
    'rgba(36,36,36,0.331884) 60%,' +
    'rgba(37,37,37,0.231775) 66.67%,' +
    'rgba(38,38,38,0.147411) 73.33%,' +
    'rgba(39,39,39,0.0816599) 80%,' +
    'rgba(39,39,39,0.03551) 86.67%,' +
    'rgba(39,39,39,0.0086472) 93.33%,' +
    'rgba(39,39,39,0)';

const gradientToBottomStyle = {
    background: `linear-gradient(to bottom, ${_gradient} 100%);`,
};

const gradientToTopStyle = {
    background: `linear-gradient(to top, ${_gradient} 100%);`,
};

const breakpointBase = 0;

const breakpointXS = 480;

const breakpointS = 760;

const breakpointM = 1000;

const breakpointL = 1300;

const breakpointXL = 1760;

const breakpointXXL = 1920;

const breakpoint = {
    base: breakpointBase,
    xs: breakpointXS,
    s: breakpointS,
    m: breakpointM,
    l: breakpointL,
    xl: breakpointXL,
    xxl: breakpointXXL,
};

function getMediaQueryMin(min) {
    return `@media(min-width:${breakpoint[min]}px)`;
}

const spacingFluidMedium = 'clamp(16px, 1.25vw + 12px, 36px)';

const gridGap = spacingFluidMedium;

const _gridWidthMax = '2560px';
// fluid sizing calculated by https://fluidtypography.com/#app-get-started
const _gridSafeZoneBase = 'max(22px, 10.625vw - 12px)'; // viewport-width range = 320 - 760px / size range = 22 - 68.75px
const _gridSafeZoneS = 'calc(5vw - 16px)'; // viewport-width range = 760 - 1920px / size range = 22(22.75) - 80(79.71)px
const _gridSafeZoneXXL = 'min(50vw - 880px, 400px)'; // viewport-width range = 1920 - 2560px / size range = 80(79.71)px - 400(399.71)px

const columnMap = {
    narrow: 4,
    basic: 2,
    extended: 1,
};
const gridColumnWidthS = `calc((100vw - ${_gridSafeZoneS} * 2 - ${gridGap} * 15) / 16)`;
const gridColumnWidthXXL = `calc((min(100vw, ${_gridWidthMax}) - ${_gridSafeZoneXXL} * 2 - ${gridGap} * 15) / 16)`;
const _gridPadding = `max(0px, 50vw - ${_gridWidthMax} / 2)`;
const _getGridOffsetS = (width) => `calc(${_gridSafeZoneS} + (${gridGap} + ${gridColumnWidthS}) * ${columnMap[width]})`;
const _getGridOffsetXXL = (width) => `calc(${_gridPadding} + ${_gridSafeZoneXXL} + (${gridGap} + ${gridColumnWidthXXL}) * ${columnMap[width]})`;

const gridFullOffset = _gridPadding;

const gridExtendedOffsetBase = _gridSafeZoneBase;

const gridExtendedOffsetS = _getGridOffsetS('extended');

const gridExtendedOffsetXXL = _getGridOffsetXXL('extended');

const gridExtendedOffset = {
    base: gridExtendedOffsetBase,
    s: gridExtendedOffsetS,
    xxl: gridExtendedOffsetXXL,
};

const gridBasicOffsetBase = _gridSafeZoneBase;

const gridBasicOffsetS = _getGridOffsetS('basic');

const gridBasicOffsetXXL = _getGridOffsetXXL('basic');

const gridBasicOffset = {
    base: gridBasicOffsetBase,
    s: gridBasicOffsetS,
    xxl: gridBasicOffsetXXL,
};

const gridNarrowOffsetBase = _gridSafeZoneBase;

const gridNarrowOffsetS = _getGridOffsetS('narrow');

const gridNarrowOffsetXXL = _getGridOffsetXXL('narrow');

const gridNarrowOffset = {
    base: gridNarrowOffsetBase,
    s: gridNarrowOffsetS,
    xxl: gridNarrowOffsetXXL,
};

const motionDurationShort = '0.25s';

const motionEasingBase = 'cubic-bezier(0.25,0.1,0.25,1)';

const breakpoints = ['base', 'xs', 's', 'm', 'l', 'xl', 'xxl'];

function getMediaQueryMax(max) {
    return `@media(max-width:${breakpoint[max] - 1}px)`;
}

const motionDurationLong = '0.6s';

const motionDurationModerate = '0.4s';

const motionDurationVeryLong = '1.2s';

const motionEasingIn = 'cubic-bezier(0,0,0.2,1)';

const motionEasingOut = 'cubic-bezier(0.4,0,0.5,1)';

const spacingStaticXSmall = '4px';

const spacingStaticSmall = '8px';

const spacingStaticMedium = '16px';

const spacingStaticLarge = '32px';

const spacingFluidXSmall = 'clamp(4px, 0.25vw + 3px, 8px)';

const spacingFluidSmall = 'clamp(8px, 0.5vw + 6px, 16px)';

const spacingFluidLarge = 'clamp(32px, 2.75vw + 23px, 76px)';

const themeLightBackgroundShading = 'rgba(1, 2, 5, 0.67)';

const themeDarkBackgroundShading = 'rgba(38, 38, 41, 0.67)';

const _displayFontPartA = `${fontStyleNormal} ${fontVariant} ${fontWeightRegular} `;
const _displayFontPartB = `/${fontLineHeight} ${fontFamily}`;

const displayMediumStyle = {
    font: `${_displayFontPartA}${fontSizeDisplayMedium}${_displayFontPartB}`,
};

const displayLargeStyle = {
    font: `${_displayFontPartA}${fontSizeDisplayLarge}${_displayFontPartB}`,
};

const _headingFontPartA = `${fontStyleNormal} ${fontVariant} ${fontWeightSemiBold} `;
const _headingFontPartB = `/${fontLineHeight} ${fontFamily}`;

const headingSmallStyle = {
    font: `${_headingFontPartA}${fontSizeHeadingSmall}${_headingFontPartB}`,
};

const headingMediumStyle = {
    font: `${_headingFontPartA}${fontSizeHeadingMedium}${_headingFontPartB}`,
};

const headingLargeStyle = {
    font: `${_headingFontPartA}${fontSizeHeadingLarge}${_headingFontPartB}`,
};

const headingXLargeStyle = {
    font: `${_headingFontPartA}${fontSizeHeadingXLarge}${_headingFontPartB}`,
};

const headingXXLargeStyle = {
    font: `${_headingFontPartA}${fontSizeHeadingXXLarge}${_headingFontPartB}`,
};

const _textFontPartA = `${fontStyleNormal} ${fontVariant} ${fontWeightRegular} `;
const _textFontPartB = `/${fontLineHeight} ${fontFamily}`;

const textXXSmallStyle = {
    font: `${_textFontPartA}${fontSizeTextXXSmall}${_textFontPartB}`,
    ...fontHyphenationStyle,
};

const textXSmallStyle = {
    font: `${_textFontPartA}${fontSizeTextXSmall}${_textFontPartB}`,
    ...fontHyphenationStyle,
};

const textSmallStyle = {
    font: `${_textFontPartA}${fontSizeTextSmall}${_textFontPartB}`,
    ...fontHyphenationStyle,
};

const textLargeStyle = {
    font: `${_textFontPartA}${fontSizeTextLarge}${_textFontPartB}`,
    ...fontHyphenationStyle,
};

const mediaQueries = Object.values(breakpoint).map((v) => `(min-width:${v}px)`);
hasWindow && window.matchMedia ? mediaQueries.map(window.matchMedia) : [];

Object.entries(breakpoint).reduce((result, [key, val]) => ({ ...result, [`${val}px`]: key }), {});

const hasVisibleIcon = (iconName, iconSource) => {
    return iconName !== 'none' || !!iconSource;
};

/**
 * Map of observed nodes and their corresponding callback functions.
 */
const observedNodesMap = new Map();
/**
 * Mutation observer for observing changes in the children of observed nodes.
 */
hasWindow &&
    new MutationObserver((mutations) => {
        // there may be race conditions in jsdom-polyfill tests  where the map is already empty when a mutation happens
        if (observedNodesMap.size) {
            const observedNodes = Array.from(observedNodesMap.keys());
            mutations
                // remove duplicates so we execute callback only once per node
                .filter((mutation, idx, arr) => arr.findIndex((m) => m.target === mutation.target) === idx)
                // find all observing parent nodes of mutated node and invoke their callbacks
                .forEach((mutation) => {
                observedNodes
                    .filter((node) => node.contains(mutation.target))
                    .forEach((node) => observedNodesMap.get(node)?.());
            });
        }
    });

/* eslint-disable no-undefined,no-param-reassign,no-shadow */

/**
 * Throttle execution of a function. Especially useful for rate limiting
 * execution of handlers on events like resize and scroll.
 *
 * @param {number} delay -                  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher)
 *                                            are most useful.
 * @param {Function} callback -               A function to be executed after delay milliseconds. The `this` context and all arguments are passed through,
 *                                            as-is, to `callback` when the throttled-function is executed.
 * @param {object} [options] -              An object to configure options.
 * @param {boolean} [options.noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds
 *                                            while the throttled-function is being called. If noTrailing is false or unspecified, callback will be executed
 *                                            one final time after the last throttled-function call. (After the throttled-function has not been called for
 *                                            `delay` milliseconds, the internal counter is reset).
 * @param {boolean} [options.noLeading] -   Optional, defaults to false. If noLeading is false, the first throttled-function call will execute callback
 *                                            immediately. If noLeading is true, the first the callback execution will be skipped. It should be noted that
 *                                            callback will never executed if both noLeading = true and noTrailing = true.
 * @param {boolean} [options.debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is
 *                                            false (at end), schedule `callback` to execute after `delay` ms.
 *
 * @returns {Function} A new, throttled, function.
 */
function throttle (delay, callback, options) {
  var _ref = options || {},
      _ref$noTrailing = _ref.noTrailing,
      noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing,
      _ref$noLeading = _ref.noLeading,
      noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading,
      _ref$debounceMode = _ref.debounceMode,
      debounceMode = _ref$debounceMode === void 0 ? undefined : _ref$debounceMode;
  /*
   * After wrapper has stopped being called, this timeout ensures that
   * `callback` is executed at the proper times in `throttle` and `end`
   * debounce modes.
   */


  var timeoutID;
  var cancelled = false; // Keep track of the last time `callback` was executed.

  var lastExec = 0; // Function to clear existing timeout

  function clearExistingTimeout() {
    if (timeoutID) {
      clearTimeout(timeoutID);
    }
  } // Function to cancel next exec


  function cancel(options) {
    var _ref2 = options || {},
        _ref2$upcomingOnly = _ref2.upcomingOnly,
        upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;

    clearExistingTimeout();
    cancelled = !upcomingOnly;
  }
  /*
   * The `wrapper` function encapsulates all of the throttling / debouncing
   * functionality and when executed will limit the rate at which `callback`
   * is executed.
   */


  function wrapper() {
    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
      arguments_[_key] = arguments[_key];
    }

    var self = this;
    var elapsed = Date.now() - lastExec;

    if (cancelled) {
      return;
    } // Execute `callback` and update the `lastExec` timestamp.


    function exec() {
      lastExec = Date.now();
      callback.apply(self, arguments_);
    }
    /*
     * If `debounceMode` is true (at begin) this is used to clear the flag
     * to allow future `callback` executions.
     */


    function clear() {
      timeoutID = undefined;
    }

    if (!noLeading && debounceMode && !timeoutID) {
      /*
       * Since `wrapper` is being called for the first time and
       * `debounceMode` is true (at begin), execute `callback`
       * and noLeading != true.
       */
      exec();
    }

    clearExistingTimeout();

    if (debounceMode === undefined && elapsed > delay) {
      if (noLeading) {
        /*
         * In throttle mode with noLeading, if `delay` time has
         * been exceeded, update `lastExec` and schedule `callback`
         * to execute after `delay` ms.
         */
        lastExec = Date.now();

        if (!noTrailing) {
          timeoutID = setTimeout(debounceMode ? clear : exec, delay);
        }
      } else {
        /*
         * In throttle mode without noLeading, if `delay` time has been exceeded, execute
         * `callback`.
         */
        exec();
      }
    } else if (noTrailing !== true) {
      /*
       * In trailing throttle mode, since `delay` time has not been
       * exceeded, schedule `callback` to execute `delay` ms after most
       * recent execution.
       *
       * If `debounceMode` is true (at begin), schedule `clear` to execute
       * after `delay` ms.
       *
       * If `debounceMode` is false (at end), schedule `callback` to
       * execute after `delay` ms.
       */
      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
    }
  }

  wrapper.cancel = cancel; // Return the wrapper function.

  return wrapper;
}

/* eslint-disable no-undefined */
/**
 * Debounce execution of a function. Debouncing, unlike throttling,
 * guarantees that a function is only executed a single time, either at the
 * very beginning of a series of calls, or at the very end.
 *
 * @param {number} delay -               A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param {Function} callback -          A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
 *                                        to `callback` when the debounced-function is executed.
 * @param {object} [options] -           An object to configure options.
 * @param {boolean} [options.atBegin] -  Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds
 *                                        after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.
 *                                        (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).
 *
 * @returns {Function} A new, debounced function.
 */

function debounce (delay, callback, options) {
  var _ref = options || {},
      _ref$atBegin = _ref.atBegin,
      atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;

  return throttle(delay, callback, {
    debounceMode: atBegin !== false
  });
}

debounce(800, (el, ariaElement) => {
    ariaElement.innerText = `You have ${el.maxLength - el.value.length} out of ${el.maxLength} characters left`;
});

/* Auto Generated Start */
const themeLight = {
    primaryColor: '#010205',
    primaryColorDarken: '#000000',
    backgroundColor: '#FFF',
    backgroundColorDarken: '#E0E0E0',
    backgroundColorLighten: '#FFFFFF',
    backgroundSurfaceColor: '#EEEFF2',
    backgroundSurfaceColorDarken: '#CBCED7',
    backgroundSurfaceColorLighten: '#FFFFFF',
    contrastLowColor: '#D8D8DB',
    contrastMediumColor: '#6B6D70',
    contrastHighColor: '#535457',
    contrastHighColorDarken: '#353638',
    contrastHighColorLighten: '#717276',
    hoverColor: 'rgba(148, 149, 152, .18)',
    hoverColorDarken: '#75767A',
    activeColor: 'rgba(148, 149, 152, 0.20)',
    focusColor: '#1A44EA',
    disabledColor: '#949598',
    errorColor: '#CC1922',
    errorColorDarken: '#951219',
    errorSoftColor: '#FFE2E4',
    errorSoftColorDarken: '#F4CED1',
    errorSoftColorLighten: '#FFFFFF',
    successColor: '#197E10',
    successColorDarken: '#0E4809',
    successSoftColor: '#E4FFEC',
    successSoftColorDarken: '#D0F4DB',
    successSoftColorLighten: '#FFFFFF',
    warningColor: '#F3BE00',
    warningSoftColor: '#FFF4D2',
    warningSoftColorDarken: '#F1E5C1',
    warningSoftColorLighten: '#FCFAF3',
    infoColor: '#2762EC',
    infoSoftColor: '#D3E1FF',
    infoSoftColorDarken: '#C2D1F1',
    infoSoftColorLighten: '#F4F7FD'
};
const themeDark = {
    primaryColor: '#FBFCFF',
    primaryColorDarken: '#BECEFF',
    backgroundColor: '#0E0E12',
    backgroundColorDarken: '#000000',
    backgroundColorLighten: '#292934',
    backgroundSurfaceColor: '#212225',
    backgroundSurfaceColorDarken: '#040405',
    backgroundSurfaceColorLighten: '#3E4045',
    contrastLowColor: '#404044',
    contrastMediumColor: '#88898C',
    contrastHighColor: '#AFB0B3',
    contrastHighColorDarken: '#909195',
    contrastHighColorLighten: '#CECFD1',
    hoverColor: 'rgba(148, 149, 152, .18)',
    hoverColorDarken: '#75767A',
    activeColor: 'rgba(126, 127, 130, 0.20)',
    focusColor: '#1A44EA',
    disabledColor: '#7E7F82',
    errorColor: '#FC4040',
    errorColorDarken: '#FB0404',
    errorSoftColor: '#3A0F0F',
    errorSoftColorDarken: '#1A1111',
    errorSoftColorLighten: '#3F2828',
    successColor: '#09D087',
    successColorDarken: '#069561',
    successSoftColor: '#003320',
    successSoftColorDarken: '#04110C',
    successSoftColorLighten: '#0F432F',
    warningColor: '#F7CB47',
    warningSoftColor: '#362B0A',
    warningSoftColorDarken: '#16130B',
    warningSoftColorLighten: '#3E3720',
    infoColor: '#178BFF',
    infoSoftColor: '#04294E',
    infoSoftColorDarken: '#0C1A27',
    infoSoftColorLighten: '#1A3856'
};
const themeAuto = {
    ...themeLight,
};
const themes = {
    'light': themeLight,
    'dark': themeDark,
    'auto': themeAuto
};
/* Auto Generated End */
const schemeHighContrastMerged = {
    disabledColor: 'GrayText',
    focusColor: 'Highlight',
};
const schemeHighContrast = {
    canvasColor: 'Canvas',
    canvasTextColor: 'CanvasText',
    highlightColor: 'Highlight',
    linkColor: 'LinkText',
};
const getThemedColors = (theme) => {
    return isHighContrastMode ? { ...themes[theme], ...schemeHighContrastMerged } : themes[theme];
};
const getHighContrastColors = () => {
    return schemeHighContrast;
};
const getInvertedThemedColors = (theme) => {
    return getThemedColors(isThemeDark(theme) ? 'light' : 'dark');
};

const motionDurationMap = {
    short: motionDurationShort,
    moderate: motionDurationModerate,
    long: motionDurationLong,
    veryLong: motionDurationVeryLong,
};
const motionEasingMap = {
    base: motionEasingBase,
    in: motionEasingIn,
    out: motionEasingOut,
    linear: 'linear',
};
const cssVariableTransitionDuration = '--p-transition-duration';
const cssVariableAnimationDuration = '--p-animation-duration';
const getTransition = (cssProperty, duration = 'short', easing = 'base', delay) => {
    return `${cssProperty} var(${cssVariableTransitionDuration}, ${motionDurationMap[duration]}) ${motionEasingMap[easing]}${delay ? ` var(${cssVariableTransitionDuration}, ${motionDurationMap[delay]})` : ''}`;
};
const addImportantToRule = (value) => `${value} !important`;
const addImportantToEachRule = (input) => {
    return Object.entries(input).reduce((result, [key, value]) => value === null
        ? result
        : ((result[key] =
            typeof value === 'object' ? addImportantToEachRule(value) : addImportantToRule(value)),
            result), {});
};
// TODO: this is workaround, in order the colors to be bundled in the main bundle, we need to have at least one function here, which is used in project and which calls "getThemedColors"
// TODO: This mechanism needs to be investigated as part of refactoring
const doGetThemedColors = (theme = 'light') => {
    return getThemedColors(theme);
};
const getFocusJssStyle = (theme, opts) => {
    const { offset = '2px', slotted = '', pseudo = false } = opts || {};
    const { focusColor } = getThemedColors(theme);
    const { focusColor: focusColorDark } = getThemedColors('dark');
    const slottedSelector = slotted && slotted !== true ? slotted : '';
    return {
        [`&${slotted ? '(' : ''}${slottedSelector}::-moz-focus-inner${slotted ? ')' : ''}`]: {
            border: 0, // reset ua-style (for FF)
        },
        [`&${slotted ? '(' : ''}${slottedSelector}:focus${slotted ? ')' : ''}`]: {
            outline: 0, // reset ua-style (for older browsers)
        },
        ...(pseudo && {
            [`&${slotted ? '(' : ''}${slottedSelector}:focus-visible${slotted ? ')' : ''}`]: {
                outline: 0, // reset ua-style (for modern browsers)
            },
        }),
        [`&${slotted ? '(' : ''}${slottedSelector}:focus-visible${slotted ? ')' : ''}${pseudo ? '::before' : ''}`]: {
            outline: `${borderWidthBase} solid ${focusColor}`,
            outlineOffset: offset,
            ...prefersColorSchemeDarkMediaQuery(theme, {
                outlineColor: focusColorDark,
            }),
        },
    };
};
// reset initial styles, e.g. in case link-pure is used with slotted anchor and nested within e.g. an accordion
const getResetInitialStylesForSlottedAnchor = {
    margin: 0,
    padding: 0,
    outline: 0, // reset native blue outline
    borderRadius: 0,
    background: 'transparent',
};
/**
 * Returns a JSS style object that can be used to visually hide text in the browser, while still allowing it to be accessed by screen readers.
 * @param {boolean} isHidden - A boolean value indicating whether the text should be hidden or not. Defaults to true.
 * @param {JssStyle} isShownJssStyle - Additional styles applied when isHidden = false
 * @returns {JssStyle} - A JSS style object containing styles depending on the value of isHidden and isShownJssStyle.
 */
const getHiddenTextJssStyle = (isHidden = true, isShownJssStyle) => {
    return isHidden
        ? {
            position: 'absolute',
            width: '1px',
            height: '1px',
            padding: 0,
            margin: '-1px',
            overflow: 'hidden',
            clip: 'rect(0,0,0,0)',
            whiteSpace: 'nowrap',
        }
        : {
            position: 'static',
            width: 'auto',
            height: 'auto',
            padding: 0,
            margin: 0,
            overflow: 'visible',
            clip: 'auto',
            whiteSpace: 'normal',
            ...isShownJssStyle,
        };
};
// TODO: there should be a shared style util for modal, flyout and flyout-navigation instead of having this code in the
//  main bundle. Or don't share it at all, in case same transition concept isn't ideal to be shared from an UI point of view.
/**
 * Generates JSS styles for a frosted glass background.
 * @param {boolean} isVisible - Determines if the frosted glass effect is visible.
 * @param {number} zIndex - The z-index to be used.
 * @param {Theme} theme - The theme to be used.
 * @param {string} duration - The duration of the transition animation.
 * @param {'blur' | 'shading'} backdrop - The backdrop variant.
 * @returns {JssStyle} - The JSS styles for the frosted glass backdrop.
 */
const getBackdropJssStyle = (isVisible, zIndex, theme, duration = 'long', backdrop = 'blur') => {
    return {
        position: 'fixed',
        inset: 0,
        zIndex,
        // TODO: background shading is missing in getThemedColors(theme).backgroundShading
        background: isThemeDark(theme) ? themeDarkBackgroundShading : themeLightBackgroundShading,
        ...prefersColorSchemeDarkMediaQuery(theme, {
            background: themeDarkBackgroundShading,
        }),
        ...(isVisible
            ? {
                visibility: 'inherit',
                pointerEvents: 'auto',
                ...(backdrop === 'blur' && frostedGlassStyle),
                opacity: 1,
            }
            : {
                visibility: 'hidden', // element shall not be tabbable after fade out transition has finished
                pointerEvents: 'none',
                ...(backdrop === 'blur' && {
                    // TODO: is `blur(0px)` necessary at all?
                    WebkitBackdropFilter: 'blur(0px)',
                    backdropFilter: 'blur(0px)',
                }),
                opacity: 0,
            }),
        transition: `${getTransition('opacity', duration)}, ${getTransition('backdrop-filter', duration)}, ${getTransition('-webkit-backdrop-filter', duration)}, visibility 0s linear var(${cssVariableTransitionDuration}, ${isVisible ? '0s' : motionDurationMap[duration]})`,
    };
};

const hostHiddenStyles = {
    '&([hidden])': {
        display: 'none',
    },
};

const colorSchemeStyles = {
    colorScheme: 'light dark',
};

/**
 * utility to wrap jss styles parameter in `@media (hover: hover)`
 * which is used to not have hover styles on touch devices
 */
const hoverMediaQuery = (style) => ({ '@media(hover:hover)': style });

const prefersColorSchemeDarkMediaQuery = (theme, style) => {
    return isThemeAuto(theme) && { '@media (prefers-color-scheme: dark)': style };
};

const getSchemedHighContrastMediaQuery = (light, dark) => {
    return {
        '@media (forced-colors: active) and (prefers-color-scheme: light)': light,
        '@media (forced-colors: active) and (prefers-color-scheme: dark)': dark,
    };
};

// NOTE: handpicked selection of plugins from jss-preset-default
const jss = createJss({
    plugins: [
        jssGlobal(),
        jssNested(),
        camelCase(),
        jssPluginSortMediaQueries({ combineMediaQueries: true }),
    ],
});
const getCss = (jssStyles) => jss
    .createStyleSheet(jssStyles, {
    generateId: (rule) => rule.key,
})
    .toString();
const supportsConstructableStylesheets = () => {
    try {
        return typeof new CSSStyleSheet().replaceSync === 'function';
    }
    catch {
        return false;
    }
};
// determine it once
supportsConstructableStylesheets();
const buildResponsiveStyles = (rawValue, getJssStyle) => {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    const value = parseJSON(rawValue);
    return typeof value === 'object'
        ? Object.keys(value)
            // base styles are applied on root object, responsive styles are nested within
            // hence it is used as the initial object within reduce function
            .filter((key) => key !== 'base')
            .reduce((result, breakpointValue) => ({
            ...result,
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            [getMediaQueryMin(breakpointValue)]: getJssStyle(value[breakpointValue]),
        }), getJssStyle(value.base))
        : getJssStyle(value);
};
const isObject = (obj) => typeof obj === 'object' && !Array.isArray(obj);
// NOTE: taken from https://stackoverflow.com/a/48218209
const mergeDeep = (...objects) => {
    return objects.reduce((prev, obj) => {
        Object.keys(obj).forEach((key) => {
            const pVal = prev[key];
            const oVal = obj[key];
            if (isObject(pVal) && isObject(oVal)) {
                prev[key] = mergeDeep(pVal, oVal);
            }
            else {
                prev[key] = oVal;
            }
        });
        return prev;
    }, {});
};

const scrollShadowColor = 'rgba(204, 204, 204, 0.35)';
const scrollShadowColorDark = 'rgba(0, 0, 0, 0.6)';

const OPTION_HEIGHT = 40; // optgroups are higher and ignored
const MULTI_SELECT_OPTION_HEIGHT = 44;
const getNoResultsOptionJssStyle = () => ({
    '&[role=status]': {
        cursor: 'not-allowed',
    },
    // TODO: shouldn't be used here, instead use sr-only functional component and style
    '&__sr': getHiddenTextJssStyle(),
});

/**
 * Applies a style only on Chromium based browsers by using a media query which is only supported there.
 * https://browserstack.com/guide/create-browser-specific-css
 *
 * @param {JssStyle} style - The style to be applied when the Chromium media query is supported.
 * @returns {JssStyle} - The Chromium media query containing the style.
 */
const supportsChromiumMediaQuery = (style) => ({
    '@media screen and (-webkit-min-device-pixel-ratio: 0) and (min-resolution: 0.001dpcm)': style,
});

/**
 * Checks if the current environment supports the native Popover API.
 *
 * @returns {boolean} `true` if the native Popover API is supported, `false` otherwise.
 */
const supportsNativePopover = () => {
    if (!hasWindow) {
        return false;
    }
    return HTMLElement.prototype.hasOwnProperty('popover');
};
// determine it once
supportsNativePopover();

const hasDocument = typeof document !== 'undefined';

const isThemeAuto = (theme) => {
    return theme === 'auto';
};

const isThemeDark = (theme) => {
    return theme === 'dark';
};

const headerSlot = 'header';
const anchorSlot = 'anchor';

const formatObjectOutput = (value) => {
    return JSON.stringify(value)
        .replace(/"([a-zA-Z?]+)":/g, '$1:') // remove double quotes from keys
        .replace(/([,:{])/g, '$1 ') // add space after following: ,:{
        .replace(/(})/g, ' $1') // add space before following: }
        .replace(/^"(.+)"$/, '$1'); // remove wrapping double quotes
};
'value, ' +
    formatObjectOutput(breakpoints.reduce((prev, key) => ({ ...prev, [key + (key !== 'base' ? '?' : '')]: 'value' }), {})).replace(/"/g, '');

const HEADING_TAGS = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];

const getComponentCss$15 = (size, compact, open, theme) => {
    const { primaryColor, hoverColor, contrastLowColor } = getThemedColors(theme);
    const { primaryColor: primaryColorDark, hoverColor: hoverColorDark, contrastLowColor: contrastLowColorDark, } = getThemedColors('dark');
    return getCss({
        '@global': {
            ':host': {
                display: 'block',
                ...addImportantToEachRule({
                    ...(compact
                        ? { transform: 'translate3d(0,0,0)' } // relevant for custom click-area in compact variant
                        : {
                            borderBottom: `1px solid ${contrastLowColor}`,
                            ...prefersColorSchemeDarkMediaQuery(theme, {
                                borderColor: contrastLowColorDark,
                            }),
                        }),
                    '&(:only-of-type)': { borderBottom: 0 },
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            button: {
                display: 'flex',
                position: 'relative',
                justifyContent: 'space-between',
                alignItems: 'center',
                width: '100%',
                textDecoration: 'none',
                border: 0,
                margin: 0, // Removes default button margin on safari 15
                gap: '24px',
                background: 'transparent',
                cursor: 'pointer',
                textAlign: 'start',
                color: primaryColor,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    color: primaryColorDark,
                }),
                ...textSmallStyle,
                fontWeight: fontWeightSemiBold,
                ...buildResponsiveStyles(size, (s) => ({
                    fontSize: s === 'medium' ? fontSizeTextMedium : fontSizeTextSmall,
                    padding: `${compact ? '4px' : s === 'medium' ? '20px' : '15px'} 0`,
                })),
                // mergeDeep needed because of hoverMediaQuery in certain modes not wrapping keys and therefore overriding "&::before" key
                ...mergeDeep({
                    '&::before': {
                        content: '""',
                        position: 'absolute',
                        borderRadius: borderRadiusSmall,
                        left: '-4px',
                        right: '-4px',
                        ...(compact
                            ? {
                                top: '2px',
                                bottom: '2px',
                            }
                            : {
                                top: '6px',
                                bottom: '6px',
                            }),
                    },
                }, hoverMediaQuery({
                    '&::before': {
                        transition: getTransition('background-color'),
                    },
                    '&:hover::before': {
                        background: hoverColor,
                        ...prefersColorSchemeDarkMediaQuery(theme, {
                            background: hoverColorDark,
                        }),
                    },
                })),
                ...getFocusJssStyle(theme, { pseudo: true, offset: '-2px' }),
            },
        },
        heading: {
            margin: 0,
        },
        'icon-container': {
            height: fontLineHeight,
            width: fontLineHeight,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
        },
        icon: {
            width: fontLineHeight,
            height: fontLineHeight,
            fontSize: fontSizeTextXXSmall,
            transform: open ? 'rotate3d(0)' : 'rotate3d(0,0,1,90deg)',
            transition: getTransition('transform'),
        },
        collapsible: {
            color: primaryColor, // enables color inheritance for slotted content
            ...prefersColorSchemeDarkMediaQuery(theme, {
                color: primaryColorDark,
            }),
            display: 'grid',
            ...(open
                ? {
                    gridTemplateRows: '1fr',
                    visibility: 'inherit',
                    transition: getTransition('grid-template-rows'),
                    paddingBottom: compact ? spacingStaticSmall : '24px',
                }
                : {
                    gridTemplateRows: '0fr',
                    visibility: 'hidden',
                    transition: `${getTransition('grid-template-rows')}, visibility 0s linear var(${cssVariableTransitionDuration}, ${motionDurationShort})`,
                }),
            '& div': {
                overflow: open ? 'visible' : 'hidden',
                // Fix overflow issues for overlapping content (e.g. select dropdown)
                animation: open ? `$overflow var(${cssVariableTransitionDuration},${motionDurationShort})` : 'none',
                // Necessary to make focus outlines fully visible
                padding: '4px',
                margin: '-4px',
                // Fix scrollbar issues when slotted content includes .sr-only styles (see issue #3042)
                transform: 'translate3d(0,0,0)',
                zIndex: 1,
            },
        },
        '@keyframes overflow': {
            from: { overflow: 'hidden' },
            to: { overflow: 'hidden' },
        },
    });
};

const TOAST_Z_INDEX = 999999;
const MODAL_Z_INDEX = 99999;
const FLYOUT_Z_INDEX = 99998;
const POPOVER_Z_INDEX = 9999;
const BANNER_Z_INDEX = 99;

const cssVariableTop = '--p-banner-position-top';
const cssVariableBottom = '--p-banner-position-bottom';
const cssVariableZIndex = '--p-internal-banner-z-index';
const topBottomFallback = '56px';
const getComponentCss$14 = (isOpen) => {
    return getCss({
        '@global': {
            ':host': addImportantToEachRule({
                position: 'fixed',
                bottom: `var(${cssVariableBottom},${topBottomFallback})`,
                left: gridExtendedOffsetBase,
                right: gridExtendedOffsetBase,
                margin: 0,
                padding: 0,
                width: 'auto',
                maxWidth: '100%', // If component is wrapped in container with maxWidth
                zIndex: `var(${cssVariableZIndex},${BANNER_Z_INDEX})`,
                ...dropShadowHighStyle,
                borderRadius: borderRadiusSmall, // needed for rounded box-shadow
                ...(isOpen
                    ? {
                        opacity: 1,
                        visibility: 'inherit',
                        transform: 'translate3d(0,0,0)',
                        transition: `transform var(${cssVariableAnimationDuration}, ${motionDurationModerate}) ${motionEasingIn}, opacity var(${cssVariableAnimationDuration}, ${motionDurationModerate}) ${motionEasingIn}`,
                    }
                    : {
                        opacity: 0,
                        visibility: 'hidden',
                        transform: `translate3d(0,calc(var(${cssVariableBottom},${topBottomFallback}) + 100%),0)`,
                        '&(.hydrated),&(.ssr)': {
                            transition: `visibility 0s linear var(${cssVariableAnimationDuration}, ${motionDurationLong}), transform var(${cssVariableAnimationDuration}, ${motionDurationModerate}) ${motionEasingOut}, opacity var(${cssVariableAnimationDuration}, ${motionDurationModerate}) ${motionEasingOut}`,
                        },
                    }),
                [getMediaQueryMin('s')]: {
                    top: `var(${cssVariableTop},${topBottomFallback})`,
                    bottom: 'auto',
                    left: gridExtendedOffsetS,
                    right: gridExtendedOffsetS,
                    // space before and after "-" is crucial)
                    ...(!isOpen && { transform: `translate3d(0,calc(-100% - var(${cssVariableTop},${topBottomFallback})),0)` }),
                },
                [getMediaQueryMin('xxl')]: {
                    left: gridExtendedOffsetXXL,
                    right: gridExtendedOffsetXXL,
                },
                ...colorSchemeStyles,
                ...hostHiddenStyles,
            }),
        },
    });
};

const groupDirectionJssStyles = {
    column: {
        flexFlow: 'column nowrap',
        alignItems: 'stretch',
    },
    row: {
        flexFlow: 'row wrap',
        alignItems: 'center',
    },
};
const getGroupDirectionJssStyles = (direction) => {
    return groupDirectionJssStyles[direction];
};

const getComponentCss$13 = (direction) => {
    return getCss({
        '@global': {
            ':host': {
                display: 'block',
                ...addImportantToEachRule({
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            div: {
                display: 'flex',
                gap: spacingFluidSmall,
                ...buildResponsiveStyles(direction, getGroupDirectionJssStyles),
            },
        },
    });
};

const fontSizeTextMap = {
    'xx-small': fontSizeTextXXSmall,
    'x-small': fontSizeTextXSmall,
    small: fontSizeTextSmall,
    medium: fontSizeTextMedium,
    large: fontSizeTextLarge,
    'x-large': fontSizeTextXLarge,
    inherit: 'inherit',
};
const getFontSizeText = (size) => {
    return fontSizeTextMap[size];
};

// Needed for slotted anchor and hidden label, which then enlarges the hidden label to equal host size and indents the text to be visually hidden.
const getVisibilityJssStyle = (hideLabel) => {
    return hideLabel
        ? {
            whiteSpace: 'nowrap',
            textIndent: '-999999px', // Needed because standard sr-only classes don't work here due that we need a bounding box for the focus style
            overflow: 'hidden',
        }
        : {
            whiteSpace: 'inherit',
            textIndent: 0,
            zIndex: 1, // fix Firefox bug on :hover (#2583)
            overflow: 'visible',
        };
};
const offsetVertical = '-2px';
const offsetHorizontal = '-4px';
const getLinkButtonPureStyles = (icon, iconSource, active, isDisabledOrLoading, stretch, size, hideLabel, alignLabel, hasSlottedAnchor, theme) => {
    const { primaryColor, disabledColor, hoverColor } = getThemedColors(theme);
    const { primaryColor: primaryColorDark, disabledColor: disabledColorDark, hoverColor: hoverColorDark, } = getThemedColors('dark');
    const hasIcon = hasVisibleIcon(icon, iconSource);
    return {
        '@global': {
            ':host': {
                ...addImportantToEachRule({
                    transform: 'translate3d(0,0,0)', // creates new stacking context
                    outline: 0, // custom element is able to delegate the focus
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
                ...buildResponsiveStyles(stretch, (responsiveStretch) => ({
                    display: responsiveStretch ? 'block' : 'inline-block',
                    width: responsiveStretch ? '100%' : 'auto', // prevents adjusting its size when used as flex or grid child
                    ...(!responsiveStretch && { verticalAlign: 'top' }),
                })),
            },
        },
        root: {
            display: 'flex',
            width: '100%',
            padding: 0,
            margin: 0, // Removes default button margin on safari 15
            color: isDisabledOrLoading ? disabledColor : primaryColor,
            ...prefersColorSchemeDarkMediaQuery(theme, {
                color: isDisabledOrLoading ? disabledColorDark : primaryColorDark,
            }),
            ...textSmallStyle,
            ...mergeDeep(buildResponsiveStyles(hideLabel, (hidelabelValue) => ({
                gap: hidelabelValue ? 0 : spacingStaticXSmall,
            })), buildResponsiveStyles(stretch, (stretchValue) => ({
                justifyContent: stretchValue ? 'space-between' : 'flex-start',
                alignItems: stretchValue ? 'center' : 'flex-start',
            })), buildResponsiveStyles(size, (sizeValue) => ({
                fontSize: getFontSizeText(sizeValue),
            }))),
            '&::before': {
                content: '""',
                position: 'absolute', // mobile Safari -> prevent lagging active state
                top: offsetVertical,
                bottom: offsetVertical,
                ...buildResponsiveStyles(hideLabel, (hideLabelValue) => ({
                    right: hideLabelValue ? offsetVertical : offsetHorizontal,
                    left: hideLabelValue ? offsetVertical : offsetHorizontal,
                })),
                borderRadius: borderRadiusSmall,
                transition: getTransition('background-color'),
                ...(active && {
                    ...frostedGlassStyle,
                    backgroundColor: hoverColor,
                    ...prefersColorSchemeDarkMediaQuery(theme, {
                        backgroundColor: hoverColorDark,
                    }),
                }),
            },
            ...(!isDisabledOrLoading &&
                hoverMediaQuery({
                    '&:hover::before': {
                        ...frostedGlassStyle,
                        backgroundColor: hoverColor,
                        ...prefersColorSchemeDarkMediaQuery(theme, {
                            backgroundColor: hoverColorDark,
                        }),
                    },
                })),
            ...(!hasSlottedAnchor && getFocusJssStyle(theme, { pseudo: true, offset: '-2px' })),
        },
        ...(hasIcon
            ? {
                icon: {
                    position: 'relative',
                    flexShrink: '0',
                    width: fontLineHeight,
                    height: fontLineHeight,
                    // workaround for Safari to optimize vertical alignment of icons
                    // TODO: check if this is still needed after optimized icons are included
                    '@supports (width: round(down, 1px, 1px))': {
                        width: `round(down, ${fontLineHeight}, 1px)`,
                        height: `round(down, ${fontLineHeight}, 1px)`,
                    },
                },
                label: mergeDeep(buildResponsiveStyles(hideLabel, getVisibilityJssStyle), buildResponsiveStyles(alignLabel, (alignLabelValue) => ({
                    // TODO: we should remove 'left' here and map the value in the component class already to 'start' but might be difficult due to breakpoint customizable prop value
                    order: alignLabelValue === 'left' || alignLabelValue === 'start' ? -1 : 0,
                }))),
            }
            : {
                label: {
                    position: 'relative', // needed for hover state when icon="none" is set
                },
            }),
    };
};

const getFunctionalComponentLoadingMessageStyles = () => {
    return {
        loading: getHiddenTextJssStyle(),
    };
};

const getComponentCss$12 = (icon, iconSource, active, isLoading, isDisabledOrLoading, stretch, size, hideLabel, alignLabel, theme) => {
    const hasIcon = hasVisibleIcon(icon, iconSource);
    return getCss(mergeDeep(getLinkButtonPureStyles(icon, iconSource, active, isDisabledOrLoading, stretch, size, hideLabel, alignLabel, false, theme), {
        root: {
            WebkitAppearance: 'none', // iOS safari
            appearance: 'none',
            background: 'transparent',
            textAlign: 'start',
            border: 0,
            cursor: isDisabledOrLoading ? 'not-allowed' : 'pointer',
        },
        ...(!hasIcon &&
            isLoading && {
            label: {
                opacity: 0, // use opacity for smooth transition between states and to keep accessible name available
            },
            icon: {
                position: 'absolute',
                top: 0,
                left: `calc(50% - ${fontLineHeight} / 2)`,
                width: fontLineHeight,
                height: fontLineHeight,
            },
        }),
        // .loading
        ...getFunctionalComponentLoadingMessageStyles(),
    }));
};

const fontWeightMap = {
    regular: fontWeightRegular,
    'semi-bold': fontWeightSemiBold,
    bold: fontWeightBold,
};
const getFontWeight = (weight) => {
    return fontWeightMap[weight];
};

const getThemedTypographyColor = (theme, textColor // eslint-disable-line @typescript-eslint/no-duplicate-type-constituents
) => {
    const themedColors = getThemedColors(theme);
    const colorMap = {
        primary: themedColors.primaryColor,
        default: themedColors.primaryColor, // deprecated but part of HeadlineColor
        'contrast-low': themedColors.contrastLowColor,
        'contrast-medium': themedColors.contrastMediumColor,
        'contrast-high': themedColors.contrastHighColor,
        'notification-success': themedColors.successColor,
        'notification-warning': themedColors.warningColor,
        'notification-error': themedColors.errorColor,
        'notification-info': themedColors.infoColor,
        inherit: 'currentColor',
    };
    return colorMap[textColor];
};

const aspectRatioPaddingMap = {
    '1:1': '100%',
    '4:3': '75%',
    '3:4': '133.33%',
    '16:9': '56.25%',
    '9:16': '177.75%',
};
const getTileBaseStyles = (aspectRatio, isDisabled) => {
    return {
        '@global': {
            ':host': {
                display: 'block',
                hyphens: 'auto',
                ...addImportantToEachRule({
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            ...addImportantToEachRule({
                '::slotted': {
                    '&(picture)': {
                        position: 'absolute',
                        inset: 0,
                    },
                    '&(img)': {
                        height: '100%',
                        width: '100%',
                        objectFit: 'cover',
                    },
                },
            }),
        },
        root: {
            position: 'relative',
            overflow: 'hidden',
            transform: 'translate3d(0,0,0)', // change stacking context for position fixed
            borderRadius: borderRadiusLarge,
            color: getThemedTypographyColor('dark', 'primary'),
            ...buildResponsiveStyles(aspectRatio, (ratio) => ({
                paddingTop: aspectRatioPaddingMap[ratio],
            })),
            ...(!isDisabled &&
                hoverMediaQuery({
                    '&:hover .image-container': {
                        transform: 'scale3d(1.05,1.05,1.05)',
                    },
                })),
        },
        'image-container': {
            position: 'absolute',
            inset: 0,
            transition: getTransition('transform', 'moderate'),
        },
        content: {
            position: 'absolute',
            left: 0,
            right: 0,
            display: 'flex',
            justifyItems: 'start',
            gap: spacingStaticMedium,
            borderRadius: borderRadiusLarge, // for gradient
            '@media (forced-colors: active)': {
                background: 'rgba(0,0,0,0.7)',
            },
        },
    };
};

const sizeMap$5 = {
    inherit: { fontSize: 'inherit' },
    default: { fontSize: fontSizeTextMedium },
};
const getButtonLinkTileStyles = (aspectRatio, size, weight, // to get deprecated semibold typed
background, align, compact, hasGradient, isDisabled) => {
    const isTopAligned = align === 'top';
    return mergeDeep(getTileBaseStyles(aspectRatio, isDisabled), {
        '@global': {
            p: {
                maxWidth: '34.375rem', // in this case rem unit makes sense to scale up available space
                margin: 0,
                ...textLargeStyle,
                hyphens: 'inherit',
                ...mergeDeep(buildResponsiveStyles(size, (s) => sizeMap$5[s]), buildResponsiveStyles(weight, (w) => ({
                    fontWeight: getFontWeight(w === 'semibold' ? 'semi-bold' : w), // mapping of the deprecated weight semibold
                }))),
                ...buildResponsiveStyles(background, (b) => ({
                    color: getThemedColors(b).primaryColor,
                })),
            },
        },
        content: {
            display: 'grid', // TODO: flex via getTileBaseStyles
            ...(isTopAligned ? { top: 0 } : { bottom: 0 }),
            padding: isTopAligned
                ? `${spacingFluidMedium} ${spacingFluidMedium} ${spacingFluidLarge}`
                : `${spacingFluidLarge} ${spacingFluidMedium} ${spacingFluidMedium}`,
            ...mergeDeep(hasGradient &&
                isThemeDark(background) &&
                buildResponsiveStyles(compact, (isCompact) => isCompact && isTopAligned ? gradientToBottomStyle : gradientToTopStyle), buildResponsiveStyles(compact, (isCompact) => isCompact // TODO: use flex
                ? {
                    alignItems: 'center',
                    gridTemplateColumns: 'auto 24px',
                    gridTemplateRows: 'auto',
                    ...(isTopAligned ? { top: 0 } : { bottom: 0 }),
                }
                : {
                    gridTemplateRows: 'auto auto',
                    gridTemplateColumns: 'auto',
                })),
        },
        'link-or-button-pure': buildResponsiveStyles(compact, (isCompact) => ({
            display: isCompact ? 'inline-block' : 'none',
        })),
        'link-or-button': {
            minHeight: '54px', // prevent content shift
            ...buildResponsiveStyles(compact, (isCompact) => ({
                display: isCompact ? 'none' : 'inline-block',
            })),
        },
    });
};

const getComponentCss$11 = (isDisabledOrLoading, ...args) => {
    const buttonLinkTileStyles = getButtonLinkTileStyles(...args);
    return getCss({
        ...buttonLinkTileStyles,
        root: {
            ...buttonLinkTileStyles.root,
            cursor: isDisabledOrLoading ? 'not-allowed' : 'pointer',
        },
    });
};

const { primaryColor: darkThemePrimaryColor$1 } = getThemedColors('dark');
const { primaryColor: lightThemePrimaryColor } = getThemedColors('light');
const getVariantColors = (variant, theme) => {
    const { primaryColor, contrastHighColor, contrastMediumColor, hoverColor } = getThemedColors(theme);
    const { canvasColor } = getHighContrastColors();
    const colors = {
        primary: {
            textColor: theme === 'dark' ? lightThemePrimaryColor : darkThemePrimaryColor$1,
            borderColor: primaryColor,
            borderColorHover: contrastHighColor,
            backgroundColor: primaryColor,
            backgroundColorHover: contrastHighColor,
        },
        secondary: {
            textColor: primaryColor,
            borderColor: primaryColor,
            borderColorHover: contrastMediumColor,
            backgroundColor: isHighContrastMode ? canvasColor : 'transparent',
            backgroundColorHover: hoverColor,
        },
    };
    return colors[variant === 'tertiary' ? 'secondary' : variant];
};
const getLinkButtonStyles = (icon, iconSource, variant, hideLabel, isDisabledOrLoading, hasSlottedAnchor, theme) => {
    const isPrimary = variant === 'primary';
    const { textColor, borderColor, borderColorHover, backgroundColor, backgroundColorHover } = getVariantColors(variant, theme);
    const { textColor: textColorDark, borderColor: borderColorDark, borderColorHover: borderColorHoverDark, backgroundColor: backgroundColorDark, backgroundColorHover: backgroundColorHoverDark, } = getVariantColors(variant, 'dark');
    const { focusColor } = getThemedColors(theme);
    const hasIcon = hasVisibleIcon(icon, iconSource) || hideLabel;
    return {
        '@global': {
            ':host': {
                display: 'inline-block',
                ...addImportantToEachRule({
                    verticalAlign: 'top',
                    outline: 0, // custom element is able to delegate the focus
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
        },
        root: {
            display: 'flex',
            alignItems: 'flex-start',
            justifyContent: 'center',
            width: '100%',
            minWidth: '54px', // ensure space is already reserved until icon component is loaded (ssr)
            minHeight: '54px', // ensure space is already reserved until icon component is loaded (ssr)
            boxSizing: 'border-box',
            textAlign: 'start',
            WebkitAppearance: 'none', // iOS safari
            appearance: 'none',
            textDecoration: 'none',
            border: `2px solid ${borderColor}`,
            borderRadius: borderRadiusSmall,
            transform: 'translate3d(0,0,0)', // creates new stacking context (for slotted anchor + focus)
            backgroundColor,
            color: textColor,
            ...textSmallStyle,
            transition: `${getTransition('background-color')}, ${getTransition('border-color')}, ${getTransition('color')}`,
            ...buildResponsiveStyles(hideLabel, (hideLabelValue) => ({
                padding: hideLabelValue ? '13px' : '13px 26px',
                gap: hideLabelValue ? 0 : spacingStaticSmall,
            })),
            ...(!hasSlottedAnchor && getFocusJssStyle(theme)),
            ...(!isDisabledOrLoading &&
                hoverMediaQuery({
                    '&:hover': {
                        backgroundColor: backgroundColorHover,
                        borderColor: isHighContrastMode ? focusColor : borderColorHover,
                        ...(!isPrimary && frostedGlassStyle),
                        ...prefersColorSchemeDarkMediaQuery(theme, {
                            backgroundColor: backgroundColorHoverDark,
                            borderColor: borderColorHoverDark,
                        }),
                    },
                })),
            ...prefersColorSchemeDarkMediaQuery(theme, {
                borderColor: borderColorDark,
                backgroundColor: backgroundColorDark,
                color: textColorDark,
            }),
        },
        label: buildResponsiveStyles(hideLabel, getHiddenTextJssStyle),
        ...(hasIcon && {
            icon: {
                width: fontLineHeight,
                height: fontLineHeight,
                ...buildResponsiveStyles(hideLabel, (hideLabelValue) => ({
                    marginInlineStart: hideLabelValue ? 0 : '-8px', // compensate white space of svg icon and optimize visual alignment
                })),
            },
        }),
    };
};

const getDisabledColors = (variant, loading, theme) => {
    const { contrastMediumColor, contrastHighColor, disabledColor, hoverColor } = getThemedColors(theme);
    const { canvasColor } = getHighContrastColors();
    const colors = {
        primary: {
            textColor: isHighContrastMode ? disabledColor : contrastHighColor,
            borderColor: isHighContrastMode ? disabledColor : loading ? contrastHighColor : disabledColor,
            backgroundColor: isHighContrastMode ? canvasColor : loading ? contrastHighColor : disabledColor,
        },
        secondary: {
            textColor: disabledColor,
            borderColor: isHighContrastMode ? disabledColor : loading ? contrastMediumColor : disabledColor,
            backgroundColor: isHighContrastMode ? canvasColor : loading ? hoverColor : 'transparent',
        },
    };
    return colors[variant === 'tertiary' ? 'secondary' : variant];
};
const getComponentCss$10 = (icon, iconSource, variant, hideLabel, disabled, loading, theme) => {
    const disabledOrLoading = isDisabledOrLoading(disabled, loading);
    const { textColor, borderColor, backgroundColor } = getDisabledColors(variant, loading, theme);
    const { textColor: textColorDark, borderColor: borderColorDark, backgroundColor: backgroundColorDark, } = getDisabledColors(variant, loading, 'dark');
    const isPrimary = variant === 'primary';
    return getCss(mergeDeep(getLinkButtonStyles(icon, iconSource, variant, hideLabel, disabledOrLoading, false, theme), {
        root: {
            cursor: disabledOrLoading ? 'not-allowed' : 'pointer',
            ...(disabledOrLoading && {
                backgroundColor,
                borderColor,
                color: textColor,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    backgroundColor: backgroundColorDark,
                    borderColor: borderColorDark,
                    color: textColorDark,
                }),
            }),
            ...(loading && !isPrimary && frostedGlassStyle),
            margin: 0, // Removes default button margin on safari 15
        },
        ...(loading && {
            spinner: {
                width: fontLineHeight,
                height: fontLineHeight,
                pointerEvents: 'none',
                position: 'absolute',
                top: '50%',
                left: '50%',
                transform: 'translate(-50%, -50%)',
                ...(isPrimary && !isHighContrastMode && { filter: 'invert(1)' }),
            },
        }),
        label: {
            transition: getTransition('opacity'),
            ...(loading && {
                opacity: 0, // use opacity for smooth transition between states
            }),
        },
        icon: {
            transition: getTransition('opacity'),
            ...(!disabled &&
                isPrimary &&
                !isHighContrastMode && {
                filter: 'invert(1)',
            }),
            ...(loading && {
                opacity: 0, // use opacity for smooth transition between states
            }),
        },
        // .loading
        ...getFunctionalComponentLoadingMessageStyles(),
    }));
};

const cssVariablePrevNextFilter = '--p-carousel-prev-next-filter';
const carouselTransitionDuration = motionDurationModerate;
const paginationInfiniteStartCaseClass = 'pagination--infinite';
const bulletClass = 'bullet';
const bulletActiveClass = 'bullet--active';
const bulletInfiniteClass = 'bullet--infinite';
const paginationVisibleBulletCount = 5;
const paginationBulletSize = '8px';
const paginationInfiniteBulletSize = '4px';
const paginationActiveBulletSize = '20px';
const paginationGap = '8px';
const paginationWidth = `calc(${paginationActiveBulletSize} + ${paginationBulletSize} * ${paginationVisibleBulletCount - 1} + ${paginationGap} * ${paginationVisibleBulletCount - 1})`; // Width for one active bullet + width of inactive bullets + spacing
const paginationInset = '8px'; // Used to increase clickable area on touch devices
const paginationGapLarge = '16px';
const paginationWidthLarge = `calc(${paginationActiveBulletSize} + ${paginationBulletSize} * ${paginationVisibleBulletCount - 1} + ${paginationGapLarge} * ${paginationVisibleBulletCount - 1} + 2 * ${paginationInset})`; // Width for one active bullet + width of inactive bullets + spacing
const selectorHeading = 'h2,::slotted([slot="heading"])';
const selectorDescription = 'p,::slotted([slot="description"])';
const mediaQueryS = getMediaQueryMin('s');
const mediaQueryXXL = getMediaQueryMin('xxl');
const mediaQueryPointerCoarse = '@media (pointer: coarse)';
const spacingMap = {
    basic: gridBasicOffset,
    extended: gridExtendedOffset,
};
const backfaceVisibilityJssStyle = {
    backfaceVisibility: 'hidden',
    WebkitBackfaceVisibility: 'hidden',
};
const getComponentCss$$ = (hasHeading, hasDescription, hasControlsSlot, headingSize, width, hasPagination, isInfinitePagination, alignHeader, theme) => {
    const { primaryColor, contrastMediumColor } = getThemedColors(theme);
    const { primaryColor: primaryColorDark, contrastMediumColor: contrastMediumColorDark } = getThemedColors('dark');
    const { canvasTextColor } = getHighContrastColors();
    const isHeaderAlignCenter = alignHeader === 'center';
    return getCss({
        '@global': {
            ':host': {
                display: 'flex',
                ...addImportantToEachRule({
                    gap: spacingFluidMedium, // TODO: maybe it's better to style by margin on .splide, then styles would be part of shadow dom
                    flexDirection: 'column',
                    boxSizing: 'content-box', // ensures padding is added to host instead of subtracted
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            ...(hasControlsSlot && {
                ['slot[name="controls"]']: {
                    display: 'block',
                    gridColumnStart: 1,
                    gridRowStart: 3,
                    alignSelf: 'center', // ensures vertical alignment to prev/next buttons
                },
            }),
            ...addImportantToEachRule({
                '::slotted': {
                    '&(*)': {
                        borderRadius: `var(--p-carousel-border-radius, ${borderRadiusLarge})`,
                    },
                    ...getFocusJssStyle(theme, { slotted: true }),
                },
                // TODO: maybe it's better to style with slot[name="heading"] and slot[name="description"] instead, then styles would be part of shadow dom
                // h2,::slotted([slot=heading]),p,::slotted([slot=description])
                ...((hasHeading || hasDescription) && {
                    [`${selectorHeading},${selectorDescription}`]: {
                        gridColumn: '1/-1',
                        color: primaryColor,
                        ...(isHeaderAlignCenter && {
                            textAlign: 'center', // relevant in case heading or description becomes multiline
                            justifySelf: 'center', // relevant for horizontal alignment of heading and description in case max-width applies
                        }),
                        ...prefersColorSchemeDarkMediaQuery(theme, {
                            color: primaryColorDark,
                        }),
                    },
                }),
                // h2,::slotted([slot=heading])
                ...(hasHeading && {
                    [selectorHeading]: {
                        maxWidth: '56.25rem',
                        margin: `0 0 ${!hasDescription ? spacingFluidMedium : 0}`,
                        ...(headingSize === 'xx-large' ? headingXXLargeStyle : headingXLargeStyle),
                    },
                }),
                // p,::slotted([slot=description])
                ...(hasDescription && {
                    [selectorDescription]: {
                        maxWidth: '34.375rem',
                        margin: `${spacingFluidSmall} 0 ${spacingFluidMedium}`,
                        ...textSmallStyle,
                    },
                }),
            }),
        },
        header: {
            display: 'grid',
            padding: `0 ${spacingMap[width].base}`,
            [mediaQueryS]: {
                gridTemplateColumns: 'minmax(0px, 1fr) auto',
                columnGap: spacingStaticMedium,
                padding: `0 ${spacingMap[width].s}`,
            },
            [mediaQueryXXL]: {
                padding: `0 ${spacingMap[width].xxl}`,
            },
        },
        nav: {
            display: 'none',
            [mediaQueryS]: {
                gridRowStart: '3',
                gridColumnEnd: '-1',
                display: 'flex',
                gap: spacingStaticXSmall,
                alignSelf: 'flex-start', // relevant in case slot="header" becomes higher than nav group
            },
            filter: `var(${cssVariablePrevNextFilter}, none)`,
        },
        btn: {
            padding: spacingStaticSmall,
        },
        'skip-link': {
            // :focus must be used in this case, because :focus-visible is just matched on the focusable element itself, not on the host element.
            '&:not(:focus)': {
                opacity: 0,
                pointerEvents: 'none',
            },
        },
        splide: {
            overflow: 'hidden',
            padding: '4px 0', // for slide focus outline
            margin: '-4px 0', // for slide focus outline
            '&__track': {
                // !important is necessary to override inline styles set by splide library
                ...addImportantToEachRule({
                    padding: `0 ${spacingMap[width].base}`,
                    [getMediaQueryMax('xs')]: {
                        paddingRight: `calc(${gridBasicOffsetBase} + ${gridGap})`, // we need to give cut off slides a bit more space on mobile views
                    },
                    [mediaQueryS]: {
                        padding: `0 ${spacingMap[width].s}`,
                    },
                    [mediaQueryXXL]: {
                        padding: `0 ${spacingMap[width].xxl}`,
                    },
                }),
                '&--draggable': {
                    cursor: 'grab',
                    userSelect: 'none',
                    WebkitUserSelect: 'none',
                    WebkitTouchCallout: 'none',
                },
            },
            '&__list': {
                ...backfaceVisibilityJssStyle,
                display: 'flex',
            },
            '&__slide': {
                ...backfaceVisibilityJssStyle,
                flexShrink: 0,
                transform: 'translateZ(0)', // fixes mobile safari flickering, https://github.com/nolimits4web/swiper/issues/3527#issuecomment-609088939
            },
            '&__sr': getHiddenTextJssStyle(), // appears in the DOM when sliding
        },
        ...(hasPagination && {
            'pagination-container': {
                ...buildResponsiveStyles(hasPagination, (hasPaginationValue) => ({
                    display: hasPaginationValue ? 'flex' : 'none',
                })),
                position: 'relative',
                justifyContent: isInfinitePagination ? 'flex-start' : 'center',
                width: paginationWidth,
                left: `calc(50% - (${paginationWidth}) / 2)`,
                [mediaQueryPointerCoarse]: {
                    width: paginationWidthLarge,
                    left: `calc(50% - ${paginationWidthLarge} / 2)`,
                },
                overflowX: 'hidden',
            },
            pagination: {
                display: 'flex',
                alignItems: 'center',
                width: 'fit-content',
                height: paginationBulletSize, // Needed to avoid jumping when rewinding dynamically added slides
                gap: paginationGap,
                [mediaQueryPointerCoarse]: {
                    height: `calc(${paginationBulletSize} + 2 * ${paginationInset})`,
                    gap: paginationGapLarge,
                },
                transition: `transform ${carouselTransitionDuration}`,
            },
            [bulletClass]: {
                // Increase clickable area on touch devices
                [mediaQueryPointerCoarse]: {
                    '&::before': {
                        content: '""',
                        position: 'absolute',
                        inset: `-${paginationInset}`,
                    },
                    position: 'relative',
                },
                borderRadius: borderRadiusSmall,
                ...(isHighContrastMode
                    ? {
                        background: canvasTextColor,
                    }
                    : {
                        background: contrastMediumColor,
                        ...prefersColorSchemeDarkMediaQuery(theme, {
                            background: contrastMediumColorDark,
                        }),
                    }),
                ...(isInfinitePagination
                    ? {
                        width: '0px',
                        height: '0px',
                        transition: `background-color ${carouselTransitionDuration}, width ${carouselTransitionDuration}, height ${carouselTransitionDuration}`,
                    }
                    : {
                        width: paginationBulletSize,
                        height: paginationBulletSize,
                        transition: `background-color ${carouselTransitionDuration}, width ${carouselTransitionDuration}`,
                    }),
                ...hoverMediaQuery({
                    cursor: 'pointer',
                }),
            },
            ...(isInfinitePagination && {
                [paginationInfiniteStartCaseClass]: {
                    [`& > .${bulletClass}:nth-child(-n+4)`]: {
                        width: paginationBulletSize,
                        height: paginationBulletSize,
                    },
                },
                [bulletInfiniteClass]: {
                    // Necessary to override the bulletActiveClass sibling selector
                    ...addImportantToEachRule({
                        width: paginationInfiniteBulletSize,
                        height: paginationInfiniteBulletSize,
                    }),
                    [`& ~ .${bulletClass}`]: {
                        width: paginationBulletSize,
                        height: paginationBulletSize,
                    },
                    [`& ~ .${bulletInfiniteClass} ~ .${bulletClass}`]: {
                        width: '0px',
                        height: '0px',
                    },
                },
            }),
            [bulletActiveClass]: {
                ...(isHighContrastMode
                    ? {
                        background: canvasTextColor,
                    }
                    : {
                        background: primaryColor,
                        ...prefersColorSchemeDarkMediaQuery(theme, {
                            background: primaryColorDark,
                        }),
                    }),
                height: paginationBulletSize,
                width: addImportantToRule(paginationActiveBulletSize),
                ...(isInfinitePagination && {
                    [`& ~ .${bulletClass}`]: {
                        width: paginationBulletSize,
                        height: paginationBulletSize,
                    },
                    [`& ~ .${bulletInfiniteClass} ~ .${bulletClass}`]: {
                        width: '0px',
                        height: '0px',
                    },
                }),
            },
        }),
    });
};

const getThemedFormStateColors = (theme, state) => {
    const themedColors = getThemedColors(theme);
    return {
        formStateColor: themedColors[`${state}Color`],
        formStateHoverColor: themedColors[`${state}ColorDarken`],
    };
};

// TODO: move to form-styles.ts
const getSlottedCheckboxRadioButtonStyles = (state, isDisabled, isLoading, theme) => {
    const { primaryColor, contrastMediumColor, contrastHighColor, disabledColor } = getThemedColors(theme);
    const { primaryColor: primaryColorDark, contrastMediumColor: contrastMediumColorDark, contrastHighColor: contrastHighColorDark, disabledColor: disabledColorDark, } = getThemedColors('dark');
    const { formStateColor, formStateHoverColor } = getThemedFormStateColors(theme, state);
    const { formStateColor: formStateColorDark, formStateHoverColor: formStateHoverColorDark } = getThemedFormStateColors('dark', state);
    const { canvasTextColor } = getHighContrastColors();
    const disabledOrLoading = isDisabledOrLoading(isDisabled, isLoading);
    // TODO: needs to be extracted into a color function
    const uncheckedColor = disabledOrLoading ? disabledColor : formStateColor || contrastMediumColor;
    const uncheckedColorDark = disabledOrLoading ? disabledColorDark : formStateColorDark || contrastMediumColorDark;
    const uncheckedHoverColor = formStateHoverColor || primaryColor;
    const uncheckedHoverColorDark = formStateHoverColorDark || primaryColorDark;
    const checkedColor = isHighContrastMode
        ? canvasTextColor
        : disabledOrLoading
            ? disabledColor
            : formStateColor || primaryColor;
    const checkedColorDark = isHighContrastMode
        ? canvasTextColor
        : disabledOrLoading
            ? disabledColorDark
            : formStateColorDark || primaryColorDark;
    const checkedHoverColor = formStateHoverColor || contrastHighColor;
    const checkedHoverColorDark = formStateHoverColorDark || contrastHighColorDark;
    return {
        '::slotted': {
            '&(input)': {
                width: fontLineHeight,
                height: fontLineHeight,
                font: `${fontSizeTextSmall} ${fontFamily}`, // needed for correct width and height definition based on ex-unit
                display: 'block',
                margin: 0,
                padding: 0,
                WebkitAppearance: 'none', // iOS safari
                appearance: 'none',
                boxSizing: 'content-box',
                background: `transparent 0% 0% / ${fontLineHeight}`,
                transition: `${getTransition('background-color')}, ${getTransition('border-color')}`,
                border: `${borderWidthBase} solid ${uncheckedColor}`,
                outline: 0, // TODO: only relevant for VRT testing with forced states - prevents :focus style (in case getFocusJssStyle() condition is not matching)
                ...(disabledOrLoading
                    ? {
                        pointerEvents: 'none', // to prevent form element becomes clickable/toggleable
                    }
                    : {
                        cursor: 'pointer',
                    }),
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    borderColor: uncheckedColorDark,
                }),
            },
            '&(input:checked)': {
                // background-image is merged in later
                borderColor: checkedColor,
                backgroundColor: checkedColor,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    borderColor: checkedColorDark,
                    backgroundColor: checkedColorDark,
                }),
            },
            ...(!disabledOrLoading &&
                !isHighContrastMode &&
                hoverMediaQuery({
                    '&(input:hover),label:hover~.wrapper &(input)': {
                        borderColor: uncheckedHoverColor,
                        ...prefersColorSchemeDarkMediaQuery(theme, {
                            borderColor: uncheckedHoverColorDark,
                        }),
                    },
                    '&(input:checked:hover),label:hover~.wrapper &(input:checked)': {
                        borderColor: checkedHoverColor,
                        backgroundColor: checkedHoverColor,
                        ...prefersColorSchemeDarkMediaQuery(theme, {
                            borderColor: checkedHoverColorDark,
                            backgroundColor: checkedHoverColorDark,
                        }),
                    },
                    'label:hover~.wrapper &(input)': supportsChromiumMediaQuery({
                        transition: 'unset', // Fixes chrome bug where transition properties are stuck on hover
                    }),
                })),
            ...(!isDisabled && getFocusJssStyle(theme, { slotted: 'input' })),
        },
    };
};

const getInlineSVGBackgroundImage = (path) => {
    return `url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">${path}</svg>')`;
};

const escapeHashCharacter = (colorString) => {
    return colorString.replace('#', '%23');
};

const getFunctionalComponentRequiredStyles = () => {
    return {
        required: {
            userSelect: 'none',
        },
    };
};

const getFunctionalComponentLabelStyles = (isDisabledOrLoading, hideLabel, theme, additionalDefaultJssStyle, additionalIsShownJssStyle) => {
    const { primaryColor, disabledColor, contrastHighColor } = getThemedColors(theme);
    const { primaryColor: primaryColorDark, disabledColor: disabledColorDark, contrastHighColor: contrastHighColorDark, } = getThemedColors('dark');
    return {
        label: {
            ...textSmallStyle,
            cursor: isDisabledOrLoading ? 'not-allowed' : 'pointer',
            justifySelf: 'flex-start', // ensures label is not getting stretched by flex or grid context of its parent
            color: isDisabledOrLoading ? disabledColor : primaryColor,
            transition: getTransition('color'), // for smooth transitions between e.g. disabled state
            ...buildResponsiveStyles(hideLabel, (isHidden) => getHiddenTextJssStyle(isHidden, additionalIsShownJssStyle)),
            ...prefersColorSchemeDarkMediaQuery(theme, {
                color: isDisabledOrLoading ? disabledColorDark : primaryColorDark,
            }),
            '&:empty': {
                display: 'none', // prevents outer spacing caused by parents grid gap, in case no label value is defined (although it has to be set to be a11y compliant)
            },
            '&+&': {
                cursor: 'unset',
                marginTop: `-${spacingStaticXSmall}`,
                fontSize: fontSizeTextXSmall,
                ...(!isDisabledOrLoading && {
                    color: contrastHighColor,
                    ...prefersColorSchemeDarkMediaQuery(theme, {
                        color: contrastHighColorDark,
                    }),
                }),
            },
            ...additionalDefaultJssStyle,
        },
        // .required
        ...getFunctionalComponentRequiredStyles(),
    };
};

const getFunctionalComponentStateMessageStyles = (theme, state, additionalDefaultJssStyle) => {
    return {
        message: {
            display: 'flex',
            gap: spacingStaticXSmall,
            ...textSmallStyle,
            color: getThemedFormStateColors(theme, state).formStateColor,
            ...prefersColorSchemeDarkMediaQuery(theme, {
                color: getThemedFormStateColors('dark', state).formStateColor,
            }),
            transition: getTransition('color'),
            ...additionalDefaultJssStyle,
        },
    };
};

const getCheckedSVGBackgroundImage$1 = (fill) => {
    return getInlineSVGBackgroundImage(`<path fill="${fill}" d="m20.22,7.47l-1.47-1.42-9.26,9.02-4.24-4.15-1.47,1.42,5.71,5.6,10.73-10.47Z"/>`);
};
const getIndeterminateSVGBackgroundImage = (fill) => {
    return getInlineSVGBackgroundImage(`<path fill="${fill}" d="m20,11v2H4v-2h16Z"/>`);
};
const getComponentCss$_ = (hideLabel, state, isDisabled, isLoading, theme) => {
    const { canvasColor } = getHighContrastColors();
    const checkedIconColor = isHighContrastMode
        ? canvasColor
        : escapeHashCharacter(getInvertedThemedColors(theme).primaryColor);
    const checkedIconColorDark = isHighContrastMode
        ? canvasColor
        : escapeHashCharacter(getInvertedThemedColors('dark').primaryColor);
    const indeterminateIconColor = isHighContrastMode
        ? canvasColor
        : escapeHashCharacter(getThemedColors(theme).primaryColor);
    const indeterminateIconColorDark = isHighContrastMode
        ? canvasColor
        : escapeHashCharacter(getThemedColors('dark').primaryColor);
    return getCss({
        '@global': {
            ':host': {
                display: 'block',
                ...addImportantToEachRule({
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            // ::slotted(input)
            ...addImportantToEachRule(mergeDeep(getSlottedCheckboxRadioButtonStyles(state, isDisabled, isLoading, theme), {
                '::slotted': {
                    '&(input)': {
                        gridArea: '1/1',
                        borderRadius: borderRadiusSmall,
                    },
                    // TODO: is it somehow useful possible to make following styles configurable by parameter?
                    ...(!isLoading && {
                        '&(input:checked)': {
                            backgroundImage: getCheckedSVGBackgroundImage$1(checkedIconColor),
                            ...prefersColorSchemeDarkMediaQuery(theme, {
                                backgroundImage: getCheckedSVGBackgroundImage$1(checkedIconColorDark),
                            }),
                        },
                        '&(input:indeterminate)': {
                            backgroundImage: getIndeterminateSVGBackgroundImage(indeterminateIconColor),
                            ...prefersColorSchemeDarkMediaQuery(theme, {
                                backgroundImage: getIndeterminateSVGBackgroundImage(indeterminateIconColorDark),
                            }),
                        },
                    }),
                },
            })),
        },
        root: {
            display: 'grid',
            gridTemplateColumns: 'auto minmax(0, 1fr)',
            rowGap: spacingStaticXSmall,
        },
        wrapper: {
            display: 'grid',
            gridArea: '1/1',
            alignSelf: 'flex-start', // in case label becomes multiline
            ...(isDisabledOrLoading(isDisabled, isLoading) && {
                // TODO: maybe .wrapper should handle it for all form components while pointer-events: none is set to input
                cursor: 'not-allowed',
            }),
        },
        ...(isLoading && {
            // TODO: extract for checkbox-wrapper and radio-button-wrapper (not gridArea and placeSelf)
            spinner: {
                position: 'relative', // ensure correct stacking, can be removed as soon as focus for input is handled with outline
                gridArea: '1/1',
                placeSelf: 'center',
                width: fontLineHeight,
                height: fontLineHeight,
                font: `${fontSizeTextSmall} ${fontFamily}`, // needed for correct width and height definition based on ex-unit
                pointerEvents: 'none',
            },
        }),
        // .label / .required
        ...getFunctionalComponentLabelStyles(isDisabled || isLoading, hideLabel, theme, {
            gridArea: '1/2',
        }, {
            paddingTop: '2px', // compensate vertical alignment
            paddingInlineStart: spacingStaticSmall, // asymmetric padding used instead of gap to prevent not clickable area between label and input
        }),
        // .message
        ...getFunctionalComponentStateMessageStyles(theme, state, {
            gridColumn: '1/3',
        }),
        // .loading
        ...getFunctionalComponentLoadingMessageStyles(),
    });
};

const widthMap = {
    narrow: gridNarrowOffset,
    basic: gridBasicOffset,
    extended: gridExtendedOffset,
};
const getComponentCss$Z = (width) => {
    return getCss({
        '@global': {
            ':host': {
                display: 'block',
                ...addImportantToEachRule({
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
        },
        root: {
            minWidth: 0, // needed for some flex context
            ...(['full', 'fluid'].includes(width)
                ? {
                    padding: `0 ${gridFullOffset}`,
                }
                : {
                    padding: `0 ${widthMap[width].base}`,
                    [getMediaQueryMin('s')]: {
                        padding: `0 ${widthMap[width].s}`,
                    },
                    [getMediaQueryMin('xxl')]: {
                        padding: `0 ${widthMap[width].xxl}`,
                    },
                }),
        },
    });
};

const crestSize = {
    width: 30,
    height: 40,
};

const { width, height } = crestSize;
const getDimensionStyle = {
    maxWidth: `${width}px`,
    maxHeight: `${height}px`,
    width: 'inherit',
    height: 'inherit',
};
const getComponentCss$Y = () => {
    return getCss({
        '@global': {
            ':host': {
                position: 'relative',
                display: 'inline-block',
                verticalAlign: 'top',
                ...addImportantToEachRule({
                    outline: 0, // TODO: is it still necessary?
                    boxSizing: 'content-box', // needed for correct height calculation when padding is set on host (e.g. custom click area)
                    ...getDimensionStyle,
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            a: {
                display: 'block',
                textDecoration: 'none',
                ...getDimensionStyle,
                '&::before': {
                    // needs to be defined always to have correct custom click area
                    content: '""',
                    position: 'absolute',
                    inset: 0,
                    borderRadius: '1px',
                },
                ...getFocusJssStyle('light', { pseudo: true }), // TODO: we need to support theme
            },
            picture: {
                display: 'block',
                width: `min(${width}px, 100%)`,
                height: `min(${height}px, 100%)`,
            },
            img: {
                display: 'block',
                maxWidth: '100%',
                maxHeight: '100%',
                width: 'auto',
                height: 'auto',
            },
        },
    });
};

const DISPLAY_TAGS = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];

const getTypographyRootJssStyle = (baseTextStyle, responsiveStyle, align, // eslint-disable-line @typescript-eslint/no-duplicate-type-constituents
color, // eslint-disable-line @typescript-eslint/no-duplicate-type-constituents
ellipsis, theme) => {
    return {
        margin: 0,
        padding: 0,
        ...baseTextStyle,
        color: getThemedTypographyColor(theme, color),
        ...prefersColorSchemeDarkMediaQuery(theme, {
            color: getThemedTypographyColor('dark', color),
        }),
        textAlign: align,
        letterSpacing: 'normal',
        listStyleType: 'none',
        whiteSpace: 'inherit',
        ...(ellipsis && {
            maxWidth: '100%',
            overflow: 'hidden',
            textOverflow: 'ellipsis',
            whiteSpace: 'nowrap',
        }),
        ...responsiveStyle,
    };
};
const getTypographySlottedJssStyle = () => {
    return {
        margin: 'inherit',
        padding: 'inherit',
        fontFamily: 'inherit',
        fontWeight: 'inherit',
        fontSize: 'inherit',
        lineHeight: 'inherit',
        fontStyle: 'inherit',
        fontVariant: 'inherit',
        color: 'inherit',
        textAlign: 'inherit',
        overflowWrap: 'inherit',
        wordWrap: 'inherit',
        hyphens: 'inherit',
        whiteSpace: 'inherit',
        letterSpacing: 'inherit',
    };
};

const sizeMap$4 = {
    small: fontSizeDisplaySmall,
    medium: fontSizeDisplayMedium,
    large: fontSizeDisplayLarge,
};
const getComponentCss$X = (size, align, color, ellipsis, theme) => {
    return getCss({
        '@global': {
            ':host': {
                display: 'block',
                ...addImportantToEachRule({
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            '::slotted': {
                [DISPLAY_TAGS.map((i) => `&(${i})`).join()]: addImportantToEachRule(getTypographySlottedJssStyle()),
            },
        },
        root: getTypographyRootJssStyle(displayLargeStyle, buildResponsiveStyles(size, (sizeValue) => ({
            fontSize: sizeValue === 'inherit' ? sizeValue : sizeMap$4[sizeValue],
        })), align, color, ellipsis, theme),
    });
};

const getComponentCss$W = (color, orientation, theme) => {
    const { contrastLowColor, contrastMediumColor, contrastHighColor } = getThemedColors(theme);
    const { contrastLowColor: contrastLowColorDark, contrastMediumColor: contrastMediumColorDark, contrastHighColor: contrastHighColorDark, } = getThemedColors('dark');
    const colorMap = {
        'contrast-low': contrastLowColor,
        'contrast-medium': contrastMediumColor,
        'contrast-high': contrastHighColor,
    };
    const colorMapDark = {
        'contrast-low': contrastLowColorDark,
        'contrast-medium': contrastMediumColorDark,
        'contrast-high': contrastHighColorDark,
    };
    return getCss({
        '@global': {
            ':host': {
                display: 'block',
                ...addImportantToEachRule({
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            hr: {
                margin: 0,
                padding: 0,
                border: 'none',
                textAlign: 'start',
                ...(isHighContrastMode
                    ? {
                        background: getHighContrastColors().canvasTextColor,
                    }
                    : {
                        background: colorMap[color],
                        ...prefersColorSchemeDarkMediaQuery(theme, {
                            background: colorMapDark[color],
                        }),
                    }),
                ...buildResponsiveStyles(orientation, (o) => o === 'horizontal' ? { height: '1px', width: '100%' } : { height: '100%', width: '1px' }),
            },
        },
    });
};

const getComponentCss$V = (state, labelSize, hasLabel, theme) => {
    return getCss({
        '@global': {
            ':host': {
                display: 'block',
                ...addImportantToEachRule({
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            fieldset: {
                margin: 0,
                padding: 0,
                border: 'none',
            },
            ...(hasLabel && {
                legend: {
                    margin: `0 0 ${spacingStaticMedium}`,
                    padding: 0,
                    color: getThemedColors(theme).primaryColor,
                    ...(labelSize === 'small' ? headingSmallStyle : headingMediumStyle),
                    ...prefersColorSchemeDarkMediaQuery(theme, {
                        color: getThemedColors('dark').primaryColor,
                    }),
                },
            }),
        },
        ...getFunctionalComponentRequiredStyles(),
        ...mergeDeep(getFunctionalComponentStateMessageStyles(theme, state), {
            message: {
                marginTop: spacingStaticMedium,
            },
        }),
    });
};

const getComponentCss$U = (state, labelSize, hasLabel, theme) => {
    return getCss({
        '@global': {
            ':host': {
                display: 'block',
                ...addImportantToEachRule({
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            fieldset: {
                margin: 0,
                padding: 0,
                border: 'none',
            },
            ...(hasLabel && {
                legend: {
                    margin: `0 0 ${spacingStaticMedium}`,
                    padding: 0,
                    color: getThemedColors(theme).primaryColor,
                    ...prefersColorSchemeDarkMediaQuery(theme, {
                        color: getThemedColors('dark').primaryColor,
                    }),
                    ...(labelSize === 'small' ? headingSmallStyle : headingMediumStyle),
                },
            }),
        },
        ...getFunctionalComponentRequiredStyles(),
        ...mergeDeep(getFunctionalComponentStateMessageStyles(theme, state), {
            message: {
                marginTop: spacingStaticMedium,
            },
        }),
    });
};

const flexItemWidths = {
    none: 0,
    'one-quarter': 25,
    'one-third': 33.333333,
    half: 50,
    'two-thirds': 66.666667,
    'three-quarters': 75,
    full: 100,
    auto: 'auto',
};
const getComponentCss$T = (width, offset, alignSelf, grow, shrink, flex) => {
    return getCss({
        '@global': {
            ':host': addImportantToEachRule({
                boxSizing: 'border-box',
                ...hostHiddenStyles,
                ...mergeDeep(buildResponsiveStyles(width, (widthResponsive) => ({
                    width: `${flexItemWidths[widthResponsive]}%`,
                })), buildResponsiveStyles(offset, (offsetResponsive) => ({
                    marginLeft: `${flexItemWidths[offsetResponsive]}%`,
                })), buildResponsiveStyles(alignSelf, (alignSelfResponsive) => ({
                    alignSelf: alignSelfResponsive,
                })), flex !== 'initial' // flex shorthand conflicts with grow and shrink, which means even default grow or shrink props would override flex
                    ? buildResponsiveStyles(flex, (flexResponsive) => ({
                        flex: flexResponsive === 'equal' ? '1 1 0' : flexResponsive,
                    }))
                    : mergeDeep(buildResponsiveStyles(grow, (flexGrow) => ({ flexGrow })), buildResponsiveStyles(shrink, (flexShrink) => ({ flexShrink })))),
            }),
        },
    });
};

const getComponentCss$S = (inline, wrap, direction, justifyContent, alignItems, alignContent) => {
    return getCss({
        '@global': {
            ':host': {
                ...buildResponsiveStyles(inline, (inlineResponsive) => ({
                    display: inlineResponsive ? 'inline-flex' : 'flex',
                })),
                ...addImportantToEachRule(mergeDeep(colorSchemeStyles, hostHiddenStyles, buildResponsiveStyles(wrap, (flexWrapResponsive) => ({ flexWrap: flexWrapResponsive })), buildResponsiveStyles(direction, (flexDirectionResponsive) => ({
                    flexDirection: flexDirectionResponsive,
                })), buildResponsiveStyles(justifyContent, (justifyContentResponsive) => ({
                    justifyContent: justifyContentResponsive,
                })), buildResponsiveStyles(alignItems, (alignItemsResponsive) => ({
                    alignItems: alignItemsResponsive,
                })), buildResponsiveStyles(alignContent, (alignContentResponsive) => ({
                    alignContent: alignContentResponsive,
                })))),
            },
        },
    });
};

const getFlyoutDialogResetJssStyle = () => {
    return {
        position: 'fixed',
        height: '100dvh',
        maxHeight: '100dvh',
        margin: '0',
        padding: '0',
        border: '0',
        visibility: 'inherit',
        outline: '0',
    };
};

const cssVariableVisibility = '--p-internal-flyout-navigation-visibility';
const cssVariableVisibilityTransitionDuration = '--p-internal-flyout-navigation-visibility-transition-duration';
const frostedGlassHeaderHeight = '4rem';
const frostedGlassBackgroundColorLight$1 = 'rgba(255, 255, 255, 0.79)';
const frostedGlassBackgroundColorDark$1 = 'rgba(14, 14, 18, 0.79)';
const scrollerWidthEnhancedView = 'clamp(338px, 10.52vw + 258px, 460px)';
const mediaQueryEnhancedView = getMediaQueryMin('s');
const getComponentCss$R = (isPrimaryScrollerVisible, isSecondaryScrollerVisible, theme) => {
    const { backgroundColor } = getThemedColors(theme);
    const { backgroundColor: backgroundColorDark } = getThemedColors('dark');
    const frostedGlassBackgroundColor = isThemeDark(theme)
        ? frostedGlassBackgroundColorDark$1
        : frostedGlassBackgroundColorLight$1;
    return getCss({
        '@global': {
            ':host': {
                display: 'block',
                ...addImportantToEachRule({
                    ...(!isPrimaryScrollerVisible && {
                        [cssVariableVisibility]: 'hidden',
                        [cssVariableVisibilityTransitionDuration]: motionDurationLong,
                    }),
                    ...getBackdropJssStyle(isPrimaryScrollerVisible, FLYOUT_Z_INDEX, theme),
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            dialog: {
                ...getFlyoutDialogResetJssStyle(),
                inset: '0',
                display: 'grid',
                overflow: 'hidden',
                width: 'auto',
                maxWidth: '100vw',
                background: 'none',
                ...(isPrimaryScrollerVisible
                    ? {
                        transform: 'translate3d(0, 0, 0)',
                        transition: `${getTransition('transform', 'long', 'in')}`,
                    }
                    : {
                        transform: 'translate3d(-100%, 0, 0)',
                        transition: `${getTransition('transform', 'long', 'out')}`,
                    }),
                [mediaQueryEnhancedView]: {
                    gridTemplateColumns: `repeat(${isSecondaryScrollerVisible ? 2 : 1}, ${scrollerWidthEnhancedView}) auto`,
                    gridTemplateRows: '100vh',
                    insetInlineEnd: 'auto', // to have correct dialog dimensions for ideal transitions
                },
                '&:dir(rtl)': {
                    ...(!isPrimaryScrollerVisible && {
                        transform: 'translate3d(100%, 0, 0)', // use correct transitions in rtl mode
                    }),
                },
                '&::backdrop': {
                    // to improve browser backwards compatibility we visually style the backdrop on the :host,
                    // although it's not on the #top-layer like it would be for modern browsers supporting ::backdrop
                    opacity: 0, // to support backdrop click for modern browsers supporting ::backdrop
                },
            },
        },
        scroller: {
            gridArea: '1/1',
            overflow: 'auto',
            // cssVariableVisibility ensures secondary scroller is not tabbable when whole flyout-navigation is closed
            // on mobile we need to decide if secondary scroller needs to be visible or not, on desktop it's not necessary but also doesn't harm
            visibility: `var(${cssVariableVisibility},${isSecondaryScrollerVisible ? 'hidden' : 'inherit'})`,
            transition: `${getTransition('left', 'long', isSecondaryScrollerVisible ? 'in' : 'out')}, visibility 0s linear var(${cssVariableTransitionDuration}, ${!isPrimaryScrollerVisible || isSecondaryScrollerVisible ? motionDurationLong : '0s'})`,
            // it's important to define background-color for each scroller to have correct scrollbar coloring
            backgroundColor,
            ...prefersColorSchemeDarkMediaQuery(theme, {
                backgroundColor: backgroundColorDark,
            }),
            [mediaQueryEnhancedView]: {
                visibility: 'inherit',
                transition: 'initial',
            },
            // simulates frosted glass header, to be visually in sync with header of secondary scroller
            '&::before': {
                content: '""',
                display: 'block',
                position: 'sticky',
                top: 0,
                zIndex: 1,
                height: frostedGlassHeaderHeight,
                backgroundColor: frostedGlassBackgroundColor,
                WebkitBackdropFilter: 'blur(8px)',
                backdropFilter: 'blur(8px)', // with current frostedGlassStyle of blur(32px) scrolling becomes visually distracting
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    backgroundColor: frostedGlassBackgroundColorDark$1,
                }),
                [mediaQueryEnhancedView]: {
                    display: 'none',
                },
            },
        },
        content: {
            display: 'flex',
            flexDirection: 'column',
            gap: spacingFluidXSmall,
            padding: `${spacingFluidSmall} ${spacingFluidLarge} ${spacingFluidLarge}`,
            [mediaQueryEnhancedView]: {
                padding: `${spacingFluidMedium} ${spacingFluidLarge} ${spacingFluidLarge}`,
            },
        },
        // header is needed to keep position of dismiss button in sync with header of secondary scroller
        header: {
            position: 'relative',
            zIndex: 3, // ensures dismiss button is visible on secondary drawer in mobile view
            gridArea: '1/1',
            alignSelf: 'flex-start',
            justifySelf: 'flex-end',
            marginInlineEnd: `calc(${spacingFluidLarge} - ${spacingFluidSmall})`,
            height: frostedGlassHeaderHeight,
            display: 'flex',
            alignItems: 'center',
            [mediaQueryEnhancedView]: {
                marginInlineEnd: 0,
                gridArea: '1/-1',
                placeSelf: 'flex-start',
            },
        },
        dismiss: {
            padding: spacingFluidSmall,
            [mediaQueryEnhancedView]: {
                '--p-internal-icon-filter': 'invert(1)',
                margin: spacingFluidSmall,
                padding: spacingStaticSmall,
            },
        },
    });
};
const getContentJssStyle = () => {
    return {
        display: 'flex',
        flexDirection: 'column',
        gap: spacingFluidXSmall,
        padding: `${spacingFluidSmall} ${spacingFluidLarge} ${spacingFluidLarge}`,
        [mediaQueryEnhancedView]: {
            padding: `${spacingFluidMedium} ${spacingFluidLarge} ${spacingFluidLarge}`,
        },
    };
};

const frostedGlassBackgroundColorLight = 'rgba(238, 239, 242, 0.79)';
const frostedGlassBackgroundColorDark = 'rgba(33, 34, 37, 0.79)';
const getComponentCss$Q = (isSecondaryScrollerVisible, theme) => {
    const { primaryColor, backgroundSurfaceColor, hoverColor } = getThemedColors(theme);
    const { primaryColor: primaryColorDark, backgroundSurfaceColor: backgroundSurfaceColorDark, hoverColor: hoverColorDark, } = getThemedColors('dark');
    const frostedGlassBackgroundColor = isThemeDark(theme)
        ? frostedGlassBackgroundColorDark
        : frostedGlassBackgroundColorLight;
    const fadeInOutTransition = isSecondaryScrollerVisible
        ? {
            opacity: 1,
            transition: `${getTransition('opacity', 'veryLong', 'in', 'short')}`,
            [mediaQueryEnhancedView]: {
                transition: `${getTransition('opacity', 'veryLong', 'in')}`,
            },
        }
        : {
            opacity: 0,
            transition: `${getTransition('opacity', 'short', 'out')}`,
        };
    return getCss({
        '@global': {
            ':host': {
                display: 'block',
                ...addImportantToEachRule({
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            '::slotted(:is(h1, h2, h3, h4, h5, h6))': addImportantToEachRule({
                ...headingSmallStyle,
                margin: 0,
                color: primaryColor,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    color: primaryColorDark,
                }),
            }),
            '::slotted(:is(h1, h2, h3, h4, h5, h6):not(:first-child))': addImportantToEachRule({
                margin: `calc(${spacingFluidMedium} - ${spacingFluidXSmall}) 0 0`, // spacingFluidXSmall to compensate default gap
            }),
            '::slotted': addImportantToEachRule({
                '&(p)': {
                    ...textSmallStyle,
                    margin: 0,
                    color: primaryColor,
                    ...prefersColorSchemeDarkMediaQuery(theme, {
                        color: primaryColorDark,
                    }),
                },
                '&(a)': {
                    ...{
                        ...textSmallStyle,
                        alignSelf: 'flex-start',
                        display: 'block',
                        textDecoration: 'none',
                        cursor: 'pointer',
                        color: primaryColor,
                        borderRadius: borderRadiusSmall,
                        marginLeft: `-${spacingStaticXSmall}`,
                        marginRight: `-${spacingStaticXSmall}`,
                        padding: `2px ${spacingStaticXSmall}`,
                        transition: `background var(${cssVariableTransitionDuration}, ${motionDurationShort}) ${motionEasingBase}`,
                        ...prefersColorSchemeDarkMediaQuery(theme, {
                            color: primaryColorDark,
                        }),
                    },
                },
                '&(a[aria-current])': {
                    background: hoverColor,
                    ...prefersColorSchemeDarkMediaQuery(theme, {
                        background: hoverColorDark,
                    }),
                },
                ...hoverMediaQuery({
                    // TODO: how can we easily re-use getHoverStyle() with ::slotted(a) selector?
                    '&(a:hover)': {
                        background: hoverColor,
                        ...prefersColorSchemeDarkMediaQuery(theme, {
                            background: hoverColorDark,
                        }),
                    },
                }),
                ...getFocusJssStyle(theme, { slotted: 'a', offset: '-2px' }),
            }),
        },
        button: {
            width: 'auto',
            padding: spacingFluidSmall,
            margin: `0 calc(${spacingFluidSmall} * -1)`,
        },
        scroller: {
            position: 'fixed',
            inset: 0,
            // "cssVariableTransitionDuration" ensures closing animation of secondary scroller is given when whole flyout-navigation gets closed
            // "cssVariableVisibility" ensures secondary scroller is not tabbable when whole flyout-navigation is closed
            ...(isSecondaryScrollerVisible
                ? {
                    zIndex: 2,
                    transform: 'translate3d(0, 0, 0)',
                    // TODO: Should be visibility: inherit to allow overwriting but currently not possible since it would inherit from the scroller of the p-flyout-navigation itself, which is hidden on mobile
                    visibility: `var(${cssVariableVisibility},visible)`,
                    transition: `${getTransition('transform', 'long', 'in')}, visibility 0s linear var(${cssVariableTransitionDuration},var(${cssVariableVisibilityTransitionDuration},0s))`,
                }
                : {
                    zIndex: 1,
                    transform: 'translate3d(100%, 0, 0)',
                    visibility: `var(${cssVariableVisibility},hidden)`,
                    transition: `${getTransition('transform', 'long', 'out')}, visibility 0s linear var(${cssVariableTransitionDuration},var(${cssVariableVisibilityTransitionDuration},${motionDurationLong}))`,
                }),
            width: '100vw',
            boxSizing: 'border-box',
            overflow: 'auto',
            ...dropShadowHighStyle,
            // it's important to define background-color for each scroller to have correct scrollbar coloring
            backgroundColor: backgroundSurfaceColor,
            ...prefersColorSchemeDarkMediaQuery(theme, {
                backgroundColor: backgroundSurfaceColorDark,
            }),
            [mediaQueryEnhancedView]: {
                boxShadow: 'none',
                insetInlineStart: `calc(${scrollerWidthEnhancedView} - 1px)`, // -1px prevents possible visible background under certain circumstances between primary and secondary scroller
                width: scrollerWidthEnhancedView,
                transform: addImportantToRule('initial'), // to overrule :dir(rtl) selector
                transition: `visibility 0s linear var(${cssVariableTransitionDuration},var(${cssVariableVisibilityTransitionDuration},0s))`,
            },
            '&:dir(rtl)': {
                ...(!isSecondaryScrollerVisible && {
                    transform: 'translate3d(-100%, 0, 0)', // use correct transitions in rtl mode for mobile view
                }),
            },
        },
        // header needs to be placed within scroller to ensure scrollbars are fully visible
        header: {
            position: 'sticky',
            top: 0,
            zIndex: 1,
            height: frostedGlassHeaderHeight,
            padding: `0 ${spacingFluidLarge}`,
            display: 'grid',
            gridTemplateColumns: '4rem minmax(0, 1fr) 4rem',
            alignItems: 'center',
            gap: spacingFluidSmall,
            WebkitBackdropFilter: 'blur(8px)',
            backdropFilter: 'blur(8px)', // with current frostedGlassStyle of blur(32px) scrolling becomes visually distracting
            backgroundColor: frostedGlassBackgroundColor,
            ...fadeInOutTransition,
            ...prefersColorSchemeDarkMediaQuery(theme, {
                backgroundColor: frostedGlassBackgroundColorDark,
            }),
            [mediaQueryEnhancedView]: {
                display: 'none',
            },
        },
        back: {
            justifySelf: 'flex-start',
            padding: spacingFluidSmall,
            marginInlineStart: `calc(${spacingFluidSmall} * -1)`,
        },
        heading: {
            ...headingMediumStyle,
            margin: 0,
            padding: 0,
            overflow: 'hidden',
            textAlign: 'center',
            whiteSpace: 'nowrap',
            textOverflow: 'ellipsis',
            color: primaryColor,
            ...prefersColorSchemeDarkMediaQuery(theme, {
                color: primaryColorDark,
            }),
        },
        content: mergeDeep(getContentJssStyle(), fadeInOutTransition),
    });
};

const headerShadowClass = 'header--shadow';
const footerShadowClass$1 = 'footer--shadow';
const getComponentCss$P = (isOpen, position, hasFooter, hasSubFooter, theme) => {
    const { primaryColor, backgroundColor } = getThemedColors(theme);
    const { primaryColor: primaryColorDark, backgroundColor: backgroundColorDark } = getThemedColors('dark');
    const isPositionStart = position === 'start';
    const contentPadding = `${spacingStaticMedium} ${spacingFluidLarge}`;
    const isDark = isThemeDark(theme);
    const shadowColor = isDark ? scrollShadowColorDark : scrollShadowColor;
    const transparentColorDark = 'rgba(14, 14, 18, 0)';
    const transparentColor = isDark ? transparentColorDark : 'rgba(255, 255, 255, 0)';
    return getCss({
        '@global': {
            ':host': {
                display: 'block',
                ...addImportantToEachRule({
                    // needed for correct alignment of the Porsche Grid within the Flyout
                    '--pds-internal-grid-outer-column': `calc(${spacingFluidLarge} - ${gridGap})`,
                    '--pds-internal-grid-margin': `calc(${spacingFluidLarge} * -1)`,
                    ...getBackdropJssStyle(isOpen, FLYOUT_Z_INDEX, theme),
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            dialog: {
                ...getFlyoutDialogResetJssStyle(),
                insetInline: isPositionStart ? '0 0' : 'auto 0',
                insetBlock: '0 0',
                display: 'flex',
                flexDirection: 'column',
                boxSizing: 'border-box',
                width: 'var(--p-flyout-width, fit-content)',
                minWidth: '320px',
                maxWidth: 'var(--p-flyout-max-width, 1180px)',
                color: primaryColor, // enables color inheritance for slotted content
                background: backgroundColor,
                ...(isOpen
                    ? {
                        opacity: 1,
                        transform: 'initial',
                        transition: `${getTransition('opacity', 'long', 'in')}, ${getTransition('transform', 'long', 'in')}`,
                    }
                    : {
                        opacity: 0,
                        transform: `translate3d(${isPositionStart ? '-100%' : '100%'}, 0, 0)`,
                        transition: `${getTransition('opacity', 'short', 'out', 'long')}, ${getTransition('transform', 'long', 'out')}`,
                    }),
                boxShadow: `${isPositionStart ? '3px' : '-3px'} 0px 30px rgba(0, 0, 0, 0.25)`,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    color: primaryColorDark,
                    background: backgroundColorDark,
                }),
                '&:focus-visible': {
                    outline: 'none', // ua-style reset
                },
                '&::backdrop': {
                    // to improve browser backwards compatibility we visually style the backdrop on the :host,
                    // although it's not on the #top-layer like it would be for modern browsers supporting ::backdrop
                    opacity: 0, // to support backdrop click for modern browsers supporting ::backdrop
                },
            },
        },
        wrapper: {
            display: 'flex', // ua-style reset
            flexGrow: 1,
            height: 0,
            flexDirection: 'column',
            ...(hasSubFooter && {
                overflowY: 'auto',
                overscrollBehaviorY: 'none',
            }),
        },
        header: {
            position: 'sticky',
            top: 0,
            zIndex: 2,
            display: 'grid',
            gridTemplateColumns: `minmax(0, 1fr) ${spacingFluidLarge}`,
            alignItems: 'flex-start',
            padding: `${spacingStaticMedium} 0`,
            paddingInlineStart: spacingFluidLarge,
            background: backgroundColor,
            ...prefersColorSchemeDarkMediaQuery(theme, {
                background: backgroundColorDark,
            }),
        },
        [headerShadowClass]: {
            boxShadow: `${isDark ? scrollShadowColorDark : scrollShadowColor} 0px 5px 10px`,
            ...prefersColorSchemeDarkMediaQuery(theme, {
                boxShadow: `${scrollShadowColorDark} 0px 5px 10px`,
            }),
        },
        dismiss: {
            gridArea: '1 / 2',
            justifySelf: 'center',
        },
        content: {
            padding: contentPadding,
            maxWidth: `calc(100vw - calc(${spacingFluidLarge} * 2))`,
            position: 'relative',
            zIndex: 0,
            backgroundColor, // to ensure scrollbar coloring is optimal for light theme
            ...prefersColorSchemeDarkMediaQuery(theme, {
                backgroundColor: backgroundColorDark, // to ensure scrollbar coloring is optimal for dark theme
            }),
            // If sub-footer is used scroll shadows have to be done via JS
            ...(!hasSubFooter && {
                overflowY: 'auto',
                WebkitOverflowScrolling: 'touch',
                backgroundImage: `linear-gradient(to top, ${backgroundColor}, ${backgroundColor}), linear-gradient(to top, ${backgroundColor}, ${backgroundColor}), linear-gradient(to top, ${shadowColor}, ${transparentColor}), linear-gradient(to bottom, ${shadowColor}, ${transparentColor})`,
                backgroundPosition: 'bottom center, top center, bottom center, top center',
                backgroundRepeat: 'no-repeat',
                backgroundSize: '100% 20px, 100% 20px, 100% 10px, 100% 10px',
                backgroundAttachment: 'local, local, scroll, scroll',
                overscrollBehaviorY: 'none',
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    backgroundImage: `linear-gradient(to top, ${backgroundColorDark}, ${backgroundColorDark}), linear-gradient(to top, ${backgroundColorDark}, ${backgroundColorDark}), linear-gradient(to top, ${scrollShadowColorDark}, ${transparentColorDark}), linear-gradient(to bottom, ${scrollShadowColorDark}, ${transparentColorDark})`,
                    backgroundColor: backgroundColorDark, // to ensure scrollbar coloring is optimal for dark theme
                }),
            }),
        },
        ...(hasFooter && {
            footer: {
                position: 'sticky',
                bottom: 0,
                zIndex: 1,
                padding: contentPadding,
                background: backgroundColor,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    background: backgroundColorDark,
                }),
            },
            [footerShadowClass$1]: {
                boxShadow: `${isDark ? scrollShadowColorDark : scrollShadowColor} 0px -5px 10px`,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    boxShadow: `${scrollShadowColorDark} 0px -5px 10px`,
                }),
            },
        }),
        ...(hasSubFooter && {
            'sub-footer': {
                padding: contentPadding,
            },
        }),
    });
};

const gutter$1 = `calc(${gridGap} / 2)`;
const gridItemWidths = [
    0, 8.333333, 16.666667, 25, 33.333333, 41.666667, 50, 58.333333, 66.666667, 75, 83.333333, 91.666667, 100,
];
const getComponentCss$O = (size, offset) => {
    return getCss({
        '@global': {
            ':host': addImportantToEachRule({
                paddingLeft: gutter$1,
                paddingRight: gutter$1,
                boxSizing: 'border-box',
                ...hostHiddenStyles,
                ...mergeDeep(buildResponsiveStyles(size, (sizeResponsive) => ({
                    width: `${gridItemWidths[sizeResponsive]}%`,
                    minWidth: `${gridItemWidths[sizeResponsive]}%`,
                })), buildResponsiveStyles(offset, (offsetResponsive) => ({
                    marginLeft: `${gridItemWidths[offsetResponsive]}%`,
                }))),
            }),
        },
    });
};

const gutter = `calc(${gridGap} / -2)`;
const getComponentCss$N = (direction, wrap) => {
    return getCss({
        '@global': {
            ':host': {
                display: 'flex',
                ...addImportantToEachRule({
                    flex: 'auto',
                    width: 'auto',
                    marginLeft: gutter,
                    marginRight: gutter,
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                    ...mergeDeep(buildResponsiveStyles(direction, (flexDirection) => ({ flexDirection })), buildResponsiveStyles(wrap, (flexWrap) => ({ flexWrap }))),
                }),
            },
        },
    });
};

const sizeMap$3 = {
    small: fontSizeHeadingSmall,
    medium: fontSizeHeadingMedium,
    large: fontSizeHeadingLarge,
    'x-large': fontSizeHeadingXLarge,
    'xx-large': fontSizeHeadingXXLarge,
};
const getComponentCss$M = (size, align, color, ellipsis, theme) => {
    return getCss({
        '@global': {
            ':host': {
                display: 'block',
                ...addImportantToEachRule({
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            '::slotted': {
                [HEADING_TAGS.map((i) => `&(${i})`).join()]: addImportantToEachRule(getTypographySlottedJssStyle()),
            },
        },
        root: getTypographyRootJssStyle(headingXXLargeStyle, buildResponsiveStyles(size, (sizeValue) => ({
            fontSize: sizeValue === 'inherit' ? sizeValue : sizeMap$3[sizeValue],
        })), align, color, ellipsis, theme),
    });
};

const HEADLINE_VARIANTS = [
    'large-title',
    'headline-1',
    'headline-2',
    'headline-3',
    'headline-4',
    'headline-5',
];
const HEADLINE_TAGS = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
const isValidVariantType = (variant) => {
    return HEADLINE_VARIANTS.includes(variant);
};

const headlineSizeMap = {
    'headline-1': fontSizeHeadingXXLarge,
    'headline-2': fontSizeHeadingXLarge,
    'headline-3': fontSizeHeadingLarge,
    'headline-4': fontSizeHeadingMedium,
    'headline-5': fontSizeHeadingSmall,
};
const getHeadlineVariantJssStyle = (variant) => {
    return {
        ...(variant === 'large-title'
            ? displayMediumStyle
            : {
                fontSize: headlineSizeMap[variant],
            }),
    };
};
const textSizeMap = {
    'xx-small': fontSizeTextXXSmall,
    'x-small': fontSizeTextXSmall,
    small: fontSizeTextSmall,
    medium: fontSizeTextMedium,
    large: fontSizeTextLarge,
    'x-large': fontSizeTextXLarge,
};
const getTextSizeJssStyle = (textSize) => {
    return {
        fontSize: textSize === 'inherit' ? textSize : textSizeMap[textSize],
    };
};
const getComponentCss$L = (variant, align, color, ellipsis, theme) => {
    return getCss({
        '@global': {
            ':host': {
                display: 'block',
                ...addImportantToEachRule({
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            '::slotted': {
                [HEADLINE_TAGS.map((i) => `&(${i})`).join()]: addImportantToEachRule(getTypographySlottedJssStyle()),
            },
        },
        root: getTypographyRootJssStyle(headingXXLargeStyle, isValidVariantType(variant)
            ? getHeadlineVariantJssStyle(variant)
            : buildResponsiveStyles(variant, getTextSizeJssStyle), align, color, ellipsis, theme),
    });
};

const toFilter = (values) => `invert(${values[0]}%) sepia(${values[1]}%) saturate(${values[2]}%) hue-rotate(${values[3]}deg) brightness(${values[4]}%) contrast(${values[5]}%)`;

const filterLightContrastLow = toFilter([93, 11, 36, 201, 89, 102]);
const filterLightContrastMedium = toFilter([45, 6, 235, 177, 91, 85]);
const filterLightContrastHigh = toFilter([40, 2, 686, 187, 80, 94]);
const filterDarkContrastLow = toFilter([20, 7, 421, 202, 97, 82]);
const filterDarkContrastMedium = toFilter([66, 3, 333, 187, 82, 86]);
const filterDarkContrastHigh = toFilter([68, 6, 108, 187, 104, 88]);

const filterLightDisabled = toFilter([63, 8, 108, 188, 94, 86]);
const filterDarkDisabled = toFilter([52, 6, 135, 187, 94, 89]);

const filterLightNotificationSuccess = toFilter([28, 89, 572, 71, 111, 98]);
const filterLightNotificationWarning = toFilter([58, 53, 820, 12, 112, 103]);
const filterLightNotificationError = toFilter([14, 75, 4140, 347, 100, 97]);
const filterLightNotificationInfo = toFilter([44, 100, 492, 195, 86, 221]);
const filterDarkNotificationSuccess = toFilter([60, 71, 512, 106, 91, 97]);
const filterDarkNotificationWarning = toFilter([75, 39, 759, 350, 109, 94]);
const filterDarkNotificationError = toFilter([64, 91, 5857, 336, 98, 102]);
const filterDarkNotificationInfo = toFilter([56, 77, 4175, 198, 104, 98]);

const filterLightPrimary = toFilter([3, 7, 2930, 188, 91, 103]);
const filterDarkPrimary = toFilter([100, 91, 38, 254, 110, 110]);

const sizeMap$2 = {
    'xx-small': fontSizeTextXXSmall,
    'x-small': fontSizeTextXSmall,
    small: fontSizeTextSmall,
    medium: fontSizeTextMedium,
    large: fontSizeTextLarge,
    'x-large': fontSizeTextXLarge,
};
const filterLight = {
    primary: filterLightPrimary,
    'state-disabled': filterLightDisabled,
    'contrast-low': filterLightContrastLow,
    'contrast-medium': filterLightContrastMedium,
    'contrast-high': filterLightContrastHigh,
    'notification-success': filterLightNotificationSuccess,
    'notification-warning': filterLightNotificationWarning,
    'notification-error': filterLightNotificationError,
    'notification-info': filterLightNotificationInfo,
};
const filterDark = {
    primary: filterDarkPrimary,
    'state-disabled': filterDarkDisabled,
    'contrast-low': filterDarkContrastLow,
    'contrast-medium': filterDarkContrastMedium,
    'contrast-high': filterDarkContrastHigh,
    'notification-success': filterDarkNotificationSuccess,
    'notification-warning': filterDarkNotificationWarning,
    'notification-error': filterDarkNotificationError,
    'notification-info': filterDarkNotificationInfo,
};
const filterMap = {
    auto: filterLight,
    light: filterLight,
    dark: filterDark,
};
const forceRerenderAnimationStyle = {
    '0%': {
        transform: 'rotateZ(0)',
    },
    '100%': {
        transform: 'rotateZ(0)',
    },
};
const keyFramesLight = 'rerender-light';
const keyFramesDark = 'rerender-dark';
const cssVariableFilter = '--p-internal-icon-filter';
const isFlippableIcon = (name, source) => {
    return (!source &&
        (name === 'arrow-double-left' ||
            name === 'arrow-double-right' ||
            name === 'arrow-first' ||
            name === 'arrow-head-left' ||
            name === 'arrow-head-right' ||
            name === 'arrow-last' ||
            name === 'arrow-left' ||
            name === 'arrow-right' ||
            name === 'chart' ||
            name === 'chat' ||
            name === 'external' ||
            name === 'increase' ||
            name === 'list' ||
            name === 'logout' ||
            name === 'send'));
};
const getComponentCss$K = (name, source, color, size, theme) => {
    const isColorInherit = color === 'inherit';
    const isSizeInherit = size === 'inherit';
    const isDark = isThemeDark(theme);
    const animationName = `${isDark ? keyFramesDark : keyFramesLight}-${color}`;
    return getCss({
        '@global': {
            ':host': {
                display: 'inline-block',
                verticalAlign: 'top',
                ...addImportantToEachRule({
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            img: {
                display: 'block', // without display, img tag gets some extra spacing
                margin: 0,
                padding: 0,
                pointerEvents: 'none', // disable dragging/ghosting of images
                ...(!isColorInherit && {
                    filter: `var(${cssVariableFilter},${filterMap[theme][color]})`,
                    ...prefersColorSchemeDarkMediaQuery(theme, {
                        filter: `var(${cssVariableFilter},${filterMap.dark[color]})`,
                    }),
                    ...(isHighContrastMode &&
                        getSchemedHighContrastMediaQuery({
                            filter: filterMap.light[color],
                        }, {
                            filter: filterMap.dark[color],
                        })),
                    WebkitAnimation: `${animationName} 1ms`, // needed to enforce repaint in Safari if theme is switched programmatically
                }),
                ...(isSizeInherit
                    ? {
                        width: size,
                        height: size,
                    }
                    : {
                        width: fontLineHeight,
                        height: fontLineHeight,
                        font: `${sizeMap$2[size]} ${fontFamily}`,
                    }),
                ...(isFlippableIcon(name, source) && {
                    '&:dir(rtl)': {
                        transform: 'scaleX(-1)',
                    },
                }),
            },
            ...(!isColorInherit && {
                [`@keyframes ${animationName}`]: forceRerenderAnimationStyle,
            }),
        },
    });
};

const mediaQueryMinS$1 = getMediaQueryMin('s');
const mediaQueryMaxS$2 = getMediaQueryMax('s');
const getBackgroundColor = (state, theme) => {
    const { infoSoftColor, successSoftColor, errorSoftColor, warningSoftColor } = getThemedColors(theme);
    const colorMap = {
        neutral: infoSoftColor, // deprecated
        info: infoSoftColor,
        warning: warningSoftColor,
        success: successSoftColor,
        error: errorSoftColor,
    };
    return colorMap[state];
};
const getNotificationRootJssStyle = (state, hasAction, hasClose, theme) => {
    return {
        // display: 'grid', // NOTE: display property is moved into component styled to not apply !important keyword
        // 2 columns for content and optional close button
        gridTemplateColumns: `minmax(auto, 1fr)${hasClose ? ' auto' : ''}`,
        gap: spacingStaticMedium,
        placeItems: 'start',
        padding: spacingStaticMedium,
        background: getBackgroundColor(state, theme),
        ...prefersColorSchemeDarkMediaQuery(theme, {
            background: getBackgroundColor(state, 'dark'),
        }),
        borderRadius: borderRadiusSmall,
        ...(isHighContrastMode && {
            outline: '1px solid transparent',
        }),
        [mediaQueryMinS$1]: {
            // 4 columns are for icon, content, optional action button and optional close button
            gridTemplateColumns: `auto minmax(auto, 1fr)${hasAction ? ' auto' : ''}${hasClose ? ' auto' : ''}`,
        },
    };
};
const getNotificationIconJssStyle = () => ({
    [mediaQueryMaxS$2]: {
        display: 'none',
    },
});
const getNotificationContentJssStyle = () => ({
    display: 'grid',
    gap: spacingStaticXSmall,
    maxWidth: '50rem',
    [mediaQueryMinS$1]: {
        marginLeft: `-${spacingStaticSmall}`,
    },
});

const mediaQueryMaxS$1 = getMediaQueryMax('s');
const getComponentCss$J = (state, hasAction, hasClose, theme) => {
    return getCss({
        '@global': {
            ':host': {
                display: 'grid',
                ...addImportantToEachRule({
                    ...getNotificationRootJssStyle(state, hasAction, hasClose, theme),
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            h5: headingSmallStyle,
            p: textSmallStyle,
            'h5,p': {
                margin: 0,
                color: getThemedColors(theme).primaryColor,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    color: getThemedColors('dark').primaryColor,
                }),
            },
        },
        icon: getNotificationIconJssStyle(),
        content: getNotificationContentJssStyle(),
        ...(hasAction && {
            action: {
                [mediaQueryMaxS$1]: {
                    gridRowStart: 2,
                },
            },
        }),
    });
};

const getComponentCss$I = (icon, iconSource, active, stretch, size, hideLabel, alignLabel, underline, hasSlottedAnchor, theme) => {
    return getCss(mergeDeep(getLinkButtonPureStyles(icon, iconSource, active, false, stretch, size, hideLabel, alignLabel, hasSlottedAnchor, theme), {
        root: {
            textDecoration: underline ? 'underline' : 'none',
        },
    }, hasSlottedAnchor && {
        '@global': addImportantToEachRule({
            '::slotted': {
                '&(a)': {
                    ...getResetInitialStylesForSlottedAnchor,
                    textDecoration: underline ? 'underline' : 'none',
                    font: 'inherit',
                    color: 'inherit',
                },
                // The clickable area for Safari < ~15 (<= release date: 2021-10-28) is reduced to the slotted anchor itself,
                // since Safari prior to this major release does not support pseudo-elements in the slotted context
                // (https://bugs.webkit.org/show_bug.cgi?id=178237)
                '&(a)::before': {
                    content: '""',
                    position: 'fixed',
                    insetBlock: offsetVertical,
                    borderRadius: borderRadiusSmall,
                    ...buildResponsiveStyles(hideLabel, (hideLabelValue) => ({
                        insetInline: hideLabelValue ? offsetVertical : offsetHorizontal,
                    })),
                },
                ...getFocusJssStyle(theme, { slotted: 'a', pseudo: true, offset: '-2px' }),
            },
        }),
    }));
};

const getComponentCss$H = (icon, iconSource, variant, hideLabel, hasSlottedAnchor, theme) => {
    const { linkColor } = getHighContrastColors();
    const isPrimary = variant === 'primary';
    return getCss(mergeDeep(getLinkButtonStyles(icon, iconSource, variant, hideLabel, false, hasSlottedAnchor, theme), {
        label: {
            clip: addImportantToRule('unset'), // to overrule breakpoint customizable hide-label style
        },
        icon: {
            ...(isPrimary &&
                !isHighContrastMode && {
                filter: 'invert(1)',
            }),
        },
    }, hasSlottedAnchor && {
        ...(isHighContrastMode && {
            root: {
                borderColor: linkColor,
            },
        }),
        '@global': addImportantToEachRule({
            '::slotted': {
                '&(a)': {
                    ...getResetInitialStylesForSlottedAnchor,
                    textDecoration: 'none',
                    font: 'inherit',
                    color: 'inherit',
                },
                // The clickable area for Safari < ~15 (<= release date: 2021-10-28) is reduced to the slotted anchor itself,
                // since Safari prior to this major release does not support pseudo-elements in the slotted context
                // (https://bugs.webkit.org/show_bug.cgi?id=178237)
                '&(a)::before': {
                    content: '""',
                    position: 'fixed',
                    inset: '-2px',
                    borderRadius: borderRadiusSmall,
                },
                ...getFocusJssStyle(theme, { slotted: 'a', pseudo: true }),
            },
        }),
    }));
};

// array is redefined instead of using the one from in model-signature
// because it is created via Object.keys(MODEL_SIGNATURES_MANIFEST) would bundle the entire manifest into both chunks
const LINK_TILE_MODEL_SIGNATURE_HEADING_TAGS = ['h2', 'h3', 'h4', 'h5', 'h6'];

const getComponentCss$G = (aspectRatio, weight, direction, hasDescription) => {
    const tileBaseStyles = getTileBaseStyles(aspectRatio);
    return getCss({
        ...tileBaseStyles,
        '@global': {
            ...tileBaseStyles['@global'],
            [LINK_TILE_MODEL_SIGNATURE_HEADING_TAGS.join(',')]: {
                margin: addImportantToRule(0),
            },
        },
        content: {
            ...tileBaseStyles.content,
            flexDirection: 'column',
            bottom: 0,
            padding: `${spacingFluidLarge} ${spacingFluidMedium} ${spacingFluidMedium}`,
            ...gradientToTopStyle,
        },
        signature: {
            position: 'absolute',
            top: spacingFluidMedium,
            left: spacingFluidMedium,
            right: spacingFluidMedium,
            display: 'flex',
        },
        heading: {
            margin: 0,
            ...textLargeStyle,
            hyphens: 'inherit',
            ...buildResponsiveStyles(weight, (w) => ({ fontWeight: getFontWeight(w) })),
        },
        ...(hasDescription && {
            description: {
                margin: '-12px 0 0 ', // TODO: perhaps gap should be overridden instead
                ...textSmallStyle,
                hyphens: 'inherit',
            },
        }),
        'link-group': {
            display: 'flex',
            width: '100%',
            gap: spacingFluidSmall,
            ...buildResponsiveStyles(direction, getGroupDirectionJssStyles),
        },
        'link-overlay': {
            // covers entire tile, used for expanded click-area only
            position: 'fixed',
            inset: 0,
        },
    });
};

const slottedAnchorSelector = `a[slot='${anchorSlot}']`;
const anchorJssStyle = {
    position: 'absolute',
    inset: 0,
    zIndex: 1, // necessary to be on top of img
    borderRadius: borderRadiusMedium,
};
const getMultilineEllipsis = (lineClamp) => {
    return {
        display: '-webkit-box',
        WebkitLineClamp: lineClamp,
        WebkitBoxOrient: 'vertical',
        overflow: 'hidden',
    };
};
const getComponentCss$F = (hasLikeButton, hasSlottedAnchor, hasPriceOriginal, hasDescription, aspectRatio, theme) => {
    const { primaryColor, contrastHighColor, contrastMediumColor, backgroundSurfaceColor } = getThemedColors(theme);
    const { primaryColor: primaryColorDark, contrastHighColor: contrastHighColorDark, contrastMediumColor: contrastMediumColorDark, backgroundSurfaceColor: backgroundSurfaceColorDark, } = getThemedColors('dark');
    return getCss({
        '@global': {
            ':host': {
                display: 'block',
                position: 'relative', // needed for ::slotted(a) to overlay correctly
                ...addImportantToEachRule({
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            [`slot[name="${headerSlot}"]`]: {
                display: 'block', // to ensure correct like button positioning when slot is unused
            },
            ...addImportantToEachRule({
                '::slotted': {
                    ...(hasSlottedAnchor && {
                        [`&(${slottedAnchorSelector})`]: {
                            ...anchorJssStyle,
                            textIndent: '-999999px', // hide anchor label visually but still usable for a11y (only works in RTL-mode because of `overflow: hidden;` parent)
                        },
                        ...getFocusJssStyle(theme, { slotted: slottedAnchorSelector }),
                    }),
                    [`&([slot="${headerSlot}"])`]: {
                        display: 'flex',
                        flexWrap: 'wrap',
                        gap: spacingFluidXSmall,
                    },
                    '&(img), &(picture)': {
                        display: 'block',
                        width: '100%',
                        height: '100%',
                        objectFit: 'cover',
                        borderRadius: borderRadiusLarge,
                        overflow: 'hidden', // needed for picture > img to have correct border-radius
                    },
                },
            }),
            ...(hasPriceOriginal && {
                s: {
                    color: contrastMediumColor,
                    ...prefersColorSchemeDarkMediaQuery(theme, {
                        color: contrastMediumColorDark,
                    }),
                },
            }),
        },
        root: {
            display: 'flex',
            flexDirection: 'column',
            aspectRatio: '3/4',
            overflow: 'hidden', // TODO: discussable if we should prevent text to overflow .root,  e.g. it also prevents a popover from being shown correctly
            boxSizing: 'border-box',
            borderRadius: borderRadiusMedium,
            padding: spacingFluidSmall,
            color: primaryColor,
            backgroundColor: backgroundSurfaceColor,
            ...buildResponsiveStyles(aspectRatio, (ratio) => ({
                aspectRatio: ratio.replace(':', '/'),
            })),
            ...prefersColorSchemeDarkMediaQuery(theme, {
                color: primaryColorDark,
                backgroundColor: backgroundSurfaceColorDark,
            }),
        },
        ...(!hasSlottedAnchor && {
            anchor: {
                ...anchorJssStyle,
                ...getFocusJssStyle(theme),
            },
        }),
        header: {
            display: 'flex',
            gap: spacingFluidSmall,
            justifyContent: 'space-between',
            alignItems: 'flex-start',
        },
        ...(hasLikeButton && {
            button: {
                position: 'relative',
                zIndex: 2, // Necessary to be on top of anchor link
            },
        }),
        image: {
            aspectRatio: '8/9',
            margin: `${spacingFluidSmall} auto ${spacingFluidXSmall}`,
            overflow: 'hidden',
            transition: getTransition('transform', 'moderate'),
            [getMediaQueryMin('s')]: {
                padding: `0 ${spacingFluidMedium}`, // ensures image is not getting to large
            },
            ...hoverMediaQuery({
                '.root:hover &': {
                    transform: 'scale3d(1.05,1.05,1.05)',
                },
            }),
        },
        wrapper: {
            display: 'flex',
            flexDirection: 'column',
            margin: 'auto',
            textAlign: 'center',
        },
        heading: {
            margin: '0 0 2px', // ua-style reset
            ...headingSmallStyle,
            ...fontHyphenationStyle,
            ...getMultilineEllipsis(3),
        },
        price: {
            margin: 0, // ua-style reset
            ...textXSmallStyle,
            ...(hasPriceOriginal && {
                display: 'flex',
                flexWrap: 'wrap',
                justifyContent: 'center',
                columnGap: spacingFluidXSmall,
            }),
        },
        ...(hasDescription && {
            description: {
                margin: 0, // ua-style reset
                ...textXXSmallStyle,
                ...getMultilineEllipsis(2),
                color: contrastHighColor,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    color: contrastHighColorDark,
                }),
            },
        }),
        ...(hasPriceOriginal && {
            'sr-only': getHiddenTextJssStyle(),
        }),
    });
};

const getComponentCss$E = (...args) => {
    return getCss({
        ...getButtonLinkTileStyles(...args),
        'link-overlay': {
            // covers entire tile, used for expanded click-area only
            position: 'fixed',
            inset: 0,
        },
    });
};

const baseSizes = {
    small: {
        width: '100px',
        height: '60px',
    },
    medium: {
        width: '120px',
        height: '72px',
    },
};
const getComponentCss$D = (size) => {
    return getCss({
        '@global': {
            ':host': {
                position: 'relative',
                display: 'inline-flex',
                verticalAlign: 'top',
                ...addImportantToEachRule({
                    outline: 0,
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            a: {
                display: 'block',
                textDecoration: 'none',
                outline: 0,
                '&::before': {
                    // needs to be defined always to have correct custom click area
                    content: '""',
                    position: 'absolute',
                    inset: 0,
                    borderRadius: '1px',
                },
                ...getFocusJssStyle('light', { pseudo: true }), // TODO: we need to support theme
            },
            picture: {
                display: 'block',
                ...(size === 'responsive'
                    ? {
                        ...baseSizes.small,
                        [getMediaQueryMin('l')]: baseSizes.medium,
                    }
                    : baseSizes[size]),
            },
            img: {
                display: 'block',
                width: '100%',
                height: 'auto',
            },
        },
    });
};

const cssVariableSpacingTop = '--p-modal-spacing-top';
const cssVariableSpacingBottom = '--p-modal-spacing-bottom';
const mediaQueryXl = getMediaQueryMin('xl');
const { primaryColor: darkThemePrimaryColor, contrastHighColor: darkThemeContrastHighColor } = getThemedColors('dark');
const stretchToFullModalWidthClassName = 'stretch-to-full-modal-width';
const marginTopBottomFallback = 'clamp(16px, 7vh, 192px)';
const marginTopBottomXlandXxlFallback = 'min(192px, 10vh)';
const footerShadowClass = 'footer--shadow';
const getFullscreenJssStyles = (fullscreen) => {
    return fullscreen
        ? {
            minWidth: '100%',
            maxWidth: 'none',
            minHeight: '100%',
            margin: 0,
            borderRadius: 0,
        }
        : {
            minWidth: '276px', // on viewport 320px: calc(${gridColumnWidthBase} * 6 + ${gridGap} * 5)
            maxWidth: '1535.5px', // on viewport 1920px: `calc(${gridColumnWidthXXL} * 14 + ${gridGap} * 13)`
            minHeight: 'auto',
            margin: `var(${cssVariableSpacingTop},${marginTopBottomFallback}) ${gridExtendedOffsetBase} var(${cssVariableSpacingBottom},${marginTopBottomFallback})`,
            borderRadius: borderRadiusMedium,
        };
};
const isFullscreenForXl = (fullscreen) => {
    const fullscreenParsed = parseJSON(fullscreen);
    if (typeof fullscreenParsed === 'boolean') {
        return fullscreenParsed;
    }
    else {
        const entries = Object.entries(fullscreenParsed);
        const [lastTrueBreakpoint] = entries.filter(([, val]) => val).pop() || [];
        const [lastFalseBreakpoint] = entries.filter(([, val]) => !val).pop() || [];
        return breakpoints.indexOf(lastTrueBreakpoint) > breakpoints.indexOf(lastFalseBreakpoint);
    }
};
const getSlottedJssStyle = (marginValue, hasHeader, hasDismissButton) => {
    const marginPx = `${-marginValue}px`;
    return {
        [`&(.${stretchToFullModalWidthClassName})`]: {
            width: `calc(100% + ${marginValue * 2}px)`,
            margin: `0 ${marginPx}`,
        },
        ...(!hasHeader && {
            [`&(.${stretchToFullModalWidthClassName}:first-child)`]: {
                marginTop: hasDismissButton ? `${-marginValue / 16}rem` : marginPx,
            },
        }),
        [`&(.${stretchToFullModalWidthClassName}:last-child)`]: {
            marginBottom: marginPx,
        },
    };
};
const getComponentCss$C = (isOpen, backdrop, isFullscreen, hasDismissButton, hasHeader, hasFooter, theme) => {
    const { primaryColor, backgroundColor } = getThemedColors(theme);
    const { primaryColor: primaryColorDark, backgroundColor: backgroundColorDark } = getThemedColors('dark');
    const isFullscreenForXlAndXxl = isFullscreenForXl(isFullscreen);
    const duration = isOpen ? 'moderate' : 'short';
    const easing = isOpen ? 'in' : 'out';
    const contentPadding = '32px';
    return getCss({
        '@global': {
            ':host': {
                overflowY: 'auto', // overrideable
                ...addImportantToEachRule({
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                    ...getBackdropJssStyle(isOpen, MODAL_Z_INDEX, theme, duration, backdrop),
                }),
            },
            '::slotted': addImportantToEachRule(mergeDeep(getSlottedJssStyle(32, hasHeader, hasDismissButton), buildResponsiveStyles(isFullscreen, (fullscreenValue) => ({
                [`&(.${stretchToFullModalWidthClassName}`]: {
                    '&:first-child)': {
                        borderRadius: fullscreenValue ? 0 : '8px 8px 0 0',
                    },
                    '&:last-child)': {
                        borderRadius: fullscreenValue ? 0 : '0 0 8px 8px',
                    },
                },
            })))),
            h2: {
                ...headingLargeStyle,
                margin: 0,
                color: primaryColor,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    color: primaryColorDark,
                }),
            },
        },
        'scroll-container': {
            display: 'flex',
            inset: 0, // TODO: is this still needed?
            height: '100%',
            overflowY: 'inherit',
            alignItems: 'center',
            justifyContent: 'center',
            flexWrap: 'wrap',
        },
        root: mergeDeep({
            color: primaryColor, // enables color inheritance for slotted content
            position: 'relative',
            boxSizing: 'border-box',
            transform: isOpen ? 'translateY(0%)' : 'translateY(25%)',
            opacity: isOpen ? 1 : 0,
            transition: `${getTransition('opacity', duration, easing)}, ${getTransition('transform', duration, easing)}`,
            paddingTop: hasDismissButton ? '2rem' : contentPadding, // rem value needed to prevent overlapping of close button and contents in scaling mode
            ...(!hasFooter && { paddingBottom: contentPadding }),
            background: backgroundColor,
            outline: isHighContrastMode ? '1px solid transparent' : 0,
            // TODO: getFocusJssStyle() can't be re-used atm, but as soon as component is refactored to `<dialog />` then no
            //  focus should be necessary at all because focus is auto forwarded to dismiss button.
            // ::after to be above sticky footer without z-index games
            '&:focus::after': {
                content: '""',
                position: 'fixed',
                border: `${borderWidthBase} solid`,
                pointerEvents: 'none', // fix text selection in focus state
                ...buildResponsiveStyles(isFullscreen, (fullscreenValue) => ({
                    borderRadius: fullscreenValue ? 0 : '12px',
                    borderColor: fullscreenValue ? primaryColor : darkThemePrimaryColor,
                    inset: fullscreenValue ? 0 : '-4px',
                    ...prefersColorSchemeDarkMediaQuery(theme, {
                        borderColor: darkThemePrimaryColor,
                    }),
                })),
            },
            '&:not(:focus-visible)::before': {
                border: 0,
            },
            [mediaQueryXl]: {
                margin: isFullscreenForXlAndXxl
                    ? 0
                    : `var(${cssVariableSpacingTop},${marginTopBottomXlandXxlFallback}) ${gridExtendedOffsetBase} var(${cssVariableSpacingBottom},${marginTopBottomXlandXxlFallback})`,
            },
            ...prefersColorSchemeDarkMediaQuery(theme, {
                color: primaryColorDark,
                background: backgroundColorDark,
            }),
        }, buildResponsiveStyles(isFullscreen, getFullscreenJssStyles) // potentially needs to be merged with mediaQueryXl
        ),
        ...(hasHeader && {
            header: {
                padding: `0 ${contentPadding} 8px`,
            },
        }),
        content: {
            ...(hasFooter && {
                position: 'relative', // to make sure content isn't above sticky footer, but might affect consumer's absolute positioning
                zIndex: 0,
            }),
            padding: `0 ${contentPadding}`,
        },
        ...(hasFooter && {
            footer: {
                position: 'sticky',
                background: backgroundColor,
                padding: contentPadding,
                bottom: 0,
                borderBottomLeftRadius: borderRadiusMedium,
                borderBottomRightRadius: borderRadiusMedium,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    background: backgroundColorDark,
                }),
            },
            [footerShadowClass]: {
                boxShadow: `${isThemeDark(theme) ? scrollShadowColorDark : scrollShadowColor} 0 -5px 10px`,
                clipPath: 'inset(-20px 0 0 0)', // crop leaking box-shadow on left and right side
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    boxShadow: `${scrollShadowColorDark} 0 -5px 10px`,
                }),
            },
        }),
        ...(hasDismissButton && {
            controls: {
                position: 'absolute',
                top: '8px',
                right: '8px',
                left: '8px',
                display: 'flex',
                justifyContent: 'flex-end',
                zIndex: 1, // To assure controls are on top when using stretchToFullModalWidthClassName and transformed slotted content
            },
            dismiss: {
                border: `2px solid ${backgroundColor}`, // needed to enlarge button slightly without affecting the hover area (are equal now).
                borderRadius: '4px',
                background: backgroundColor,
                ...hoverMediaQuery({
                    '&:hover': {
                        background: darkThemeContrastHighColor,
                        borderColor: darkThemeContrastHighColor,
                    },
                }),
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    background: backgroundColorDark,
                    borderColor: backgroundColorDark,
                }),
            },
        }),
    });
};

const modelSignatureHeight = 36;

const colorToFilterLight = {
    primary: filterLightPrimary,
    'contrast-low': filterLightContrastLow,
    'contrast-medium': filterLightContrastMedium,
    'contrast-high': filterLightContrastHigh,
};
const colorToFilterDark = {
    primary: filterDarkPrimary,
    'contrast-low': filterDarkContrastLow,
    'contrast-medium': filterDarkContrastMedium,
    'contrast-high': filterDarkContrastHigh,
};
const colorToFilterMap = {
    auto: colorToFilterLight,
    light: colorToFilterLight,
    dark: colorToFilterDark,
};
const getComponentCss$B = (size, color, theme) => {
    const isSizeInherit = size === 'inherit';
    const isColorInherit = color === 'inherit';
    return getCss({
        '@global': {
            ':host': {
                display: 'inline-block',
                verticalAlign: 'top',
                ...addImportantToEachRule({
                    maxWidth: '100%',
                    maxHeight: '100%',
                    ...(!isSizeInherit && {
                        width: 'inherit',
                        height: 'inherit',
                        // TODO: we need a width map of all signatures to ensure same fluid behavior like implemented fro crest + wordmark
                        maxHeight: `${modelSignatureHeight}px`,
                    }),
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            img: {
                display: 'block',
                maxWidth: '100%',
                maxHeight: '100%',
                pointerEvents: 'none', // prevents image drag
                ...(!isColorInherit && {
                    filter: colorToFilterMap[theme][color],
                    ...prefersColorSchemeDarkMediaQuery(theme, {
                        filter: colorToFilterMap.dark[color],
                    }),
                    ...(isHighContrastMode &&
                        getSchemedHighContrastMediaQuery({
                            filter: colorToFilterMap.light[color],
                        }, {
                            filter: colorToFilterMap.dark[color],
                        })),
                }),
                ...(isSizeInherit && { height: size }),
            },
        },
    });
};

const getComponentCss$A = (theme) => {
    const { primaryColor, contrastHighColor, backgroundSurfaceColor, disabledColor, contrastLowColor } = getThemedColors(theme);
    const { primaryColor: primaryColorDark, disabledColor: disabledColorDark, contrastHighColor: contrastHighColorDark, backgroundSurfaceColor: backgroundSurfaceColorDark, contrastLowColor: contrastLowColorDark, } = getThemedColors('dark');
    const { highlightColor } = getHighContrastColors();
    return getCss({
        '@global': {
            ':host': addImportantToEachRule({
                scrollMarginTop: spacingStaticSmall, // Creates top margin when navigating with keyboard and list is scrolled automatically
                ...hostHiddenStyles,
            }),
        },
        option: {
            display: 'flex',
            justifyContent: 'space-between',
            gap: '12px',
            padding: `${spacingStaticSmall} 12px`,
            flex: `1 0 calc(${fontLineHeight} + ${spacingStaticSmall} * 2)`,
            color: contrastHighColor,
            ...prefersColorSchemeDarkMediaQuery(theme, {
                color: contrastHighColorDark,
            }),
            cursor: 'pointer',
            textAlign: 'start',
            wordBreak: 'break-word',
            boxSizing: 'border-box',
            borderRadius: borderRadiusSmall,
            transition: `${getTransition('background-color')}, ${getTransition('color')}`,
            ...getNoResultsOptionJssStyle(),
            ...hoverMediaQuery({
                '&:not([aria-disabled]):not(.option--disabled):not([role=status]):hover': {
                    color: isHighContrastMode ? highlightColor : primaryColor,
                    background: contrastLowColor,
                    ...prefersColorSchemeDarkMediaQuery(theme, {
                        color: isHighContrastMode ? highlightColor : primaryColorDark,
                        background: contrastLowColorDark,
                    }),
                },
            }),
            '&--selected': {
                background: backgroundSurfaceColor,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    background: backgroundSurfaceColorDark,
                }),
            },
            '&--highlighted': {
                background: contrastLowColor,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    background: contrastLowColorDark,
                }),
            },
            '&--highlighted, &--selected': {
                color: isHighContrastMode ? highlightColor : primaryColor,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    color: isHighContrastMode ? highlightColor : primaryColorDark,
                }),
            },
            '&--disabled': {
                cursor: 'not-allowed',
                color: disabledColor,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    color: disabledColorDark,
                }),
            },
            '&--hidden': {
                display: 'none',
            },
        },
        checkbox: {
            pointerEvents: 'none', // Avoid checkbox label click which updates input within p-checkbox-wrapper
        },
    });
};

/**
 * Generates placeholder styles for an input element.
 *
 * @param {JssStyle} styles - The styles to apply to the placeholder.
 * @returns {JssStyle} - The generated placeholder styles.
 */
const getPlaceholderJssStyle = (styles) => ({
    '&::placeholder': styles,
    '&::-webkit-input-placeholder': styles /* Chrome/Opera/Safari */,
    '&::-moz-placeholder': styles /* Firefox 19+ */,
    '&:-moz-placeholder': styles /* Firefox 18- */,
});

// Used for elements that must overflow `overflow:hidden` containers, are positioned absolute and wrapped within a native `popover` element.
const getPopoverResetJssStyle = () => {
    return {
        position: 'absolute',
        border: 'none',
        background: 'none',
        pointerEvents: 'all',
        padding: 0,
        margin: 0,
        overflow: 'initial',
        '&:-internal-popover-in-top-layer::backdrop': {
            display: 'none',
        },
    };
};

const getSlottedTextFieldTextareaSelectStyles = (child, state, isLoading, theme, additionalDefaultJssStyle) => {
    const { primaryColor, contrastLowColor, contrastMediumColor, disabledColor } = getThemedColors(theme);
    const { primaryColor: primaryColorDark, contrastLowColor: contrastLowColorDark, contrastMediumColor: contrastMediumColorDark, disabledColor: disabledColorDark, } = getThemedColors('dark');
    const { formStateColor, formStateHoverColor } = getThemedFormStateColors(theme, state);
    const { formStateColor: formStateColorDark, formStateHoverColor: formStateHoverColorDark } = getThemedFormStateColors('dark', state);
    return {
        [`::slotted(${child})`]: {
            display: 'block',
            width: '100%',
            height: child !== 'textarea'
                ? `calc(${fontLineHeight} + 10px + ${borderWidthBase} * 2 + ${spacingStaticSmall} * 2)` // we need 10px additionally so input height becomes 54px
                : 'auto',
            margin: 0,
            outline: 0,
            WebkitAppearance: 'none', // iOS safari
            appearance: 'none',
            boxSizing: 'border-box',
            border: `${borderWidthBase} solid ${formStateColor || contrastMediumColor}`,
            borderRadius: borderRadiusSmall,
            background: 'transparent',
            font: textSmallStyle.font.replace('ex', 'ex + 6px'), // a minimum line-height is needed for input, otherwise value is scrollable in Chrome, +6px is aligned with how Safari visualize date/time input highlighting
            textIndent: 0,
            color: primaryColor,
            transition: `${getTransition('background-color')}, ${getTransition('border-color')}, ${getTransition('color')}`, // for smooth transitions between e.g. disabled states
            ...prefersColorSchemeDarkMediaQuery(theme, {
                borderColor: formStateColorDark || contrastMediumColorDark,
                color: primaryColorDark,
            }),
            ...additionalDefaultJssStyle,
        },
        ...(!isLoading &&
            hoverMediaQuery({
                // with the media query the selector has higher priority and overrides disabled styles
                [`::slotted(${child}:not(:disabled):not(:focus):not([readonly]):hover),label:hover~.wrapper ::slotted(${child}:not(:disabled):not(:focus):not([readonly]))${child === 'select' ? ',label:hover~.wrapper ::part(select-wrapper-dropdown)' : ''}`]: {
                    borderColor: formStateHoverColor || primaryColor,
                    ...prefersColorSchemeDarkMediaQuery(theme, {
                        borderColor: formStateHoverColorDark || primaryColorDark,
                    }),
                },
            })),
        // TODO: getFocusJssStyle() can't be re-used because focus style differs for form elements
        [`::slotted(${child}:focus)`]: {
            borderColor: primaryColor,
            ...prefersColorSchemeDarkMediaQuery(theme, {
                borderColor: primaryColorDark,
            }),
        },
        [`::slotted(${child}:disabled)`]: {
            cursor: 'not-allowed',
            color: disabledColor,
            borderColor: disabledColor,
            WebkitTextFillColor: disabledColor,
            ...prefersColorSchemeDarkMediaQuery(theme, {
                color: disabledColorDark,
                borderColor: disabledColorDark,
                WebkitTextFillColor: disabledColorDark,
            }),
        },
        ...(child !== 'select' && {
            [`::slotted(${child}[readonly])`]: {
                borderColor: contrastLowColor,
                background: contrastLowColor,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    borderColor: contrastLowColorDark,
                    background: contrastLowColorDark,
                }),
            },
        }),
    };
};
const formElementLayeredGap = '9px'; // to have same distance vertically and horizontally for e.g. button/icon within form element
const formElementLayeredSafeZone = `calc(${formElementLayeredGap} + ${borderWidthBase})`;
// TODO: basic button/icon padding can already be set within style function instead of on component style level
const formButtonOrIconPadding = spacingStaticXSmall;
// TODO: if we'd use 12px instead, it wouldn't be necessary for textarea to have a custom vertical padding,
//  unfortunately line-height alignment breaks for a select element for some reasons then
// TODO: basic form element padding can already be set within style function instead of on component style level
const formElementPaddingVertical = spacingStaticSmall;
// TODO: basic form element padding can already be set within style function instead of on component style level
const formElementPaddingHorizontal = spacingStaticMedium;
const getCalculatedFormElementPaddingHorizontal = (buttonOrIconAmount) => {
    // when applied, font-family and font-size needs to be set too for correct calculation of ex-unit ($fontLineHeight)
    return `calc(${formElementLayeredGap} + ${formElementPaddingHorizontal} / 2 + (${fontLineHeight} + ${formButtonOrIconPadding} * 2) * ${buttonOrIconAmount})`;
};
// TODO: re-use in textarea-wrapper not only in text-field-wrapper
const getUnitCounterJssStyle = (isDisabled, theme) => {
    const { disabledColor, contrastMediumColor } = getThemedColors(theme);
    const { disabledColor: disabledColorDark, contrastMediumColor: contrastMediumColorDark } = getThemedColors('dark');
    return {
        pointerEvents: 'none',
        maxWidth: '100%',
        boxSizing: 'border-box',
        whiteSpace: 'nowrap',
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        font: textSmallStyle.font,
        color: contrastMediumColor,
        ...prefersColorSchemeDarkMediaQuery(theme, {
            color: contrastMediumColorDark,
        }),
        ...(isDisabled && {
            color: disabledColor,
            ...prefersColorSchemeDarkMediaQuery(theme, {
                color: disabledColorDark,
            }),
        }),
    };
};

const INTERNAL_MULTI_SELECT_SLOT = 'internal-select';

const getComponentCss$z = (direction, isOpen, isDisabled, hideLabel, state, isWithinForm, isNativePopoverCase, theme) => {
    const { contrastHighColor } = getThemedColors(theme);
    const { contrastHighColor: contrastHighColorDark } = getThemedColors('dark');
    return getCss({
        '@global': {
            ':host': {
                display: 'block',
                ...addImportantToEachRule({
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            ...(isWithinForm &&
                addImportantToEachRule({
                    [`::slotted([slot=${INTERNAL_MULTI_SELECT_SLOT}])`]: {
                        position: 'absolute',
                        opacity: 0,
                        height: '0px',
                        bottom: 0,
                    },
                })),
            // TODO: re-use select-wrapper-style
            input: getInputStyles(isDisabled, direction, isOpen, state, theme),
        },
        root: {
            display: 'grid',
            gap: spacingStaticXSmall,
            ...(isWithinForm && {
                position: 'relative', // Necessary for native HTML validation box positioning (internal-select)
            }),
        },
        wrapper: {
            position: 'relative',
            display: 'grid',
            gridTemplateColumns: `minmax(0, 1fr) auto auto ${formElementLayeredSafeZone}`,
        },
        // TODO: extract for multi-select, select-wrapper and text-field (not gridArea and placeSelf)
        icon: {
            gridArea: '1/3',
            placeSelf: 'center',
            padding: formButtonOrIconPadding,
            pointerEvents: 'none',
            transform: 'rotate3d(0,0,1,0.0001deg)', // needs to be a little more than 0 for correct direction in safari
            transition: getTransition('transform'),
            '&--rotate': {
                transform: 'rotate3d(0,0,1,180deg)',
            },
        },
        // TODO: extract for multi-select, select-wrapper and text-field (not gridArea and placeSelf)
        button: {
            gridArea: '1/2',
            placeSelf: 'center',
            padding: formButtonOrIconPadding,
        },
        listbox: getListStyles$2(isOpen, direction, theme),
        // TODO: extract (maybe even as functional component) and re-use in multi-select and select-wrapper
        'no-results': {
            padding: `${spacingStaticSmall} 12px`,
            boxSizing: 'border-box',
            color: contrastHighColor,
            ...prefersColorSchemeDarkMediaQuery(theme, {
                color: contrastHighColorDark,
            }),
            ...getNoResultsOptionJssStyle(),
        },
        // TODO: maybe we should extract it as functional component too
        'sr-only': getHiddenTextJssStyle(),
        // .label / .required
        ...getFunctionalComponentLabelStyles(isDisabled, hideLabel, theme),
        // .message
        ...getFunctionalComponentStateMessageStyles(theme, state),
        ...(isNativePopoverCase && {
            popover: {
                ...getPopoverResetJssStyle(),
            },
        }),
    });
};
// TODO: use getSlottedTextFieldTextareaSelectStyles() instead an manipulate selectors like done with PIN Code or even better make it configurable as parameter
const getInputStyles = (isDisabled, direction, isOpen, state, theme) => {
    const isDirectionDown = direction === 'down';
    const { primaryColor, disabledColor, backgroundColor, contrastMediumColor } = getThemedColors(theme);
    const { primaryColor: primaryColorDark, disabledColor: disabledColorDark, backgroundColor: backgroundColorDark, contrastMediumColor: contrastMediumColorDark, } = getThemedColors('dark');
    const { formStateColor, formStateHoverColor } = getThemedFormStateColors(theme, state);
    const { formStateColor: formStateColorDark, formStateHoverColor: formStateHoverColorDark } = getThemedFormStateColors('dark', state);
    return {
        gridArea: '1/1/1/-1',
        flex: 1,
        minWidth: 0,
        // TODO: abstract and re-use for multi-select, select-wrapper and text-field-wrapper
        height: `calc(${fontLineHeight} + 10px + ${borderWidthBase} * 2 + ${spacingStaticSmall} * 2)`, // we need 10px additionally so input height becomes 54px, // we need 6px additionally so input height becomes 50px
        font: textSmallStyle.font.replace('ex', 'ex + 6px'), // a minimum line-height is needed for input, otherwise value is scrollable in Chrome, +6px is alig
        margin: 0, // necessary reset for iOS Safari 15 (and maybe other browsers)
        padding: `${formElementPaddingVertical} ${formElementPaddingHorizontal}`,
        paddingInlineEnd: getCalculatedFormElementPaddingHorizontal(2),
        boxSizing: 'border-box',
        outline: 0,
        WebkitAppearance: 'none', // iOS safari
        appearance: 'none',
        ...textSmallStyle,
        textOverflow: 'ellipsis',
        '&:disabled': {
            cursor: 'not-allowed',
        },
        transition: `${getTransition('background-color')}, ${getTransition('border-color')}, ${getTransition('color')}`, // for smooth transitions between e.g. disabled states
        color: primaryColor,
        '&:not(:focus)': {
            ...getPlaceholderJssStyle({ color: primaryColor, opacity: 1 }),
            ...prefersColorSchemeDarkMediaQuery(theme, getPlaceholderJssStyle({ color: primaryColorDark, opacity: 1 })),
        }, // Opacity fixes placeholder being shown lighter in firefox
        ...hoverMediaQuery({
            '&:hover:not(:disabled):not(:focus),label:hover~.wrapper &:not(:disabled):not(:focus)': {
                borderColor: isOpen ? primaryColor : formStateHoverColor || primaryColor,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    borderColor: isOpen ? primaryColorDark : formStateHoverColorDark || primaryColorDark,
                }),
            },
        }),
        ...(!isDisabled && {
            // TODO: getFocusJssStyle() can't be re-used because focus style differs for form elements
            '&:focus': {
                borderColor: primaryColor,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    borderColor: primaryColorDark,
                }),
            },
        }),
        background: backgroundColor,
        border: `${borderWidthBase} solid ${isOpen ? primaryColor : formStateColor || contrastMediumColor}`,
        borderRadius: borderRadiusSmall,
        ...(isOpen && {
            [isDirectionDown ? 'paddingBottom' : 'paddingTop']: `calc(${formElementPaddingVertical} + 1px)`, // Add padding to keep same height when border changes
            [isDirectionDown ? 'borderBottom' : 'borderTop']: addImportantToRule(`1px solid ${contrastMediumColor}`),
            [isDirectionDown ? 'borderBottomLeftRadius' : 'borderTopLeftRadius']: 0,
            [isDirectionDown ? 'borderBottomRightRadius' : 'borderTopRightRadius']: 0,
        }),
        ...(isDisabled && {
            ...getPlaceholderJssStyle({ color: disabledColor }),
            cursor: 'not-allowed',
            color: disabledColor,
            borderColor: disabledColor,
            WebkitTextFillColor: disabledColor,
        }),
        ...prefersColorSchemeDarkMediaQuery(theme, {
            color: primaryColorDark,
            background: backgroundColorDark,
            border: `${borderWidthBase} solid ${isOpen ? primaryColorDark : formStateColorDark || contrastMediumColorDark}`,
            ...(isOpen && {
                [isDirectionDown ? 'borderBottom' : 'borderTop']: addImportantToRule(`1px solid ${contrastMediumColorDark}`),
            }),
            ...(isDisabled && {
                ...getPlaceholderJssStyle({ color: disabledColorDark }),
                color: disabledColorDark,
                borderColor: disabledColorDark,
                WebkitTextFillColor: disabledColorDark,
            }),
        }),
    };
};
const getListStyles$2 = (isOpen, direction, theme) => {
    const isDirectionDown = direction === 'down';
    const { primaryColor, backgroundColor } = getThemedColors(theme);
    const { primaryColor: primaryColorDark, backgroundColor: backgroundColorDark } = getThemedColors('dark');
    return {
        position: 'absolute',
        margin: 0,
        display: isOpen ? 'flex' : 'none',
        flexDirection: 'column',
        gap: spacingStaticSmall,
        padding: '6px',
        ...textSmallStyle,
        zIndex: 10,
        left: 0,
        right: 0,
        [isDirectionDown ? 'top' : 'bottom']: '100%',
        boxSizing: 'border-box',
        maxHeight: `${8.5 * (MULTI_SELECT_OPTION_HEIGHT + 8) + 6 + 2}px`, // 8.5 options * option height + 8px gap + additional spacing (6px = padding, 2px = border)
        overflowY: 'auto',
        WebkitOverflowScrolling: 'touch',
        background: backgroundColor,
        border: `2px solid ${primaryColor}`,
        [isDirectionDown ? 'borderTop' : 'borderBottom']: 'none',
        borderRadius: borderRadiusSmall,
        [isDirectionDown ? 'borderTopLeftRadius' : 'borderBottomLeftRadius']: 0,
        [isDirectionDown ? 'borderTopRightRadius' : 'borderBottomRightRadius']: 0,
        scrollbarWidth: 'thin', // firefox
        scrollbarColor: 'auto', // firefox
        transition: getTransition('border-color'),
        transform: 'translate3d(0,0,0)', // fix iOS bug if less than 5 items are displayed
        ...prefersColorSchemeDarkMediaQuery(theme, {
            background: backgroundColorDark,
            borderColor: primaryColorDark,
        }),
    };
};

const mediaQueryMinS = getMediaQueryMin('s');
const mediaQueryMaxS = getMediaQueryMax('s');
// button size needs to be fluid between 320px and 360px viewport width, so that the pagination fits into 320px viewport
// and text scale 200% works (almost) on mobile viewports too
const buttonSize = `clamp(36px, calc(${fontLineHeight} + 10vw - 20px), 40px)`;
const disabledCursorStyle = {
    cursor: 'default',
    pointerEvents: 'none', // prevents :hover (has no effect when forced), maybe we can remove it since CSS selectors already cover desired behavior
};
const hiddenStyle = { display: 'none' };
const getComponentCss$y = (activePage, pageTotal, showLastPage, theme) => {
    const { primaryColor, disabledColor, hoverColor } = getThemedColors(theme);
    const { primaryColor: primaryColorDark, disabledColor: disabledColorDark, hoverColor: hoverColorDark, } = getThemedColors('dark');
    return getCss({
        '@global': {
            ':host': {
                display: 'block',
                ...addImportantToEachRule({
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            nav: {
                display: 'flex',
                justifyContent: 'center',
                userSelect: 'none',
            },
            ul: {
                display: 'flex',
                gap: spacingStaticXSmall,
                margin: 0,
                padding: 0,
                [mediaQueryMinS]: {
                    gap: spacingStaticSmall,
                },
            },
            li: {
                listStyleType: 'none',
                ...(pageTotal > 5 && {
                    // max 5 items including ellipsis at the same time on mobile
                    [mediaQueryMaxS]: {
                        [activePage < 4
                            ? // we are at the start, so let's hide start ellipsis and 2 items before end ellipsis
                                '&.ellip-start,&:nth-child(6),&:nth-child(7),&:not(.ellip):nth-child(8)'
                            : pageTotal - activePage < 3
                                ? // we are at the end, so let's hide end ellipsis and 2 items after start ellipsis
                                    '&.ellip-end, &.ellip-start + &:not(.current), &.ellip-start + &:not(.current) + &:not(.current)'
                                : // we are at in the middle, so let's hide elements after start and before end ellipsis
                                    '&.ellip-start + &:not(.current), &.current-1, &.current\\+1, &.current\\+1 + &:not(.ellip)']: hiddenStyle,
                        // without last page we need to adjust end page handling
                        ...(!showLastPage &&
                            (pageTotal - activePage < 2
                                ? { [`&.current-2${pageTotal - activePage === 1 ? ',&.current-1' : ''}`]: hiddenStyle }
                                : activePage > 2 && {
                                    '&.current\\+1,&.current\\+2': hiddenStyle,
                                    '&.ellip-end': { display: 'initial' },
                                })),
                    },
                }),
                [mediaQueryMinS]: {
                    // prev
                    '&:first-child': { marginInlineEnd: spacingStaticSmall },
                    // next
                    '&:last-child': { marginInlineStart: spacingStaticSmall },
                    ...(pageTotal < 8
                        ? { '&.ellip': hiddenStyle }
                        : // max 7 items including ellipsis at the same time on tablet
                            {
                                // we are at the start, so let's hide start ellipsis
                                ...(activePage <= 4 && { '&.ellip-start': hiddenStyle }),
                                // we are at the end, so let's hide end ellipsis
                                ...(pageTotal - activePage < 4 && { '&.ellip-end:nth-last-child(3)': hiddenStyle }),
                                // we are at the end without last page, so let's hide end ellipsis
                                ...(pageTotal - activePage < 3 && { '&.ellip-end:nth-last-child(2)': hiddenStyle }),
                            }),
                },
            },
            span: {
                display: 'flex',
                justifyContent: 'center',
                alignItems: 'center',
                transition: `${getTransition('background-color')}, ${getTransition('border-color')}, ${getTransition('color')}`, // for smooth transition between states
                position: 'relative',
                width: buttonSize,
                height: buttonSize,
                boxSizing: 'border-box',
                ...textSmallStyle,
                whiteSpace: 'nowrap',
                cursor: 'pointer',
                color: primaryColor,
                borderRadius: borderRadiusSmall,
                borderColor: 'transparent', // default value is needed for smooth transition
                outline: 0, // TODO: only relevant for VRT testing with forced states - prevents :focus style
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    color: primaryColorDark,
                }),
                ...hoverMediaQuery({
                    '&:not([aria-disabled]):not(.ellipsis):hover': {
                        ...frostedGlassStyle,
                        background: hoverColor,
                        ...prefersColorSchemeDarkMediaQuery(theme, {
                            background: hoverColorDark,
                        }),
                    },
                }),
                '&[aria-current]': {
                    ...disabledCursorStyle,
                    color: primaryColor,
                    border: `${borderWidthBase} solid ${primaryColor}`,
                    ...prefersColorSchemeDarkMediaQuery(theme, {
                        color: primaryColorDark,
                        borderColor: primaryColorDark,
                    }),
                },
                '&[aria-disabled]': {
                    ...disabledCursorStyle,
                    color: disabledColor,
                    ...prefersColorSchemeDarkMediaQuery(theme, {
                        color: disabledColorDark,
                    }),
                },
                // TODO :not(.ellipsis) is only needed for VRT states tests to work properly
                '&:not(.ellipsis)': getFocusJssStyle(theme),
            },
        },
        ellipsis: {
            ...disabledCursorStyle,
            '&::after': {
                content: '""',
            },
        },
    });
};

const removeSlottedSelector = (styles) => Object.fromEntries(Object.entries(styles).map(([key, value]) => {
    value = typeof value === 'object' ? removeSlottedSelector(value) : value;
    return [key.replace(/::slotted\(([^,]+)\)/g, '$1'), value];
}));
const removeStyles = (selector, styles) => Object.fromEntries(Object.entries(styles)
    .filter(([key]) => key !== selector)
    .map(([key, value]) => {
    value = typeof value === 'object' ? removeStyles(selector, value) : value;
    return [key, value];
}));

const getComponentCss$x = (hideLabel, state, isDisabled, isLoading, isWithinForm, length, theme) => {
    const inputSize = `calc(${fontLineHeight} + 10px + ${borderWidthBase} * 2 + ${spacingStaticSmall} * 2)`; // equivalent to calculation of input height within form-styles
    const inputStyles = removeStyles('input[readonly]', removeSlottedSelector(getSlottedTextFieldTextareaSelectStyles('input', state, isLoading, theme, {
        // TODO: move into getSlottedTextFieldTextareaSelectStyles()
        padding: `${formElementPaddingVertical} ${spacingStaticXSmall}`,
        // TODO: move into getSlottedTextFieldTextareaSelectStyles() via parameter, e.g. textAlign=center|start
        textAlign: 'center',
        // TODO: move into getSlottedTextFieldTextareaSelectStyles() via parameter, e.g. size=max|min
        width: inputSize,
        ...(length > 4 && {
            [getMediaQueryMax('xs')]: {
                // TODO: instead of having dedicated css rules depending on length we should try to implement a fluid one fits all solution
                width: `calc((276px - (${spacingStaticSmall} * ${length - 1})) / ${length})`, // calculate the max with of the inputs that fit into grid in viewport base (276px)
            },
        }),
        // TODO: move into getSlottedTextFieldTextareaSelectStyles() via parameter, e.g. isLoading
        ...(isLoading && {
            opacity: 0.2, // TODO: not in sync with e.g. checkbox/radio-button loading style
            cursor: 'not-allowed',
        }),
        // since @playwright/test@1.40.1 this does not work anymore in Webkit browser engine for unknown reasons
        /* ...Object.fromEntries(
          Array.from(Array(length)).map((_, i) => {
            return [`&:nth-of-type(${i + 1})`, { gridArea: `1/${i + 1}` }];
          })
        ),*/
        '&:nth-of-type(1)': { gridArea: '1/1' },
        '&:nth-of-type(2)': { gridArea: '1/2' },
        '&:nth-of-type(3)': { gridArea: '1/3' },
        '&:nth-of-type(4)': { gridArea: '1/4' },
        '&:nth-of-type(5)': { gridArea: '1/5' },
        '&:nth-of-type(6)': { gridArea: '1/6' },
    })));
    return getCss({
        '@global': {
            ':host': {
                display: 'block',
                ...addImportantToEachRule({
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            // input
            ...inputStyles,
            ...(isWithinForm &&
                addImportantToEachRule({
                    '::slotted([slot=internal-input])': {
                        position: 'absolute',
                        height: inputSize,
                        width: 0,
                        opacity: 0,
                    },
                })),
        },
        root: {
            display: 'grid',
            gap: spacingStaticXSmall,
        },
        wrapper: {
            display: 'grid',
            gridTemplateColumns: `repeat(${length}, minmax(0, 1fr))`,
            justifySelf: 'flex-start',
            gap: spacingStaticSmall,
        },
        ...(isLoading && {
            spinner: {
                gridArea: '1/1/1/-1',
                placeSelf: 'center',
                width: inputSize,
                height: inputSize,
                pointerEvents: 'none',
            },
        }),
        // .label / .required
        ...getFunctionalComponentLabelStyles(isDisabled, hideLabel, theme),
        // .message
        ...getFunctionalComponentStateMessageStyles(theme, state),
        // .loading
        ...getFunctionalComponentLoadingMessageStyles(),
    });
};

const safeZonePx = 16;

const { canvasColor, canvasTextColor } = getHighContrastColors();
const directionPositionMap = {
    top: {
        bottom: '100%',
        left: '50%',
        transform: 'translate3d(-50%, 0, 0)', // translate3d used to fix Safari shadow bug
    },
    right: {
        top: '50%',
        left: '100%',
        transform: 'translate3d(0, -50%, 0)',
    },
    bottom: {
        top: '100%',
        left: '50%',
        transform: 'translate3d(-50%, 0, 0)',
    },
    left: {
        top: '50%',
        right: '100%',
        transform: 'translate3d(0, -50%, 0)',
    },
};
const borderWidth = '12px';
const transparentColor = 'transparent';
const join = (...arr) => arr.join(' ');
const getDirectionArrowMap = (theme) => {
    const { backgroundColor, backgroundSurfaceColor } = getThemedColors(theme);
    const { backgroundSurfaceColor: backgroundSurfaceColorDark } = getThemedColors('dark');
    const isDark = isThemeDark(theme);
    return {
        top: {
            top: 0,
            left: '50%',
            transform: 'translateX(-50%)',
            borderWidth: join(borderWidth, borderWidth, 0),
            ...(isHighContrastMode
                ? {
                    borderColor: join(canvasTextColor, canvasColor, canvasColor),
                }
                : {
                    borderColor: join(isDark ? backgroundSurfaceColor : backgroundColor, transparentColor, transparentColor),
                    ...prefersColorSchemeDarkMediaQuery(theme, {
                        borderColor: join(backgroundSurfaceColorDark, transparentColor, transparentColor),
                    }),
                }),
        },
        right: {
            top: '50%',
            right: 0,
            transform: 'translateY(-50%)',
            borderWidth: join(borderWidth, borderWidth, borderWidth, 0),
            ...(isHighContrastMode
                ? {
                    borderColor: join(canvasColor, canvasTextColor, canvasColor, canvasColor),
                }
                : {
                    borderColor: join(transparentColor, isDark ? backgroundSurfaceColor : backgroundColor, transparentColor, transparentColor),
                    ...prefersColorSchemeDarkMediaQuery(theme, {
                        borderColor: join(transparentColor, backgroundSurfaceColorDark, transparentColor, transparentColor),
                    }),
                }),
        },
        bottom: {
            bottom: 0,
            left: '50%',
            transform: 'translateX(-50%)',
            borderWidth: join(0, borderWidth, borderWidth),
            ...(isHighContrastMode
                ? {
                    borderColor: join(canvasColor, canvasColor, canvasTextColor),
                }
                : {
                    borderColor: join(transparentColor, transparentColor, isDark ? backgroundSurfaceColor : backgroundColor),
                    ...prefersColorSchemeDarkMediaQuery(theme, {
                        borderColor: join(transparentColor, transparentColor, backgroundSurfaceColorDark),
                    }),
                }),
        },
        left: {
            top: '50%',
            left: 0,
            transform: 'translateY(-50%)',
            borderWidth: join(borderWidth, 0, borderWidth, borderWidth),
            ...(isHighContrastMode
                ? {
                    borderColor: join(canvasColor, canvasColor, canvasColor, canvasTextColor),
                }
                : {
                    borderColor: join(transparentColor, transparentColor, transparentColor, isDark ? backgroundSurfaceColor : backgroundColor),
                    ...prefersColorSchemeDarkMediaQuery(theme, {
                        borderColor: join(transparentColor, transparentColor, transparentColor, backgroundSurfaceColorDark),
                    }),
                }),
        },
    };
};
const getComponentCss$w = (direction, isNativePopoverCase, theme) => {
    const { hoverColor, backgroundColor, primaryColor, backgroundSurfaceColor } = getThemedColors(theme);
    const { hoverColor: hoverColorDark, primaryColor: primaryColorDark, backgroundSurfaceColor: backgroundSurfaceColorDark, } = getThemedColors('dark');
    const shadowColor = 'rgba(0,0,0,0.3)';
    return getCss({
        '@global': {
            ':host': {
                display: 'inline-block',
                verticalAlign: 'top',
                ...addImportantToEachRule({
                    position: 'relative',
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            p: {
                ...textSmallStyle,
                margin: 0,
            },
            button: {
                display: 'block',
                WebkitAppearance: 'none', // iOS safari
                appearance: 'none',
                background: 'transparent',
                border: 0,
                padding: 0,
                cursor: 'pointer',
                ...textSmallStyle,
                width: fontLineHeight, // width needed to improve ssr support
                height: fontLineHeight, // height needed to improve ssr support
                borderRadius: '50%',
                // TODO: we should try to use getHoverStyle()
                ...hoverMediaQuery({
                    transition: getTransition('background-color'),
                    '&:hover': {
                        ...frostedGlassStyle,
                        backgroundColor: hoverColor,
                        ...prefersColorSchemeDarkMediaQuery(theme, {
                            backgroundColor: hoverColorDark,
                        }),
                    },
                }),
                ...getFocusJssStyle(theme, { offset: 0 }),
            },
        },
        label: getHiddenTextJssStyle(),
        icon: {
            transform: 'translate3d(0,0,0)', // Fixes movement on hover in Safari
        },
        spacer: {
            ...(isNativePopoverCase
                ? {
                    ...getPopoverResetJssStyle(),
                }
                : {
                    inset: `${-safeZonePx}px`,
                }),
            position: 'absolute',
            zIndex: POPOVER_Z_INDEX,
            filter: `drop-shadow(0 0 16px ${shadowColor})`,
            backdropFilter: 'drop-shadow(0px 0px 0px transparent)', // fixes issues with Chrome >= 105 where filter: drop-shadow is not applied correctly after animation ends
            pointerEvents: 'none',
            animation: `${motionDurationShort} $fadeIn ${motionEasingBase} forwards`
                ,
            '&::before': {
                content: '""',
                position: 'absolute',
                borderStyle: 'solid',
                ...getDirectionArrowMap(theme)[direction],
            },
            ...prefersColorSchemeDarkMediaQuery(theme, {
                filter: `drop-shadow(0 0 16px ${shadowColor})`,
            }),
        },
        popover: {
            position: 'absolute',
            maxWidth: 'min(90vw, 27rem)',
            width: 'max-content',
            boxSizing: 'border-box',
            background: isThemeDark(theme) ? backgroundSurfaceColor : backgroundColor,
            padding: '8px 16px',
            pointerEvents: 'auto',
            ...directionPositionMap[direction],
            ...textSmallStyle,
            listStyleType: 'none',
            color: primaryColor,
            whiteSpace: 'inherit',
            borderRadius: borderRadiusSmall,
            ...(isHighContrastMode && {
                outline: `1px solid ${canvasTextColor}`,
            }),
            ...prefersColorSchemeDarkMediaQuery(theme, {
                background: backgroundSurfaceColorDark,
                color: primaryColorDark,
            }),
        },
        '@keyframes fadeIn': {
            from: {
                opacity: 0,
            },
            to: {
                opacity: 1,
            },
        },
    });
};

const getCheckedSVGBackgroundImage = (fill) => {
    return getInlineSVGBackgroundImage(`<circle fill="${fill}" cx="12" cy="12" r="6"/>`);
};
const getComponentCss$v = (hideLabel, state, isDisabled, isLoading, theme) => {
    const checkedIconColor = isHighContrastMode
        ? getHighContrastColors().canvasColor
        : escapeHashCharacter(getInvertedThemedColors(theme).primaryColor);
    const checkedIconColorDark = isHighContrastMode
        ? getHighContrastColors().canvasColor
        : escapeHashCharacter(getInvertedThemedColors('dark').primaryColor);
    return getCss({
        '@global': {
            ':host': {
                display: 'block',
                ...addImportantToEachRule({
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            // ::slotted(input)
            ...addImportantToEachRule(mergeDeep(getSlottedCheckboxRadioButtonStyles(state, isDisabled, isLoading, theme), {
                '::slotted': {
                    '&(input)': {
                        gridArea: '1/1',
                        borderRadius: '50%',
                    },
                    // TODO: is it somehow useful possible to make following styles configurable by paramter?
                    ...(!isLoading && {
                        '&(input:checked)': {
                            backgroundImage: getCheckedSVGBackgroundImage(checkedIconColor),
                            ...prefersColorSchemeDarkMediaQuery(theme, {
                                backgroundImage: getCheckedSVGBackgroundImage(checkedIconColorDark),
                            }),
                        },
                    }),
                },
            })),
        },
        root: {
            display: 'grid',
            gridTemplateColumns: 'auto minmax(0, 1fr)',
            rowGap: spacingStaticXSmall,
        },
        wrapper: {
            display: 'grid',
            gridArea: '1/1',
            alignSelf: 'flex-start', // in case label becomes multiline
            ...(isDisabledOrLoading(isDisabled, isLoading) && {
                // TODO: maybe .wrapper should handle it for all form components while pointer-events: none is set to input
                cursor: 'not-allowed',
            }),
        },
        ...(isLoading && {
            // TODO: extract for checkbox-wrapper and radio-button-wrapper (not gridArea and placeSelf)
            spinner: {
                position: 'relative', // ensure correct stacking, can be removed as soon as focus for input is handled with outline
                gridArea: '1/1',
                placeSelf: 'center',
                width: fontLineHeight,
                height: fontLineHeight,
                font: `${fontSizeTextSmall} ${fontFamily}`, // needed for correct width and height definition based on ex-unit
                pointerEvents: 'none',
            },
        }),
        // .label / .required
        ...getFunctionalComponentLabelStyles(isDisabled || isLoading, hideLabel, theme, {
            gridArea: '1/2',
        }, {
            paddingTop: '2px', // compensate vertical alignment
            paddingInlineStart: spacingStaticSmall, // asymmetric padding used instead of gap to prevent not clickable area between label and input
        }),
        // .message
        ...getFunctionalComponentStateMessageStyles(theme, state, {
            gridColumn: '1/3',
        }),
        // .loading
        ...getFunctionalComponentLoadingMessageStyles(),
    });
};

const gradientColorLight = {
    'background-base': '255,255,255',
    'background-surface': '238,239,242',
};
const gradientColorDark = {
    'background-base': '14,14,18',
    'background-surface': '33,34,37',
};
const gradientColorMap = {
    auto: gradientColorLight,
    light: gradientColorLight,
    dark: gradientColorDark,
};
const getGradient = (theme, gradientColorTheme) => {
    const gradientColor = gradientColorMap[theme][gradientColorTheme];
    return (`rgba(${gradientColor},1) 20%,` +
        `rgba(${gradientColor},0.6) 48%,` +
        `rgba(${gradientColor},0.3) 68%,` +
        `rgba(${gradientColor},0)`);
};
const prevNextWrapperWidth = `calc(${fontLineHeight} + 24px)`;
const getComponentCss$u = (gradientColor, isNextHidden, isPrevHidden, scrollIndicatorPosition, hasScrollbar, theme) => {
    const { backgroundColor, backgroundSurfaceColor, hoverColor } = getThemedColors(theme);
    const { backgroundColor: backgroundColorDark, backgroundSurfaceColor: backgroundSurfaceColorDark, hoverColor: hoverColorDark, } = getThemedColors('dark');
    const backgroundColorLight = {
        'background-base': backgroundColor,
        'background-surface': backgroundSurfaceColor,
    };
    const backgroundColorMap = {
        auto: backgroundColorLight,
        light: backgroundColorLight,
        dark: {
            'background-base': backgroundSurfaceColorDark,
            'background-surface': backgroundColorDark,
        },
    };
    const actionPrevNextStyles = {
        position: 'absolute',
        top: 0,
        bottom: 0,
        direction: 'ltr',
        width: prevNextWrapperWidth,
        padding: '4px 0',
        pointerEvents: 'none',
        display: 'flex',
        alignItems: scrollIndicatorPosition === 'center' ? 'center' : 'flex-start',
    };
    return getCss({
        '@global': {
            ':host': {
                display: 'block',
                ...addImportantToEachRule({
                    height: 'inherit',
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            button: {
                display: 'flex',
                pointerEvents: 'auto',
                alignItems: 'center',
                justifyContent: 'center',
                ...textSmallStyle,
                height: `calc(${fontLineHeight} + 4px)`,
                width: `calc(${fontLineHeight} + 4px)`,
                border: 0,
                outline: 0,
                cursor: 'pointer',
                background: backgroundColorMap[theme][gradientColor],
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    background: backgroundColorMap.dark[gradientColor],
                }),
                borderRadius: borderRadiusSmall,
                ...frostedGlassStyle,
                visibility: 'hidden',
                ...(!isThemeDark(theme) && dropShadowLowStyle),
                ...hoverMediaQuery({
                    transition: getTransition('background-color'),
                    '&:hover': {
                        ...frostedGlassStyle,
                        background: hoverColor,
                        ...prefersColorSchemeDarkMediaQuery(theme, {
                            background: hoverColorDark,
                        }),
                    },
                }),
            },
        },
        root: {
            position: 'relative',
            display: 'grid',
            gridTemplateColumns: `${prevNextWrapperWidth} minmax(0, 1fr) ${prevNextWrapperWidth}`,
            margin: '0 -4px',
            height: 'inherit',
        },
        'scroll-area': {
            gridArea: '1 / 1 / 1 / -1',
            padding: '4px',
            overflow: 'auto hidden',
            ...(!hasScrollbar && {
                // If scrollbar is disabled - hide scrollbar
                msOverflowStyle: 'none' /* IE and Edge */,
                scrollbarWidth: 'none' /* Firefox */,
                '&::-webkit-scrollbar': {
                    display: 'none',
                },
            }),
        },
        // Extra wrapper needed to compensate different offset parent calculation depending on browser.
        // Needed for position of status bar.
        'scroll-wrapper': {
            position: 'relative',
            display: 'inline-flex',
            minHeight: '28px',
            minWidth: '100%',
            verticalAlign: 'top',
            borderRadius: borderRadiusSmall,
            ...getFocusJssStyle(theme),
        },
        trigger: {
            position: 'absolute',
            top: 0,
            bottom: 0,
            width: '1px',
            visibility: 'hidden',
            '&:first-of-type': {
                left: 0,
            },
            '&:last-of-type': {
                right: 0,
            },
        },
        'action-prev': {
            ...actionPrevNextStyles,
            left: '-1px', // ensures that the gradient always overlays the content (e.g. when zoomed)
            justifyContent: 'flex-start',
            background: `linear-gradient(to right, ${getGradient(theme, gradientColor)} 100%)`,
            ...prefersColorSchemeDarkMediaQuery(theme, {
                background: `linear-gradient(to right, ${getGradient('dark', gradientColor)} 100%)`,
            }),
            visibility: isPrevHidden ? 'hidden' : 'inherit',
            '& button': {
                marginLeft: '8px',
                // hide buttons on mobile (actually devices not supporting hover)
                ...hoverMediaQuery({
                    visibility: isPrevHidden ? 'hidden' : 'inherit',
                }),
            },
        },
        'action-next': {
            ...actionPrevNextStyles,
            right: '-1px', // ensures that the gradient always overlays the content (e.g. when zoomed)
            justifyContent: 'flex-end',
            background: `linear-gradient(to left, ${getGradient(theme, gradientColor)} 100%)`,
            ...prefersColorSchemeDarkMediaQuery(theme, {
                background: `linear-gradient(to left, ${getGradient('dark', gradientColor)} 100%)`,
            }),
            visibility: isNextHidden ? 'hidden' : 'inherit',
            '& button': {
                marginRight: '8px',
                // hide buttons on mobile (actually devices not supporting hover)
                ...hoverMediaQuery({
                    visibility: isNextHidden ? 'hidden' : 'inherit',
                }),
            },
        },
        icon: {
            '&:dir(rtl)': {
                transform: 'scaleX(-1)',
            },
        },
    });
};

const ITEM_PADDING = '17px';
const ICON_SIZE = '1.5rem';
const ICON_MARGIN = '.25rem';
const getColors$2 = (isDisabled, isSelected, theme) => {
    const { primaryColor, contrastMediumColor, disabledColor, contrastLowColor } = getThemedColors(theme);
    const { highlightColor } = getHighContrastColors();
    return {
        buttonColor: isDisabled ? disabledColor : primaryColor,
        labelColor: isDisabled ? disabledColor : contrastMediumColor,
        borderColor: isSelected ? (isHighContrastMode ? highlightColor : primaryColor) : contrastLowColor,
        hoverBorderColor: primaryColor,
    };
};
const getItemPadding = (hasIconAndSlottedContent) => hasIconAndSlottedContent ? `13px ${ITEM_PADDING} 13px 13px` : `13px ${ITEM_PADDING}`;
const getComponentCss$t = (isDisabled, isSelected, hasIcon, hasSlottedContent, theme) => {
    const { buttonColor, labelColor, borderColor, hoverBorderColor } = getColors$2(isDisabled, isSelected, theme);
    const { buttonColor: buttonColorDark, labelColor: labelColorDark, borderColor: borderColorDark, hoverBorderColor: hoverBorderColorDark, } = getColors$2(isDisabled, isSelected, 'dark');
    return getCss({
        '@global': {
            ':host': {
                display: 'block',
                ...addImportantToEachRule({
                    outline: 0,
                    ...hostHiddenStyles,
                }),
            },
            // All width relevant styling has to be kept in sync with the tempDiv of the p-segmented-control utils
            button: {
                position: 'relative',
                display: 'block',
                height: '100%',
                width: '100%',
                padding: getItemPadding(hasIcon && hasSlottedContent),
                margin: 0, // Removes default button margin on safari 15
                border: `${borderWidthBase} solid ${borderColor}`,
                borderRadius: borderRadiusSmall,
                background: 'transparent',
                color: buttonColor,
                ...textSmallStyle,
                ...(isDisabled
                    ? {
                        cursor: 'not-allowed',
                    }
                    : {
                        cursor: 'pointer',
                        ...(!isSelected &&
                            hoverMediaQuery({
                                transition: getTransition('border-color'),
                                '&:hover': {
                                    borderColor: hoverBorderColor,
                                    ...prefersColorSchemeDarkMediaQuery(theme, {
                                        borderColor: hoverBorderColorDark,
                                    }),
                                },
                            })),
                    }),
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    borderColor: borderColorDark,
                    color: buttonColorDark,
                }),
                ...getFocusJssStyle(theme),
            },
            // label
            span: {
                display: 'block',
                ...textXSmallStyle,
                overflowWrap: 'normal',
                color: labelColor,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    color: labelColorDark,
                }),
            },
        },
        ...(hasIcon && {
            icon: {
                height: ICON_SIZE,
                width: ICON_SIZE,
                ...(hasSlottedContent && {
                    marginInlineEnd: ICON_MARGIN,
                }),
            },
        }),
    });
};

const MIN_ITEM_WIDTH = 46;
const MAX_ITEM_WIDTH = 220;
const getComponentCss$s = (maxWidth, columns) => {
    maxWidth = (maxWidth > MAX_ITEM_WIDTH && MAX_ITEM_WIDTH) || (maxWidth < MIN_ITEM_WIDTH && MIN_ITEM_WIDTH) || maxWidth;
    return getCss({
        '@global': {
            ':host': {
                display: 'grid',
                ...addImportantToEachRule({
                    gridAutoRows: '1fr', // for equal height
                    ...buildResponsiveStyles(columns, (col) => ({
                        gridTemplateColumns: col === 'auto' ? `repeat(auto-fit, ${maxWidth}px)` : `repeat(${col}, minmax(0, 1fr))`,
                    })),
                    gap: '6px',
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
        },
    });
};

const dropdownPositionVar = '--p-internal-dropdown-position';
const getButtonStyles$1 = (direction, isOpen, state, theme) => {
    const { primaryColor, disabledColor, contrastMediumColor } = getThemedColors(theme);
    const { primaryColor: primaryColorDark, disabledColor: disabledColorDark, contrastMediumColor: contrastMediumColorDark, } = getThemedColors('dark');
    const { formStateHoverColor, formStateColor } = getThemedFormStateColors(theme, state);
    const { formStateHoverColor: formStateHoverColorDark, formStateColor: formStateColorDark } = getThemedFormStateColors('dark', state);
    const isDirectionDown = direction === 'down';
    return {
        '@global': {
            // TODO: extract generic default button/anchor reset style
            button: {
                position: 'absolute',
                inset: 0,
                width: '100%', // fixes Firefox positioning issue
                height: '100%', // fixes Firefox positioning issue
                margin: 0,
                padding: 0,
                background: 'transparent',
                border: `${borderWidthBase} solid ${isOpen ? primaryColor : formStateColor || contrastMediumColor}`, // using border of styled select below for label:hover selector
                borderRadius: borderRadiusSmall,
                outline: '0',
                cursor: 'pointer',
                transition: getTransition('border-color'), // background and text color are handled on select
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    borderColor: isOpen ? primaryColorDark : formStateColorDark || contrastMediumColorDark,
                }),
                // TODO: getFocusJssStyle() can't be re-used because focus style differs for form elements
                '&:focus, &:focus ~ ul': {
                    borderColor: primaryColor,
                    ...prefersColorSchemeDarkMediaQuery(theme, {
                        borderColor: primaryColorDark,
                    }),
                },
                ...hoverMediaQuery({
                    '&:not(:disabled):not(:focus):hover': {
                        borderColor: isOpen ? primaryColor : formStateHoverColor || primaryColor,
                        ...prefersColorSchemeDarkMediaQuery(theme, {
                            borderColor: isOpen ? primaryColorDark : formStateHoverColorDark || primaryColorDark,
                        }),
                    },
                }),
                '&:disabled': {
                    cursor: 'not-allowed',
                    borderColor: disabledColor,
                    ...prefersColorSchemeDarkMediaQuery(theme, {
                        borderColor: disabledColorDark,
                    }),
                },
                ...(isOpen && {
                    [isDirectionDown ? 'borderBottomLeftRadius' : 'borderTopLeftRadius']: 0,
                    [isDirectionDown ? 'borderBottomRightRadius' : 'borderTopRightRadius']: 0,
                }),
            },
        },
    };
};
const getFilterStyles = (direction, isOpen, state, disabled, theme) => {
    const { primaryColor, backgroundColor, disabledColor, contrastMediumColor } = getThemedColors(theme);
    const { primaryColor: primaryColorDark, backgroundColor: backgroundColorDark, disabledColor: disabledColorDark, contrastMediumColor: contrastMediumColorDark, } = getThemedColors('dark');
    const { formStateHoverColor, formStateColor } = getThemedFormStateColors(theme, state);
    const { formStateHoverColor: formStateHoverColorDark, formStateColor: formStateColorDark } = getThemedFormStateColors('dark', state);
    const isDirectionDown = direction === 'down';
    const placeHolderJssStyle = {
        opacity: 1,
        color: disabled ? disabledColor : primaryColor,
    };
    const placeHolderDarkJssStyle = {
        opacity: 1,
        color: disabled ? disabledColorDark : primaryColorDark,
    };
    return {
        '@global': {
            input: {
                display: 'block',
                position: 'absolute',
                inset: borderWidthBase,
                width: 'calc(100% - 4px)', // fixes Firefox positioning issue, 4px = 2 x borderWidthBase
                height: 'calc(100% - 4px)', // fixes Firefox positioning issue, 4px = 2 x borderWidthBase
                zIndex: 1,
                font: textSmallStyle.font.replace('ex', 'ex + 6px'), // a minimum line-height is needed for input, otherwise value is scrollable in Chrome, +6px is alig
                margin: 0, // necessary reset for iOS Safari 15 (and maybe other browsers)
                // TODO: could be done with css subgrid much more elegant in the near future
                //  or move input into select-wrapper and handle it the same like multi-select
                padding: `${formElementPaddingVertical} ${formElementPaddingHorizontal}`,
                paddingInlineEnd: getCalculatedFormElementPaddingHorizontal(1),
                outline: '0',
                WebkitAppearance: 'none', // iOS safari
                appearance: 'none',
                boxSizing: 'border-box',
                border: '0', // done via span
                borderRadius: borderRadiusSmall, // for white corners
                opacity: 0, // is used to overlay input on focus
                ...textSmallStyle,
                textIndent: 0,
                cursor: disabled ? 'not-allowed' : 'text',
                color: primaryColor,
                background: backgroundColor,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    color: primaryColorDark,
                    background: backgroundColorDark,
                }),
                '&::placeholder': {
                    ...placeHolderJssStyle,
                    ...prefersColorSchemeDarkMediaQuery(theme, placeHolderDarkJssStyle),
                },
                '&::-webkit-input-placeholder': {
                    ...placeHolderJssStyle,
                    ...prefersColorSchemeDarkMediaQuery(theme, placeHolderDarkJssStyle),
                },
                '&::-moz-placeholder': {
                    ...placeHolderJssStyle,
                    ...prefersColorSchemeDarkMediaQuery(theme, placeHolderDarkJssStyle),
                },
                '&:not(:disabled):focus': {
                    opacity: 1, // to display value while typing
                    '&+span, &~ ul': {
                        borderColor: primaryColor,
                        ...prefersColorSchemeDarkMediaQuery(theme, {
                            borderColor: primaryColorDark,
                        }),
                    },
                },
                ...hoverMediaQuery({
                    '&:not(:disabled)': {
                        '&+span:hover': {
                            borderColor: isOpen ? primaryColor : formStateHoverColor || primaryColor,
                            ...prefersColorSchemeDarkMediaQuery(theme, {
                                borderColor: isOpen ? primaryColorDark : formStateHoverColorDark || primaryColorDark,
                            }),
                        },
                        '&:hover': {
                            '&+span, &~ul': {
                                borderColor: isOpen ? primaryColor : formStateHoverColor || primaryColor,
                                ...prefersColorSchemeDarkMediaQuery(theme, {
                                    borderColor: isOpen ? primaryColorDark : formStateHoverColorDark || primaryColorDark,
                                }),
                            },
                        },
                    },
                }),
                // TODO: we should try to get rid of the span and apply the border-styles on either select or input
                '&+span': {
                    // for focus outline and clicking arrow since input ends left of the icon
                    position: 'absolute',
                    inset: 0,
                    transition: getTransition('border-color'),
                    pointerEvents: 'all',
                    cursor: disabled ? 'not-allowed' : 'pointer',
                    border: `${borderWidthBase} solid ${isOpen ? primaryColor : formStateColor || contrastMediumColor}`,
                    ...prefersColorSchemeDarkMediaQuery(theme, {
                        borderColor: isOpen ? primaryColorDark : formStateColorDark || contrastMediumColorDark,
                    }),
                    borderRadius: borderRadiusSmall,
                    ...(isOpen && {
                        [isDirectionDown ? 'borderBottomLeftRadius' : 'borderTopLeftRadius']: 0,
                        [isDirectionDown ? 'borderBottomRightRadius' : 'borderTopRightRadius']: 0,
                    }),
                },
            },
        },
    };
};
const getListStyles$1 = (direction, theme) => {
    const isDirectionDown = direction === 'down';
    const { primaryColor: primaryColorDark, backgroundColor: backgroundColorDark, contrastMediumColor: contrastMediumColorDark, disabledColor: disabledColorDark, contrastHighColor: contrastHighColorDark, backgroundSurfaceColor: backgroundSurfaceColorDark, contrastLowColor: contrastLowColorDark, } = getThemedColors('dark');
    const { primaryColor, backgroundColor, contrastMediumColor, contrastHighColor, backgroundSurfaceColor, disabledColor, contrastLowColor, } = getThemedColors(theme);
    const { highlightColor } = getHighContrastColors();
    return {
        '@global': {
            ul: {
                display: 'flex',
                flexDirection: 'column',
                gap: spacingStaticSmall,
                position: `var(${dropdownPositionVar}, absolute)`, // for vrt tests
                padding: '6px',
                margin: 0,
                background: backgroundColor,
                ...textSmallStyle,
                color: contrastHighColor,
                zIndex: 10,
                left: 0,
                right: 0,
                [isDirectionDown ? 'top' : 'bottom']: 'calc(100% - 2px)', // 2px border + 2px safety for rounded corners
                boxSizing: 'border-box',
                maxHeight: `${8.5 * (OPTION_HEIGHT + 8) + 6 + 2}px`, // 8px = gap, 6px = padding, 2px = border
                overflowY: 'auto',
                WebkitOverflowScrolling: 'touch',
                scrollBehavior: 'smooth',
                border: `2px solid ${primaryColor}`,
                [isDirectionDown ? 'borderTop' : 'borderBottom']: addImportantToRule(`1px solid ${contrastMediumColor}`),
                ...(isDirectionDown
                    ? ['borderBottomLeftRadius', 'borderBottomRightRadius']
                    : ['borderTopLeftRadius', 'borderTopRightRadius']).reduce((result, curr) => ({ ...result, [curr]: borderRadiusSmall }), {}),
                scrollbarWidth: 'thin', // firefox
                scrollbarColor: 'auto', // firefox
                transition: getTransition('border-color'),
                transform: 'translate3d(0,0,0)', // fix iOS bug if less than 5 items are displayed
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    color: contrastHighColorDark,
                    background: backgroundColorDark,
                    borderColor: primaryColorDark,
                    [isDirectionDown ? 'borderTopColor' : 'borderBottomColor']: addImportantToRule(contrastMediumColorDark),
                }),
            },
        },
        option: {
            display: 'flex',
            justifyContent: 'space-between',
            gap: '12px',
            padding: `${spacingStaticSmall} 12px`,
            flex: `1 0 calc(${fontLineHeight} + ${spacingStaticSmall} * 2)`,
            cursor: 'pointer',
            textAlign: 'start',
            wordBreak: 'break-word',
            boxSizing: 'border-box',
            borderRadius: borderRadiusSmall,
            transition: `${getTransition('background-color')}, ${getTransition('color')}`,
            ...getNoResultsOptionJssStyle(),
            ...hoverMediaQuery({
                '&:not([aria-disabled]):not(.option--disabled):not([role=status]):hover': {
                    color: isHighContrastMode ? highlightColor : primaryColor,
                    background: contrastLowColor,
                    ...prefersColorSchemeDarkMediaQuery(theme, {
                        color: isHighContrastMode ? highlightColor : primaryColorDark,
                        background: contrastLowColorDark,
                    }),
                },
            }),
            '&--selected': {
                cursor: 'default',
                pointerEvents: 'none',
                background: backgroundSurfaceColor,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    background: backgroundSurfaceColorDark,
                }),
            },
            '&--highlighted': {
                background: contrastLowColor,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    background: contrastLowColorDark,
                }),
            },
            '&--highlighted, &--selected': {
                color: isHighContrastMode ? highlightColor : primaryColor,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    color: isHighContrastMode ? highlightColor : primaryColorDark,
                }),
            },
            '&--disabled': {
                cursor: 'not-allowed',
                color: disabledColor,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    color: disabledColorDark,
                }),
            },
            '&--hidden': {
                display: 'none',
            },
        },
        optgroup: {
            color: contrastMediumColor,
            display: 'block',
            padding: '3px 14px',
            fontWeight: fontWeightSemiBold,
            ...prefersColorSchemeDarkMediaQuery(theme, {
                color: contrastMediumColorDark,
            }),
            '&:not(:first-child)': {
                marginTop: spacingStaticSmall,
            },
            '&~$option': {
                paddingLeft: '24px',
            },
        },
    };
};
const getComponentCss$r = (direction, isOpen, state, disabled, filter, isNativePopoverCase, theme) => {
    return getCss(
    // merge because of global styles
    mergeDeep({
        '@global': {
            ':host': {
                display: 'block',
                position: 'relative',
            },
        },
        'sr-text': {
            display: 'none',
        },
        ...(isNativePopoverCase && {
            popover: {
                ...getPopoverResetJssStyle(),
            },
        }),
    }, filter
        ? getFilterStyles(direction, isOpen, state, disabled, theme)
        : getButtonStyles$1(direction, isOpen, state, theme), isOpen && getListStyles$1(direction, theme)));
};

const getComponentCss$q = (isDisabled, hasCustomDropdown, hideLabel, state, theme) => {
    return getCss({
        '@global': {
            ':host': {
                display: 'block',
                ...addImportantToEachRule({
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            // ::slotted(select)
            ...addImportantToEachRule(getSlottedTextFieldTextareaSelectStyles('select', state, false, theme, {
                gridArea: '1/1/1/-1',
                position: 'static',
                zIndex: 0, // TODO: overrides global style.css in e2e and vrts
                cursor: 'pointer',
                // TODO: move into getSlottedTextFieldTextareaSelectStyles()
                padding: `${formElementPaddingVertical} ${formElementPaddingHorizontal}`,
                paddingInlineEnd: getCalculatedFormElementPaddingHorizontal(1),
                // TODO: needs to be aligned with multi-select
                ...(hasCustomDropdown && !isDisabled && { borderColor: 'transparent' }),
            })),
        },
        root: {
            display: 'grid',
            gap: spacingStaticXSmall,
        },
        wrapper: {
            display: 'grid',
            gridTemplateColumns: `minmax(0, 1fr) auto ${formElementLayeredSafeZone}`,
        },
        // TODO: extract for multi-select, select-wrapper and text-field (not gridArea and placeSelf)
        icon: {
            gridArea: '1/2',
            placeSelf: 'center',
            position: 'relative',
            zIndex: 2, // ensures icon is above input or button of select dropdown
            pointerEvents: 'none',
            padding: formButtonOrIconPadding,
            transform: 'rotate3d(0,0,1,0.0001deg)', // needs to be a little more than 0 for correct direction in safari
            transition: getTransition('transform'),
            '&--open': {
                transform: 'rotate3d(0,0,1,180deg)',
            },
        },
        dropdown: {
            gridArea: '1/1/1/-1',
        },
        // .label / .required
        ...getFunctionalComponentLabelStyles(isDisabled, hideLabel, theme),
        // .message
        ...getFunctionalComponentStateMessageStyles(theme, state),
    });
};

// TODO: Enforce order of slotted text, img
const getComponentCss$p = (theme) => {
    return getCss({
        '@global': addImportantToEachRule({
            ':host': {
                scrollMargin: '6px', // Aligns option when list is scrolled by navigating with keyboard
                ...hostHiddenStyles,
            },
            '::slotted(img)': {
                height: fontLineHeight,
                borderRadius: borderRadiusSmall,
            },
        }),
        ...getOptionStyles(theme),
        icon: {
            marginInlineStart: 'auto',
        },
    });
};
// TODO: Copied from multi-select and select-wrapper-dropdown, extract and reuse
const getOptionStyles = (theme) => {
    const { primaryColor: primaryColorDark, contrastHighColor: contrastHighColorDark, disabledColor: disabledColorDark, backgroundSurfaceColor: backgroundSurfaceColorDark, contrastLowColor: contrastLowColorDark, } = getThemedColors('dark');
    const { primaryColor, contrastHighColor, backgroundSurfaceColor, disabledColor, contrastLowColor } = getThemedColors(theme);
    const { highlightColor } = getHighContrastColors();
    return {
        option: {
            display: 'flex',
            // justifyContent: 'space-between', // TODO: Commenented out
            gap: '12px',
            padding: `${spacingStaticSmall} 12px`,
            flex: `1 0 calc(${fontLineHeight} + ${spacingStaticSmall} * 2)`,
            minHeight: `calc(${fontLineHeight} + ${spacingStaticSmall} * 2)`, // TODO: Added this line to preserve height for empty option
            color: contrastHighColor,
            ...prefersColorSchemeDarkMediaQuery(theme, {
                color: contrastHighColorDark,
            }),
            cursor: 'pointer',
            textAlign: 'start',
            wordBreak: 'break-word',
            boxSizing: 'border-box',
            borderRadius: borderRadiusSmall,
            transition: `${getTransition('background-color')}, ${getTransition('color')}`,
            ...getNoResultsOptionJssStyle(),
            ...hoverMediaQuery({
                '&:not([aria-disabled]):not(.option--disabled):not([role=status]):hover': {
                    color: isHighContrastMode ? highlightColor : primaryColor,
                    background: contrastLowColor,
                    ...prefersColorSchemeDarkMediaQuery(theme, {
                        color: isHighContrastMode ? highlightColor : primaryColorDark,
                        background: contrastLowColorDark,
                    }),
                },
            }),
            '&--selected': {
                cursor: 'default',
                pointerEvents: 'none',
                background: backgroundSurfaceColor,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    background: backgroundSurfaceColorDark,
                }),
            },
            '&--highlighted': {
                background: contrastLowColor,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    background: contrastLowColorDark,
                }),
            },
            '&--highlighted, &--selected': {
                color: isHighContrastMode ? highlightColor : primaryColor,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    color: isHighContrastMode ? highlightColor : primaryColorDark,
                }),
            },
            '&--disabled': {
                cursor: 'not-allowed',
                color: disabledColor,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    color: disabledColorDark,
                }),
            },
            '&--hidden': {
                display: 'none',
            },
        },
    };
};

const INTERNAL_SELECT_SLOT = 'internal-select';

const getComponentCss$o = (direction, isOpen, isDisabled, hideLabel, state, isWithinForm, isNativePopoverCase, theme) => {
    return getCss({
        '@global': {
            ':host': addImportantToEachRule({
                ...colorSchemeStyles,
                ...hostHiddenStyles,
            }),
            ...(isWithinForm &&
                addImportantToEachRule({
                    [`::slotted([slot=${INTERNAL_SELECT_SLOT}])`]: {
                        position: 'absolute',
                        opacity: 0,
                        height: '0px',
                        bottom: 0,
                    },
                })),
            // TODO: re-use select-wrapper-style
            button: getButtonStyles(isDisabled, direction, isOpen, state, theme),
        },
        root: {
            display: 'grid',
            gap: spacingStaticXSmall,
            ...(isWithinForm && {
                position: 'relative', // Necessary for native HTML validation box positioning (internal-select)
            }),
        },
        wrapper: {
            position: 'relative',
            display: 'grid',
            gridTemplateColumns: `minmax(0, 1fr) auto auto ${formElementLayeredSafeZone}`,
        },
        icon: {
            gridArea: '1/3',
            placeSelf: 'center',
            padding: formButtonOrIconPadding,
            pointerEvents: 'none',
            transform: 'rotate3d(0,0,1,0.0001deg)', // needs to be a little more than 0 for correct direction in safari
            transition: getTransition('transform'),
            '&--rotate': {
                transform: 'rotate3d(0,0,1,180deg)',
            },
        },
        listbox: getListStyles(isOpen, direction, theme),
        'sr-only': getHiddenTextJssStyle(),
        // .label / .required
        ...getFunctionalComponentLabelStyles(isDisabled, hideLabel, theme),
        // .message
        ...getFunctionalComponentStateMessageStyles(theme, state),
        ...(isNativePopoverCase && {
            popover: {
                ...getPopoverResetJssStyle(),
            },
        }),
    });
};
// TODO: Rename to JSSStyles
// TODO: use getSlottedTextFieldTextareaSelectStyles() instead an manipulate selectors like done with PIN Code or even better make it configurable as parameter
const getButtonStyles = (isDisabled, direction, isOpen, state, theme) => {
    const isDirectionDown = direction === 'down';
    const { primaryColor, disabledColor, backgroundColor, contrastMediumColor } = getThemedColors(theme);
    const { primaryColor: primaryColorDark, disabledColor: disabledColorDark, backgroundColor: backgroundColorDark, contrastMediumColor: contrastMediumColorDark, } = getThemedColors('dark');
    const { formStateColor, formStateHoverColor } = getThemedFormStateColors(theme, state);
    const { formStateColor: formStateColorDark, formStateHoverColor: formStateHoverColorDark } = getThemedFormStateColors('dark', state);
    return {
        textAlign: 'start', // TODO: Newly added (rest is copied from select-wrapper-dropdown), share rest for both components
        overflowX: 'hidden', // TODO: Newly added (rest is copied from select-wrapper-dropdown), share rest for both components
        whiteSpace: 'nowrap', // TODO: Newly added (rest is copied from select-wrapper-dropdown), share rest for both components
        gridArea: '1/1/1/-1',
        flex: 1,
        minWidth: 0,
        // TODO: abstract and re-use for multi-select, select-wrapper and text-field-wrapper
        height: `calc(${fontLineHeight} + 10px + ${borderWidthBase} * 2 + ${spacingStaticSmall} * 2)`, // we need 10px additionally so input height becomes 54px, // we need 6px additionally so input height becomes 50px
        font: textSmallStyle.font.replace('ex', 'ex + 6px'), // a minimum line-height is needed for input, otherwise value is scrollable in Chrome, +6px is alig
        margin: 0, // necessary reset for iOS Safari 15 (and maybe other browsers)
        padding: `${formElementPaddingVertical} ${formElementPaddingHorizontal}`,
        paddingInlineEnd: getCalculatedFormElementPaddingHorizontal(1),
        boxSizing: 'border-box',
        outline: 0,
        WebkitAppearance: 'none', // iOS safari
        appearance: 'none',
        ...textSmallStyle,
        textOverflow: 'ellipsis',
        cursor: 'pointer',
        '&:disabled': {
            cursor: 'not-allowed',
        },
        transition: `${getTransition('background-color')}, ${getTransition('border-color')}, ${getTransition('color')}`, // for smooth transitions between e.g. disabled states
        color: primaryColor,
        '&:not(:focus)': {
            ...getPlaceholderJssStyle({ color: primaryColor, opacity: 1 }),
            ...prefersColorSchemeDarkMediaQuery(theme, getPlaceholderJssStyle({ color: primaryColorDark, opacity: 1 })),
        }, // Opacity fixes placeholder being shown lighter in firefox
        ...hoverMediaQuery({
            '&:hover:not(:disabled):not(:focus),label:hover~.wrapper &:not(:disabled):not(:focus)': {
                borderColor: isOpen ? primaryColor : formStateHoverColor || primaryColor,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    borderColor: isOpen ? primaryColorDark : formStateHoverColorDark || primaryColorDark,
                }),
            },
        }),
        ...(!isDisabled && {
            '&:focus': {
                borderColor: primaryColor,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    borderColor: primaryColorDark,
                }),
            },
        }),
        background: backgroundColor,
        border: `${borderWidthBase} solid ${isOpen ? primaryColor : formStateColor || contrastMediumColor}`,
        borderRadius: borderRadiusSmall,
        ...(isOpen && {
            [isDirectionDown ? 'paddingBottom' : 'paddingTop']: `calc(${formElementPaddingVertical} + 1px)`, // Add padding to keep same height when border changes
            [isDirectionDown ? 'borderBottom' : 'borderTop']: addImportantToRule(`1px solid ${contrastMediumColor}`),
            [isDirectionDown ? 'borderBottomLeftRadius' : 'borderTopLeftRadius']: 0,
            [isDirectionDown ? 'borderBottomRightRadius' : 'borderTopRightRadius']: 0,
        }),
        ...(isDisabled && {
            ...getPlaceholderJssStyle({ color: disabledColor }),
            cursor: 'not-allowed',
            color: disabledColor,
            borderColor: disabledColor,
            WebkitTextFillColor: disabledColor,
        }),
        ...prefersColorSchemeDarkMediaQuery(theme, {
            color: primaryColorDark,
            background: backgroundColorDark,
            border: `${borderWidthBase} solid ${isOpen ? primaryColorDark : formStateColorDark || contrastMediumColorDark}`,
            ...(isOpen && {
                [isDirectionDown ? 'borderBottom' : 'borderTop']: addImportantToRule(`1px solid ${contrastMediumColorDark}`),
            }),
            ...(isDisabled && {
                ...getPlaceholderJssStyle({ color: disabledColorDark }),
                color: disabledColorDark,
                borderColor: disabledColorDark,
                WebkitTextFillColor: disabledColorDark,
            }),
        }),
    };
};
// TODO: Rename to JSSStyles
// TODO: Copied from multi-select, extract and use in select and multi-select
const getListStyles = (isOpen, direction, theme) => {
    const isDirectionDown = direction === 'down';
    const { primaryColor, backgroundColor } = getThemedColors(theme);
    const { primaryColor: primaryColorDark, backgroundColor: backgroundColorDark } = getThemedColors('dark');
    return {
        position: 'absolute',
        margin: 0,
        display: isOpen ? 'flex' : 'none',
        flexDirection: 'column',
        gap: spacingStaticSmall,
        padding: '6px',
        ...textSmallStyle,
        zIndex: 10,
        // TODO: Inset inline 0
        left: 0,
        right: 0,
        [isDirectionDown ? 'top' : 'bottom']: '100%',
        boxSizing: 'border-box',
        maxHeight: `${8.5 * (MULTI_SELECT_OPTION_HEIGHT + 8) + 6 + 2}px`, // 8.5 options * option height + 8px gap + additional spacing (6px = padding, 2px = border)
        overflowY: 'auto',
        WebkitOverflowScrolling: 'touch',
        background: backgroundColor,
        border: `2px solid ${primaryColor}`,
        [isDirectionDown ? 'borderTop' : 'borderBottom']: 'none',
        borderRadius: borderRadiusSmall,
        [isDirectionDown ? 'borderTopLeftRadius' : 'borderBottomLeftRadius']: 0,
        [isDirectionDown ? 'borderTopRightRadius' : 'borderBottomRightRadius']: 0,
        scrollbarWidth: 'thin', // firefox
        scrollbarColor: 'auto', // firefox
        transition: getTransition('border-color'),
        transform: 'translate3d(0,0,0)', // fix iOS bug if less than 5 items are displayed
        ...prefersColorSchemeDarkMediaQuery(theme, {
            background: backgroundColorDark,
            borderColor: primaryColorDark,
        }),
    };
};

const sizeSmall = '48px';
const sizeMedium = '72px';
const sizeLarge = '104px';
const sizeMap$1 = {
    small: { height: sizeSmall, width: sizeSmall },
    medium: { height: sizeMedium, width: sizeMedium },
    large: { height: sizeLarge, width: sizeLarge },
    inherit: { height: 'inherit', width: 'inherit' },
};
const getComponentCss$n = (size, theme) => {
    const strokeDasharray = '57'; // C = 2R
    const animationDuration = `var(${cssVariableAnimationDuration}, ${motionDurationVeryLong})`;
    const { primaryColor, contrastMediumColor } = getThemedColors(theme);
    const { primaryColor: primaryColorDark, contrastMediumColor: contrastMediumColorDark } = getThemedColors('dark');
    const { canvasColor, canvasTextColor } = getHighContrastColors();
    const firstHighContrastStrokeColor = isHighContrastMode && canvasTextColor;
    const lastHighContrastStrokeColor = isHighContrastMode && canvasColor;
    return getCss({
        '@global': {
            ':host': {
                display: 'inline-flex',
                ...addImportantToEachRule({
                    verticalAlign: 'top',
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            svg: {
                display: 'block', // for correct vertical alignment
                fill: 'none',
                animation: `$rotate ${animationDuration} steps(50) infinite`,
            },
            circle: {
                '&:first-child': {
                    // TODO: High Contrast Mode should be handled within a local color helper function
                    stroke: firstHighContrastStrokeColor || contrastMediumColor,
                    ...prefersColorSchemeDarkMediaQuery(theme, {
                        stroke: firstHighContrastStrokeColor || contrastMediumColorDark,
                    }),
                },
                '&:last-child': {
                    animation: `$dash ${animationDuration} steps(50) infinite`,
                    // TODO: High Contrast Mode should be handled within a local color helper function
                    stroke: lastHighContrastStrokeColor || primaryColor,
                    ...prefersColorSchemeDarkMediaQuery(theme, {
                        stroke: lastHighContrastStrokeColor || primaryColorDark,
                    }),
                    strokeDasharray: strokeDasharray
                        ,
                    strokeLinecap: 'round',
                },
            },
            '@keyframes rotate': {
                '0%': {
                    transform: 'rotateZ(0deg)',
                },
                '100%': {
                    transform: 'rotateZ(360deg)',
                },
            },
            '@keyframes dash': {
                '0%': {
                    strokeDashoffset: 57,
                    transform: 'rotateZ(0)',
                },
                '50%, 75%': {
                    strokeDashoffset: 20,
                    transform: 'rotateZ(80deg)',
                },
                '100%': {
                    strokeDashoffset: 57,
                    transform: 'rotateZ(360deg)',
                },
            },
        },
        root: {
            display: 'block',
            ...buildResponsiveStyles(size, (s) => sizeMap$1[s]),
            strokeWidth: 1.5,
        },
        'sr-only': getHiddenTextJssStyle(),
    });
};

const getSVGPath = (stepCount, numberedCircleColors, isStateCurrent) => {
    // # of the hexcolor starts a fragment identifier in URLs, so we have to replace it with the escaped value of # = %23
    numberedCircleColors = Object.entries(numberedCircleColors).reduce((result, [key, value]) => ({ ...result, [key]: escapeHashCharacter(value) }), {});
    const { disabledColor, invertedBaseColor, primaryColor } = numberedCircleColors;
    const fillColor = isStateCurrent ? invertedBaseColor : disabledColor;
    const svgCirclePath = `<circle fill="${isStateCurrent ? primaryColor : 'none'}"${isStateCurrent ? '' : ` stroke="${fillColor}"`} stroke-width="1px" cx="12" cy="12" r="9"/>`;
    // Full SVG is provided by design (./numbers_raw.svg), created with illustrator and optimized with ImageOptim.
    // The optimized file can be found in ./numbers_optim.svg.
    // TODO: could certainly be optimized size wise by exporting icons larger and having less decimals
    const svgNumberedCirclePaths = [
        `${svgCirclePath}<path fill="${fillColor}" d="m12.33 8.67-2.43.91v-.94l2.6-1.03h.85v8.78h-1.02z"/>`,
        `${svgCirclePath}<path fill="${fillColor}" d="m9.46 15.58c0-1.35.73-2.07 1.7-2.72l.95-.63c.78-.52 1.57-1.05 1.57-2.24 0-1.12-.62-1.58-1.7-1.58s-1.68.48-1.78 1.97h-.96c.06-1.82.78-2.91 2.74-2.91s2.72.92 2.72 2.52-.92 2.23-1.79 2.8l-.95.63c-1.11.75-1.52 1.18-1.52 2.01v.16h4.17v.81h-5.15v-.81z"/>`,
        `${svgCirclePath}<path fill="${fillColor}" d="m10.1 13.73c.1 1.43.63 2 1.92 2 1.2 0 1.8-.49 1.8-1.68 0-1.08-.51-1.66-1.8-1.66h-.89v-.9h.83c1.12 0 1.66-.56 1.66-1.53 0-1.08-.64-1.55-1.73-1.55s-1.69.49-1.79 1.97h-.97c.1-1.79.84-2.91 2.76-2.91s2.74.92 2.74 2.49c0 .79-.38 1.54-1.16 1.9.84.28 1.36.92 1.36 2.19 0 1.54-.97 2.49-2.81 2.49-1.96 0-2.8-.9-2.88-2.81z"/>`,
        `${svgCirclePath}<path fill="${fillColor}" d="m8.87 13.6 3.54-5.99h1.43v5.89h1.25v.86h-1.25v2.02h-.99v-2.02h-3.98zm3.98-.1v-4.98l-2.91 4.98z"/>`,
        `${svgCirclePath}<path fill="${fillColor}" d="m9.34 12.45.42-4.83h4.71v.94h-3.9l-.26 2.95c.38-.43 1-.68 1.79-.68 1.86 0 2.76.9 2.76 2.81 0 2.06-1.03 2.91-2.86 2.91s-2.74-.84-2.81-2.51h.97c.06 1.13.57 1.7 1.84 1.7 1.39 0 1.85-.68 1.85-2.06s-.48-2-1.85-2c-1.07 0-1.54.42-1.75 1.17h-.91v-.39z"/>`,
        `${svgCirclePath}<path fill="${fillColor}" d="m9.97 11.02 2.22-3.4h1.1l-2.27 3.44c.33-.16.69-.23 1.1-.23 1.84 0 2.76.9 2.76 2.81 0 2.06-1.04 2.91-2.86 2.91s-2.87-.85-2.87-2.91c0-1.08.3-1.8.83-2.61zm2.05 4.71c1.38 0 1.84-.68 1.84-2.05s-.47-2.01-1.84-2.01-1.85.64-1.85 2.01.46 2.05 1.85 2.05z"/>`,
        `${svgCirclePath}<path fill="${fillColor}" d="m9.21 7.61h5.57v.74l-3.58 8.04h-1.05l3.54-7.84h-4.49v-.94z"/>`,
        `${svgCirclePath}<path fill="${fillColor}" d="m10.47 11.94c-.65-.33-1.13-.92-1.13-2.01 0-1.53.85-2.47 2.66-2.47s2.66.94 2.66 2.47c0 1.08-.47 1.68-1.15 2.01.92.35 1.34 1.07 1.34 2.11 0 1.73-.99 2.49-2.86 2.49s-2.86-.76-2.86-2.49c0-1.04.41-1.76 1.33-2.11zm1.53 3.78c1.27 0 1.85-.51 1.85-1.69 0-1.1-.58-1.61-1.85-1.61s-1.85.52-1.85 1.61c0 1.18.58 1.69 1.85 1.69zm1.65-5.76c0-1.1-.56-1.56-1.65-1.56s-1.65.47-1.65 1.56c0 1 .46 1.6 1.65 1.6s1.65-.6 1.65-1.6z"/>`,
        `${svgCirclePath}<path fill="${fillColor}" d="m9.16 10.33c0-2.03 1.02-2.86 2.83-2.86s2.82.81 2.82 2.85c0 1.11-.3 1.82-.81 2.64l-2.18 3.44h-1.1l2.18-3.37c-.31.14-.65.2-1.01.2-1.82 0-2.74-.99-2.74-2.9zm4.65 0c0-1.23-.47-1.92-1.81-1.92s-1.81.69-1.81 1.92c0 1.37.49 2.05 1.81 2.05s1.81-.68 1.81-2.05z"/>`,
    ];
    return svgNumberedCirclePaths[stepCount];
};
const getComponentCss$m = (state, disabled, theme) => {
    const { primaryColor, hoverColor, disabledColor } = getThemedColors(theme);
    const { primaryColor: primaryColorDark, hoverColor: hoverColorDark, disabledColor: disabledColorDark, } = getThemedColors('dark');
    const isStateCurrent = state === 'current';
    const isStateCurrentOrUndefined = !state || isStateCurrent;
    const isDisabled = !state || disabled;
    return getCss({
        '@global': {
            ':host': {
                ...(isStateCurrentOrUndefined &&
                    Array.from(Array(9)).reduce((result, _, i) => ({
                        ...result,
                        [`&(:nth-of-type(${i + 1})) $button::before`]: {
                            backgroundImage: getInlineSVGBackgroundImage(getSVGPath(i, {
                                primaryColor,
                                invertedBaseColor: getInvertedThemedColors(theme).primaryColor,
                                disabledColor,
                            }, isStateCurrent)),
                            ...prefersColorSchemeDarkMediaQuery(theme, {
                                backgroundImage: getInlineSVGBackgroundImage(getSVGPath(i, {
                                    primaryColor: primaryColorDark,
                                    invertedBaseColor: getInvertedThemedColors('dark').primaryColor,
                                    disabledColor: disabledColorDark,
                                }, isStateCurrent)),
                            }),
                        },
                    }), {})),
                ...addImportantToEachRule({
                    fontSize: 'inherit',
                    ...hostHiddenStyles,
                    '&(:not(:last-of-type))': {
                        marginInlineEnd: spacingFluidXSmall,
                    },
                }),
            },
            button: {
                display: 'flex',
                position: 'relative',
                gap: '3px',
                color: isDisabled ? disabledColor : primaryColor,
                padding: '4px 10px 4px 6px',
                margin: 0, // Removes default button margin on safari 15
                background: 0,
                border: 0,
                ...textSmallStyle,
                fontSize: 'inherit',
                width: 'max-content',
                cursor: isDisabled ? 'not-allowed' : 'pointer',
                borderRadius: borderRadiusSmall,
                ...(isStateCurrent && {
                    ...frostedGlassStyle,
                    background: hoverColor,
                }),
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    color: isDisabled ? disabledColorDark : primaryColorDark,
                    ...(isStateCurrent && {
                        background: hoverColorDark,
                    }),
                }),
                ...(!isDisabled &&
                    hoverMediaQuery({
                        transition: getTransition('background-color'),
                        '&:hover': {
                            ...frostedGlassStyle,
                            background: hoverColor,
                            ...prefersColorSchemeDarkMediaQuery(theme, {
                                background: hoverColorDark,
                            }),
                        },
                    })),
                ...(isStateCurrentOrUndefined && {
                    // counter
                    // Pseudo element is needed to center the counter to the text, as it is not working optimal directly on the button
                    '&::before': {
                        content: '""',
                        height: fontLineHeight,
                        width: fontLineHeight,
                    },
                }),
                ...getFocusJssStyle(theme, { offset: '-2px' }),
            },
        },
        ...(!isStateCurrentOrUndefined && {
            // complete / warning icons via icon component
            icon: {
                height: fontLineHeight,
                width: fontLineHeight,
            },
        }),
        'sr-only': getHiddenTextJssStyle(),
    });
};

const getComponentCss$l = (size) => {
    return getCss({
        '@global': {
            ':host': {
                display: 'block',
                ...addImportantToEachRule({
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
        },
        scroller: {
            ...textSmallStyle,
            ...buildResponsiveStyles(size, (s) => ({ fontSize: fontSizeText[s] })),
        },
    });
};

const getColors$1 = (checked, disabled, loading, theme) => {
    const { primaryColor, contrastMediumColor, successColor, successColorDarken, disabledColor } = getThemedColors(theme);
    const { backgroundColor: lightThemeBackgroundColor } = getThemedColors('light');
    const { canvasColor, canvasTextColor } = getHighContrastColors();
    const checkedColor = isHighContrastMode ? canvasTextColor : successColor;
    const disabledOrLoadingColor = isDisabledOrLoading(disabled, loading) && disabledColor;
    return {
        buttonBorderColor: disabledOrLoadingColor || (checked ? checkedColor : contrastMediumColor),
        buttonBorderColorHover: checked ? (isHighContrastMode ? primaryColor : successColorDarken) : primaryColor,
        buttonBackgroundColor: checked ? disabledOrLoadingColor || checkedColor : 'transparent',
        buttonBackgroundColorHover: checked ? (isHighContrastMode ? checkedColor : successColorDarken) : 'transparent',
        toggleBackgroundColor: (loading && 'transparent') ||
            (disabled && !checked && disabledColor) ||
            (checked
                ? isHighContrastMode
                    ? canvasColor
                    : lightThemeBackgroundColor
                : isHighContrastMode
                    ? canvasTextColor
                    : primaryColor),
        toggleBackgroundColorHover: checked
            ? lightThemeBackgroundColor
            : isHighContrastMode
                ? canvasTextColor
                : primaryColor,
        textColor: disabledOrLoadingColor || primaryColor,
    };
};
const getComponentCss$k = (alignLabel, hideLabel, stretch, checked, disabled, loading, theme) => {
    const { buttonBorderColor, buttonBorderColorHover, buttonBackgroundColor, buttonBackgroundColorHover, toggleBackgroundColor, toggleBackgroundColorHover, textColor, } = getColors$1(checked, disabled, loading, theme);
    const { buttonBorderColor: buttonBorderColorDark, buttonBorderColorHover: buttonBorderColorHoverDark, buttonBackgroundColor: buttonBackgroundColorDark, buttonBackgroundColorHover: buttonBackgroundColorHoverDark, toggleBackgroundColor: toggleBackgroundColorDark, toggleBackgroundColorHover: toggleBackgroundColorHoverDark, textColor: textColorDark, } = getColors$1(checked, disabled, loading, 'dark');
    return getCss({
        '@global': {
            ':host': {
                ...buildResponsiveStyles(stretch, (stretchValue) => ({
                    display: stretchValue ? 'flex' : 'inline-flex',
                })),
                ...addImportantToEachRule({
                    outline: 0, // custom element is able to delegate the focus
                    gap: spacingStaticSmall,
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                    ...buildResponsiveStyles(stretch, (stretchValue) => ({
                        justifyContent: stretchValue ? 'space-between' : 'flex-start',
                        width: stretchValue ? '100%' : 'auto', // prevents adjusting its size when used as flex or grid child
                        ...(!stretchValue && { verticalAlign: 'top' }),
                    })),
                }),
            },
            button: {
                display: 'flex',
                alignItems: 'center',
                flexShrink: 0,
                width: '48px',
                height: '28px',
                boxSizing: 'border-box',
                border: `${borderWidthBase} solid ${buttonBorderColor}`,
                borderRadius: '14px',
                backgroundColor: buttonBackgroundColor,
                cursor: isDisabledOrLoading(disabled, loading) ? 'not-allowed' : 'pointer',
                transition: `${getTransition('background-color')}, ${getTransition('border-color')}, ${getTransition('color')}`,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    borderColor: buttonBorderColorDark,
                    backgroundColor: buttonBackgroundColorDark,
                }),
                margin: 0, // Removes default button margin on safari 15
                padding: 0,
                WebkitAppearance: 'none', // iOS safari
                appearance: 'none',
                ...(!isDisabledOrLoading(disabled, loading) &&
                    hoverMediaQuery({
                        '&:hover': {
                            borderColor: buttonBorderColorHover,
                            backgroundColor: buttonBackgroundColorHover,
                            ...prefersColorSchemeDarkMediaQuery(theme, {
                                borderColor: buttonBorderColorHoverDark,
                                backgroundColor: buttonBackgroundColorHoverDark,
                            }),
                            '& .toggle': {
                                backgroundColor: toggleBackgroundColorHover,
                                ...prefersColorSchemeDarkMediaQuery(theme, {
                                    backgroundColor: toggleBackgroundColorHoverDark,
                                }),
                            },
                        },
                    })),
                ...getFocusJssStyle(theme),
            },
            label: {
                ...textSmallStyle,
                minWidth: 0, // prevents flex child to overflow max available parent size
                minHeight: 0, // prevents flex child to overflow max available parent size
                cursor: isDisabledOrLoading(disabled, loading) ? 'not-allowed' : 'pointer',
                color: textColor,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    color: textColorDark,
                }),
                ...mergeDeep(buildResponsiveStyles(alignLabel, (alignLabelValue) => ({
                    // TODO: we should remove 'left' here and map the value in the component class already to 'start' but might be difficult due to breakpoint customizable prop value
                    order: alignLabelValue === 'left' || alignLabelValue === 'start' ? -1 : 0,
                })), buildResponsiveStyles(hideLabel, (isHidden) => getHiddenTextJssStyle(isHidden, {
                    paddingTop: '2px', // currently, line-height of textSmall doesn't match height of switch
                }))),
            },
        },
        toggle: {
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            width: '20px',
            height: '20px',
            borderRadius: '50%',
            backgroundColor: toggleBackgroundColor,
            transition: `${getTransition('background-color')}, ${getTransition('transform')}`,
            transform: `translate3d(${checked ? '22px' : '2px'}, 0, 0)`,
            '&:dir(rtl)': {
                transform: `translate3d(${checked ? '-22px' : '-2px'}, 0, 0)`,
            },
            ...prefersColorSchemeDarkMediaQuery(theme, {
                backgroundColor: toggleBackgroundColorDark,
            }),
        },
        ...(loading && {
            spinner: {
                width: '28px',
                height: '28px',
            },
        }),
        // .loading
        ...getFunctionalComponentLoadingMessageStyles(),
    });
};

const getComponentCss$j = () => {
    return getCss({
        '@global': {
            ':host': {
                display: 'table-row-group',
                ...addImportantToEachRule(hostHiddenStyles),
            },
        },
    });
};

const getComponentCss$i = (multiline) => {
    return getCss({
        '@global': {
            ':host': {
                display: 'table-cell',
                verticalAlign: 'middle',
                ...addImportantToEachRule({
                    padding: spacingFluidSmall,
                    margin: 0,
                    whiteSpace: multiline ? 'normal' : 'nowrap',
                    ...hostHiddenStyles,
                }),
            },
        },
    });
};

const isDirectionAsc = (dir) => dir === 'asc';
const isSortable = (active, direction) => {
    return active !== undefined && direction !== undefined;
};

const cssVariableTableHoverColor = '--p-internal-table-hover-color';
const cssVariableTableBorderColor = '--p-internal-table-border-color';
const cssVariableTableHeadCellIconFilter = '--p-internal-table-head-cell-icon-filter';
const getComponentCss$h = (theme) => {
    const { primaryColor, hoverColor, contrastLowColor } = doGetThemedColors(theme);
    const { primaryColor: primaryColorDark, hoverColor: hoverColorDark, contrastLowColor: contrastLowColorDark, } = doGetThemedColors('dark');
    return getCss({
        '@global': {
            ':host': {
                display: 'block',
                ...addImportantToEachRule({
                    ...textSmallStyle,
                    color: primaryColor,
                    textAlign: 'start',
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                    ...prefersColorSchemeDarkMediaQuery(theme, {
                        color: primaryColorDark,
                    }),
                }),
            },
            '::slotted(*)': addImportantToEachRule({
                [cssVariableTableHoverColor]: hoverColor,
                [cssVariableTableBorderColor]: contrastLowColor,
                [cssVariableTableHeadCellIconFilter]: isThemeDark(theme) ? 'invert(100%)' : 'none',
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    [cssVariableTableHoverColor]: hoverColorDark,
                    [cssVariableTableBorderColor]: contrastLowColorDark,
                    [cssVariableTableHeadCellIconFilter]: 'invert(100%)',
                }),
                ...(isHighContrastMode &&
                    getSchemedHighContrastMediaQuery({
                        [cssVariableTableHeadCellIconFilter]: 'none',
                    }, {
                        [cssVariableTableHeadCellIconFilter]: 'invert(100%)',
                    })),
            }),
        },
        caption: {
            marginBottom: spacingFluidMedium,
        },
        table: {
            display: 'table',
            borderCollapse: 'collapse',
            width: '100%',
            whiteSpace: 'nowrap', // shouldn't be inherited for caption, that's why it's defined here
        },
    });
};

const { hoverColor } = getThemedColors('light'); // hover color and focus color are the same for light and dark
const buttonBeforeOffsetVertical = '-2px';
const buttonBeforeOffsetHorizontal = '-4px';
const getComponentCss$g = (active, direction, hideLabel, multiline) => {
    const sortable = isSortable(active, direction);
    return getCss({
        '@global': {
            ':host': {
                display: 'table-cell',
                ...addImportantToEachRule({
                    padding: `2px ${spacingFluidSmall} ${spacingFluidSmall}`,
                    verticalAlign: 'bottom',
                    whiteSpace: multiline ? 'normal' : 'nowrap',
                    ...hostHiddenStyles,
                }),
            },
            ...(sortable
                ? {
                    button: {
                        position: 'relative',
                        display: 'flex',
                        gap: spacingStaticXSmall,
                        width: 'auto',
                        margin: 0, // Removes default button margin on safari 15
                        padding: 0,
                        font: 'inherit',
                        color: 'inherit',
                        alignItems: 'flex-end',
                        WebkitAppearance: 'none', // iOS safari
                        appearance: 'none',
                        background: 'transparent',
                        textAlign: 'start',
                        border: 0,
                        zIndex: 0,
                        cursor: 'pointer',
                        // TODO: re-think if ::before is still needed
                        '&::before': {
                            content: '""',
                            position: 'absolute',
                            inset: `${buttonBeforeOffsetVertical} ${buttonBeforeOffsetHorizontal}`,
                            borderRadius: borderRadiusSmall,
                            zIndex: -1, // needed so that text behind element is selectable and/or visible
                            transition: getTransition('background-color'),
                        },
                        ...hoverMediaQuery({
                            '&:hover, &:focus-visible': {
                                '& .icon': {
                                    opacity: 1,
                                },
                            },
                            '&:hover::before': {
                                ...frostedGlassStyle,
                                backgroundColor: hoverColor,
                            },
                        }),
                        // TODO: to be future proof, we need to pass theme parameter
                        ...getFocusJssStyle('light', { pseudo: true, offset: '-2px' }),
                    },
                }
                : hideLabel && {
                    span: {
                        ...getHiddenTextJssStyle(),
                        display: 'block',
                        border: 0,
                    },
                }),
        },
        ...(sortable && {
            icon: {
                transition: getTransition('opacity'),
                opacity: active ? 1 : 0,
                transform: `rotate3d(0,0,1,${isDirectionAsc(direction) ? 0 : 180}deg)`,
                transformOrigin: '50% 50%', // for iOS
                filter: `var(${cssVariableTableHeadCellIconFilter})`,
            },
        }),
    });
};

const getComponentCss$f = () => {
    return getCss({
        '@global': {
            ':host': {
                display: 'table-row',
                ...addImportantToEachRule(hostHiddenStyles),
            },
        },
    });
};

const getComponentCss$e = () => {
    return getCss({
        '@global': {
            ':host': {
                display: 'table-header-group',
                ...addImportantToEachRule({
                    fontSize: fontSizeTextXSmall,
                    lineHeight: fontLineHeight,
                    fontWeight: fontWeightSemiBold,
                    ...hostHiddenStyles,
                }),
            },
        },
    });
};

const getComponentCss$d = () => {
    return getCss({
        '@global': {
            ':host': {
                display: 'table-row',
                ...addImportantToEachRule({
                    borderTop: `1px solid var(${cssVariableTableBorderColor})`,
                    borderBottom: `1px solid var(${cssVariableTableBorderColor})`,
                    transition: getTransition('background'),
                    ...hostHiddenStyles,
                    ...hoverMediaQuery({
                        '&(:hover)': {
                            // ...frostedGlassStyle, // will result in not smooth transition when applied
                            background: `var(${cssVariableTableHoverColor})`,
                        },
                    }),
                }),
            },
        },
    });
};

const scrollerAnimatedCssClass = 'scroller--animated';
const targetSelectors = ['a', 'button'];
const transformSelector = (selector) => targetSelectors.map((tag) => selector.replace(/\[role]/g, tag)).join();
const getComponentCss$c = (size, weight, theme) => {
    const { primaryColor, hoverColor } = getThemedColors(theme);
    const { primaryColor: primaryColorDark, hoverColor: hoverColorDark } = getThemedColors('dark');
    const barJssStyle = {
        position: 'absolute',
        height: '2px',
        left: 0,
        ...(isHighContrastMode
            ? {
                background: getHighContrastColors().canvasTextColor,
            }
            : {
                background: primaryColor,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    background: primaryColorDark,
                }),
            }),
    };
    return getCss({
        '@global': {
            ':host': {
                display: 'block',
                ...addImportantToEachRule({
                    position: 'relative',
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            ...addImportantToEachRule({
                '::slotted': {
                    // TODO: produces duplicated css code in SSR context, we should try to make use of multiple selector like
                    //  `::slotted(:is(a,button))`.
                    ...getFocusJssStyle(theme, { slotted: 'a', offset: '1px' }),
                    ...getFocusJssStyle(theme, { slotted: 'button', offset: '1px' }),
                },
                // would be nice to use shared selector like '::slotted([role])'
                // but this doesn't work reliably when rendering in browser
                [transformSelector('::slotted([role])')]: {
                    ...getResetInitialStylesForSlottedAnchor,
                    display: 'inline-block',
                    position: 'relative',
                    margin: '0 0 4px 0',
                    verticalAlign: 'top',
                    // TODO: can we use `all: 'inherit'` instead?
                    fontFamily: 'inherit',
                    fontStyle: 'inherit',
                    fontVariant: 'inherit',
                    fontWeight: 'inherit',
                    fontSize: 'inherit',
                    lineHeight: 'inherit',
                    whiteSpace: 'nowrap',
                    boxSizing: 'border-box',
                    WebkitAppearance: 'none', // iOS safari
                    appearance: 'none',
                    outlineOffset: '1px',
                    textDecoration: 'none',
                    textAlign: 'start',
                    border: 0,
                    color: primaryColor,
                    cursor: 'pointer',
                    borderRadius: borderRadiusSmall,
                    zIndex: 0, // needed for ::before pseudo element to be visible
                    ...prefersColorSchemeDarkMediaQuery(theme, {
                        color: primaryColorDark,
                    }),
                    ...hoverMediaQuery({
                        '&::before': {
                            content: '""',
                            position: 'absolute',
                            inset: '-2px -4px',
                            borderRadius: borderRadiusSmall,
                            zIndex: -1, // Stack the pseudo-element behind the button to avoid overlay of frosted-glass effect with label text
                            transition: getTransition('background-color'),
                        },
                    }),
                },
                ...hoverMediaQuery({
                    [transformSelector('::slotted([role]:hover)::before')]: {
                        ...frostedGlassStyle,
                        background: hoverColor,
                        ...prefersColorSchemeDarkMediaQuery(theme, {
                            background: hoverColorDark,
                        }),
                    },
                }),
                // basic invisible bar, that will be delayed via transition: visibility
                [transformSelector('::slotted([role])::after')]: {
                    content: '""',
                    visibility: 'hidden',
                },
                // visible bar for selected tab
                [transformSelector('::slotted([role][aria-selected="true"])::after, ::slotted([role][aria-current="true"])::after')]: {
                    ...barJssStyle,
                    right: '0px',
                    bottom: isHighContrastMode ? '-4px' : '-6px',
                    visibility: 'inherit',
                },
                [transformSelector('::slotted([role]:not(:last-child))')]: {
                    marginInlineEnd: spacingStaticMedium,
                },
            }),
        },
        scroller: {
            ...textSmallStyle,
            fontWeight: getFontWeight(weight),
            ...buildResponsiveStyles(size, (s) => ({ fontSize: fontSizeText[s] })),
        },
        // conditionally applied and removed based on if activeTabIndex exists
        [scrollerAnimatedCssClass]: {
            ['& ' +
                transformSelector('::slotted([role][aria-selected="true"])::after, ::slotted([role][aria-current="true"])::after')]: {
                transition: addImportantToRule(`visibility 0s linear var(${cssVariableTransitionDuration}, ${motionDurationModerate})`), // bar appears after transition
            },
        },
        // moving bar
        bar: {
            ...barJssStyle,
            width: 0, // actual width and transform is set via inline css
            bottom: isHighContrastMode ? '0' : '-2px',
            visibility: 'inherit',
            transition: `${getTransition('transform', 'moderate')}, ${getTransition('width', 'moderate')}`,
            animation: `$hide 0s var(${cssVariableAnimationDuration},0.5s) forwards`, // auto hide bar after transition, needs to be a little longer in Safari
        },
        '@keyframes hide': {
            to: {
                visibility: 'hidden',
            },
        },
    });
};

const getComponentCss$b = (theme) => {
    const { primaryColor } = getThemedColors(theme);
    const { primaryColor: primaryColorDark } = getThemedColors('dark');
    return getCss({
        '@global': {
            ':host': {
                display: 'block',
                ...addImportantToEachRule({
                    color: primaryColor, // enables color inheritance for e.g. slotted anchor
                    borderRadius: '2px',
                    ...hostHiddenStyles,
                    ...prefersColorSchemeDarkMediaQuery(theme, {
                        color: primaryColorDark,
                    }),
                    ...getFocusJssStyle(theme, { slotted: true }),
                }),
            },
        },
    });
};

const getComponentCss$a = () => {
    return getCss({
        '@global': {
            ':host': {
                display: 'block',
                ...addImportantToEachRule({
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
        },
        root: {
            marginBottom: '8px',
        },
    });
};

const getThemedBackgroundColor = (tagColor, themedColors) => {
    const colorMap = {
        'background-base': themedColors.backgroundColor,
        'background-surface': themedColors.backgroundSurfaceColor,
        primary: themedColors.primaryColor,
        'notification-info-soft': themedColors.infoSoftColor,
        'notification-warning-soft': themedColors.warningSoftColor,
        'notification-success-soft': themedColors.successSoftColor,
        'notification-error-soft': themedColors.errorSoftColor,
    };
    return colorMap[tagColor];
};

const getComponentCss$9 = (color, hasLabel, theme) => {
    const themedColors = getThemedColors(theme);
    const themedColorsDark = getThemedColors('dark');
    const { primaryColor, hoverColor, contrastHighColor } = themedColors;
    const { primaryColor: primaryColorDark, hoverColor: hoverColorDark, contrastHighColor: contrastHighColorDark, } = themedColorsDark;
    const backgroundColor = getThemedBackgroundColor(color, themedColors);
    const backgroundColorDark = getThemedBackgroundColor(color, themedColorsDark);
    return getCss({
        '@global': {
            ':host': {
                display: 'inline-block',
                verticalAlign: 'top',
                ...addImportantToEachRule({
                    outline: 0,
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            button: {
                display: 'flex',
                position: 'relative',
                alignItems: 'center',
                gap: '12px',
                minHeight: '54px',
                padding: '4px 12px',
                margin: 0, // Removes default button margin on safari 15
                borderRadius: borderRadiusSmall,
                border: 0,
                cursor: 'pointer',
                background: backgroundColor,
                color: primaryColor,
                textAlign: 'start',
                ...textSmallStyle,
                ...(isHighContrastMode && {
                    // TODO: using border would increase the dimension but using outline interferes with the focus style
                    outline: '1px solid transparent',
                }),
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    background: backgroundColorDark,
                    color: primaryColorDark,
                }),
                ...hoverMediaQuery({
                    '&:hover > .icon': {
                        backgroundColor: hoverColor,
                        ...prefersColorSchemeDarkMediaQuery(theme, {
                            backgroundColor: hoverColorDark,
                        }),
                    },
                }),
                ...getFocusJssStyle(theme),
            },
        },
        ...(hasLabel && {
            label: {
                display: 'block',
                marginBottom: '-4px',
                color: contrastHighColor,
                fontSize: fontSizeTextXSmall,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    color: contrastHighColorDark,
                }),
            },
        }),
        icon: {
            padding: '4px',
            marginInlineEnd: '-2px', // compensate white space of svg icon and optimize visual alignment
            transition: getTransition('background-color'),
            borderRadius: borderRadiusSmall,
        },
        'sr-only': getHiddenTextJssStyle(),
    });
};

const getThemedBackgroundHoverColor = (tagColor, themedColors, theme) => {
    const isDark = isThemeDark(theme);
    const keySuffix = isDark ? 'Lighten' : 'Darken';
    const colorMap = {
        'background-base': themedColors[`backgroundColor${keySuffix}`],
        'background-surface': themedColors[`backgroundSurfaceColor${keySuffix}`],
        primary: isDark ? themedColors.contrastHighColorLighten : themedColors.contrastHighColor,
        'notification-info-soft': themedColors[`infoSoftColor${keySuffix}`],
        'notification-success-soft': themedColors[`successSoftColor${keySuffix}`],
        'notification-error-soft': themedColors[`errorSoftColor${keySuffix}`],
        'notification-warning-soft': themedColors[`warningSoftColor${keySuffix}`],
    };
    return colorMap[tagColor];
};

const getColors = (themedColors, tagColor, theme) => {
    const { primaryColor } = tagColor === 'primary' ? getInvertedThemedColors(theme) : themedColors;
    return {
        primaryColor,
        backgroundColor: getThemedBackgroundColor(tagColor, themedColors),
        backgroundHoverColor: getThemedBackgroundHoverColor(tagColor, themedColors, theme),
    };
};
const getComponentCss$8 = (tagColor, isFocusable, theme) => {
    const themedColors = getThemedColors(theme);
    const themedColorsDark = getThemedColors('dark');
    const { primaryColor, backgroundColor, backgroundHoverColor } = getColors(themedColors, tagColor, theme);
    const { primaryColor: primaryColorDark, backgroundColor: backgroundColorDark, backgroundHoverColor: backgroundHoverColorDark, } = getColors(themedColorsDark, tagColor, 'dark');
    return getCss({
        '@global': {
            ':host': {
                display: 'inline-flex',
                verticalAlign: 'top',
                whiteSpace: 'nowrap',
                ...addImportantToEachRule({
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            span: {
                display: 'flex',
                gap: '2px',
                alignItems: 'center',
                position: 'relative',
                padding: '4px 9px',
                borderRadius: borderRadiusSmall,
                background: backgroundColor,
                color: primaryColor,
                font: textXSmallStyle.font,
                ...(isHighContrastMode && {
                    outline: '1px solid transparent',
                }),
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    background: backgroundColorDark,
                    color: primaryColorDark,
                }),
                ...(isFocusable &&
                    hoverMediaQuery({
                        transition: getTransition('background-color'),
                        '&:hover': {
                            background: backgroundHoverColor,
                            ...prefersColorSchemeDarkMediaQuery(theme, {
                                background: backgroundHoverColorDark,
                            }),
                        },
                    })),
            },
            '::slotted': addImportantToEachRule({
                '&(a),&(button)': {
                    ...getResetInitialStylesForSlottedAnchor,
                    display: 'inline',
                    position: 'static',
                    textDecoration: 'underline',
                    cursor: 'pointer',
                    font: 'inherit',
                    color: 'inherit',
                    WebkitAppearance: 'none', // iOS safari
                    appearance: 'none',
                    border: 0,
                    textAlign: 'start',
                },
                '&(a)::before,&(button)::before': {
                    content: '""',
                    position: 'absolute',
                    inset: 0,
                    borderRadius: '4px',
                },
                ...getFocusJssStyle(theme, { slotted: 'a', pseudo: true }),
                ...getFocusJssStyle(theme, { slotted: 'button', pseudo: true }),
                '&(br)': {
                    display: 'none',
                },
            }),
        },
        icon: {
            marginInlineStart: '-2px', // compensate white space of svg icon and optimize visual alignment
            alignSelf: 'flex-start',
            ...(['neutral-contrast-high', 'primary'].includes(tagColor) && {
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    filter: 'invert(1)',
                }),
            }),
        },
    });
};

const isType = (inputType, typeToValidate) => inputType === typeToValidate;
// eslint-disable-next-line no-underscore-dangle
const _hasShowPickerSupport = () => {
    return (hasDocument &&
        'showPicker' in HTMLInputElement.prototype &&
        // TODO: it would be better to determinate support by checking for existence of "calendar-picker-indicator"
        !!window.navigator.userAgent.match(/chrome|chromium|crios|edg/i));
};
const hasShowPickerSupport = _hasShowPickerSupport();
const showCustomCalendarOrTimeIndicator = (isCalendar, isTime) => {
    return hasShowPickerSupport && (isCalendar || isTime);
};

const cssVariableInputPaddingStart = '--p-internal-text-field-input-padding-start';
const cssVariableInputPaddingEnd = '--p-internal-text-field-input-padding-end';
const getComponentCss$7 = (isDisabled, hideLabel, state, hasUnitOrVisibleCounter, unitPosition, inputType, showPasswordToggle, isWithinForm, hasSubmitButton, theme) => {
    const isSearch = isType(inputType, 'search');
    const isPassword = isType(inputType, 'password');
    const isNumber = isType(inputType, 'number');
    const isCalendar = isType(inputType, 'date') || isType(inputType, 'week') || isType(inputType, 'month');
    const isTime = isType(inputType, 'time');
    const isSearchOrPassword = isSearch || (isPassword && showPasswordToggle);
    const isSearchWithoutFormOrSubmitButton = isSearch && (!isWithinForm || !hasSubmitButton);
    const isSearchWithForm = isSearch && isWithinForm;
    const isCalendarOrTimeWithCustomIndicator = showCustomCalendarOrTimeIndicator(isCalendar, isTime);
    return getCss({
        '@global': {
            ':host': {
                display: 'block',
                ...addImportantToEachRule({
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            // ::slotted(input)
            ...addImportantToEachRule({
                ...getSlottedTextFieldTextareaSelectStyles('input', state, false, theme, {
                    gridArea: '1/1/1/-1',
                    padding: `${formElementPaddingVertical} ${formElementPaddingHorizontal}`,
                    paddingInlineStart: `var(${cssVariableInputPaddingStart})`, // iOS Safari 14.5 can't handle padding-inline shorthand with css variables
                    paddingInlineEnd: `var(${cssVariableInputPaddingEnd})`, // iOS Safari 14.5 can't handle padding-inline shorthand with css variables
                    // TODO: move into getSlottedTextFieldTextareaSelectStyles()
                    ...(isNumber && {
                        MozAppearance: 'textfield', // hides up/down spin button for Firefox
                    }),
                    ...((isCalendar || isTime) && {
                        // for native placeholder color in safari, background has to be a special value, `transparent` or `rgba(0,0,0,0)` won't work
                        // this works nice for `theme="light"`, but for `theme="dark"` placeholder appears blue which is still better
                        // than having invisible dots or colons for data/time or not seeing the value at all after selection
                        // found on https://browserstrangeness.bitbucket.io/css_hacks.html#safari
                        '@supports (-webkit-hyphens: none)': {
                            background: 'rgba(0,0,1,0)',
                            color: isThemeDark(theme) ? getThemedColors(theme).primaryColor : 'initial',
                        },
                    }),
                }),
                // TODO: move into getSlottedTextFieldTextareaSelectStyles()
                '::slotted': {
                    '&(input:-internal-autofill-selected),&(input:-internal-autofill-previewed),&(input:-webkit-autofill),&(input:-webkit-autofill:focus)': {
                        WebkitBackgroundClip: 'padding-box', // reset webkit autofill styles
                    },
                },
            }),
        },
        root: {
            [cssVariableInputPaddingStart]: isSearchWithoutFormOrSubmitButton
                ? getCalculatedFormElementPaddingHorizontal(1)
                : formElementPaddingHorizontal,
            [cssVariableInputPaddingEnd]: isSearchOrPassword || isCalendarOrTimeWithCustomIndicator
                ? getCalculatedFormElementPaddingHorizontal(isSearchWithForm && hasSubmitButton ? 2 : 1)
                : formElementPaddingHorizontal,
            display: 'grid',
            gap: spacingStaticXSmall,
        },
        wrapper: {
            display: 'grid',
            gridTemplateColumns: `${formElementLayeredSafeZone} auto minmax(0, 1fr) auto auto ${formElementLayeredSafeZone}`,
        },
        ...((isSearchOrPassword || isCalendarOrTimeWithCustomIndicator) && {
            // TODO: extract for multi-select, select-wrapper and text-field (not gridArea and placeSelf) like done for unit class
            button: {
                gridArea: '1/5',
                placeSelf: 'center',
                padding: formButtonOrIconPadding,
                // TODO: maybe we should render hidden button conditionally, needs to be checked if a11y compliant
                '&:not([hidden])~.button': {
                    gridArea: '1/4',
                },
            },
        }),
        ...(isSearchWithoutFormOrSubmitButton && {
            // TODO: extract for multi-select, select-wrapper and text-field (not gridArea and placeSelf) like done for unit class
            icon: {
                gridArea: '1/2',
                placeSelf: 'center',
                padding: formButtonOrIconPadding,
                pointerEvents: 'none',
            },
        }),
        ...(hasUnitOrVisibleCounter && {
            'unit-counter': {
                ...getUnitCounterJssStyle(isDisabled, theme),
                gridArea: `1/${unitPosition === 'suffix' ? 5 : 1}/1/${unitPosition === 'suffix' ? 7 : 3}`,
                placeSelf: 'center',
                paddingInline: unitPosition === 'suffix'
                    ? `${formElementLayeredGap} calc(${formElementPaddingHorizontal} + ${borderWidthBase})`
                    : `calc(${formElementPaddingHorizontal} + ${borderWidthBase}) ${formElementLayeredGap}`, // padding needed for correct input padding synchronisation
            },
        }),
        // TODO: maybe we should extract it as functional component too
        'sr-only': getHiddenTextJssStyle(),
        // .label / .required
        ...getFunctionalComponentLabelStyles(isDisabled, hideLabel, theme),
        // .message
        ...getFunctionalComponentStateMessageStyles(theme, state),
    });
};

/** @deprecated */
const isListTypeOrdered = (type) => type !== 'unordered';
const isListTypeNumbered = (type) => type === 'numbered';

const cssVariablePaddingTop = '--p-internal-text-list-padding-top';
const cssVariablePaddingBottom = '--p-internal-text-list-padding-bottom';
const cssVariablePseudoSpace = '--p-internal-text-list-pseudo-space';
const cssVariableUnorderedGridColumn = '--p-internal-text-list-unordered-grid-column';
const cssVariableUnorderedPseudoContent = '--p-internal-text-list-unordered-pseudo-content';
const cssVariableOrderedGridColumn = '--p-internal-text-list-ordered-grid-column';
const cssVariableOrderedPseudoSuffix = '--p-internal-text-list-ordered-pseudo-suffix';
const counter = 'p-text-list-counter';
const getComponentCss$6 = (type, theme) => {
    const isOrderedList = isListTypeOrdered(type);
    return getCss({
        '@global': {
            ':host': {
                display: 'block',
                ...addImportantToEachRule({
                    counterReset: counter,
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            'ol,ul': {
                ...textSmallStyle,
                margin: 0,
                padding: `var(${cssVariablePaddingTop},0) 0 var(${cssVariablePaddingBottom},0) 0`,
                listStyleType: 'none',
                color: getThemedColors(theme).primaryColor,
                ...prefersColorSchemeDarkMediaQuery(theme, {
                    color: getThemedColors('dark').primaryColor,
                }),
            },
            // css selector for text-list-item
            '::slotted(*)': addImportantToEachRule({
                [cssVariablePaddingTop]: spacingStaticXSmall, // padding top for nested list
                [cssVariablePaddingBottom]: spacingStaticMedium, // padding bottom for nested list, TODO: in case it's last root list item with a nested list it would result in outer spacing which is not desired
                [cssVariablePseudoSpace]: isOrderedList
                    ? `var(${cssVariableOrderedGridColumn},1.5rem)`
                    : `var(${cssVariableUnorderedGridColumn},.375rem)`,
                '&::before': isOrderedList
                    ? {
                        content: `counters(${counter},'.',${isListTypeNumbered(type) ? 'decimal' : 'lower-latin'}) var(${cssVariableOrderedPseudoSuffix},'.')`,
                        counterIncrement: counter,
                        justifySelf: 'flex-end',
                        whiteSpace: 'nowrap',
                    }
                    : {
                        content: `var(${cssVariableUnorderedPseudoContent},'')`,
                    },
            }),
        },
    });
};

const getComponentCss$5 = () => {
    return getCss({
        '@global': {
            ':host': {
                display: 'grid',
                ...addImportantToEachRule({
                    gridTemplateColumns: `var(${cssVariablePseudoSpace}) 1fr`,
                    columnGap: spacingStaticMedium,
                    font: 'inherit', // ensures style can't be overwritten from outside
                    color: 'inherit', // ensures style can't be overwritten from outside
                    ...hostHiddenStyles,
                }),
            },
            ...addImportantToEachRule({
                '::slotted(*)': {
                    [cssVariableUnorderedGridColumn]: '.625rem', // reserves space for ::before (nested unordered list)
                    [cssVariableUnorderedPseudoContent]: '""', // custom ::before char "" (nested unordered list)
                    [cssVariableOrderedGridColumn]: '2rem', // reserves space for ::before (nested ordered list)
                    [cssVariableOrderedPseudoSuffix]: '""', // don't show ::before suffix "." (nested ordered list)
                },
                '::slotted(*:last-child)': {
                    gridColumn: 2,
                },
            }),
        },
    });
};

const TEXT_TAGS = ['p', 'span', 'div', 'address', 'blockquote', 'figcaption', 'cite', 'time', 'legend'];

const sizeMap = {
    'xx-small': fontSizeTextXXSmall,
    'x-small': fontSizeTextXSmall,
    small: fontSizeTextSmall,
    medium: fontSizeTextMedium,
    large: fontSizeTextLarge,
    'x-large': fontSizeTextXLarge,
};
const getComponentCss$4 = (size, weight, align, color, ellipsis, theme) => {
    return getCss({
        '@global': {
            ':host': {
                display: 'block',
                ...addImportantToEachRule({
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            '::slotted': {
                [TEXT_TAGS.map((i) => `&(${i})`).join()]: addImportantToEachRule(getTypographySlottedJssStyle()),
            },
        },
        root: getTypographyRootJssStyle(textSmallStyle, buildResponsiveStyles(size, (sizeValue) => ({
            fontSize: sizeValue === 'inherit' ? sizeValue : sizeMap[sizeValue],
            fontWeight: getFontWeight(weight),
        })), align, color, ellipsis, theme),
    });
};

const getComponentCss$3 = (isDisabled, hideLabel, state, hasCounter, theme) => {
    return getCss({
        '@global': {
            ':host': {
                display: 'block',
                ...addImportantToEachRule({
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            // ::slotted(textarea)
            ...mergeDeep(addImportantToEachRule(getSlottedTextFieldTextareaSelectStyles('textarea', state, false, theme, {
                gridArea: '1/1',
                // TODO: move into getSlottedTextFieldTextareaSelectStyles()
                font: textSmallStyle.font, // to override line-height
                // TODO: move into getSlottedTextFieldTextareaSelectStyles()
                padding: hasCounter
                    ? `12px ${formElementPaddingHorizontal} ${spacingStaticLarge}`
                    : `12px ${formElementPaddingHorizontal}`,
            })), {
                // TODO: is it possible to move into getSlottedTextFieldTextareaSelectStyles()?
                '::slotted(textarea)': {
                    height: 'auto', // removes !important from getBaseChildStyles
                    minHeight: '200px', // min-height should be overridable
                    resize: 'vertical', // overridable, too
                },
            }),
        },
        root: {
            display: 'grid',
            gap: spacingStaticXSmall,
        },
        wrapper: {
            display: 'grid',
        },
        ...(hasCounter && {
            counter: {
                ...getUnitCounterJssStyle(isDisabled, theme),
                gridArea: '1/1',
                placeSelf: 'flex-end',
                padding: `6px calc(${formElementPaddingHorizontal} + ${borderWidthBase})`,
            },
            // TODO: maybe we should extract it as functional component too
            'sr-only': getHiddenTextJssStyle(),
        }),
        // .label / .required
        ...getFunctionalComponentLabelStyles(isDisabled, hideLabel, theme),
        // .message
        ...getFunctionalComponentStateMessageStyles(theme, state),
    });
};

const cssVariablePositionBottom = '--p-toast-position-bottom'; // CSS custom property exposed as public interface
const cssVariablePositionBottomInternal = '--p-internal-toast-position-bottom';
const ANIMATION_DURATION = motionDurationModerate;
const duration = ANIMATION_DURATION;
const getKeyframes = (direction, outsideStyle) => {
    const insideStyle = { opacity: 1, transform: 'translate3d(0,0,0)' };
    return direction === 'in'
        ? {
            from: outsideStyle,
            to: insideStyle,
        }
        : {
            from: insideStyle,
            to: outsideStyle,
        };
};
const getKeyframesMobile = (direction, bottomVar) => getKeyframes(direction, {
    opacity: 0,
    transform: `translate3d(0,calc(var(${bottomVar}) + 100%),0)`, // space before and after "+" is crucial
});
const toastCloseClassName = 'close';
const getComponentCss$1 = () => {
    return getCss({
        '@global': {
            ':host': addImportantToEachRule({
                position: 'fixed',
                insetInline: gridExtendedOffsetBase,
                // Needs a not overridable internal css variable to cover default position depending on viewport size and to handle animation properly.
                // In addition, a public css variable can be passed to overwrite the default position.
                [cssVariablePositionBottomInternal]: `var(${cssVariablePositionBottom}, 56px)`,
                bottom: `var(${cssVariablePositionBottomInternal})`,
                zIndex: TOAST_Z_INDEX,
                [getMediaQueryMin('s')]: {
                    insetInline: '64px auto',
                    maxWidth: 'min(42rem, calc(100vw - 64px * 2))',
                    [cssVariablePositionBottomInternal]: `var(${cssVariablePositionBottom}, 64px)`,
                    bottom: `var(${cssVariablePositionBottomInternal})`,
                },
                ...colorSchemeStyles,
                ...hostHiddenStyles,
            }),
            '@keyframes in': getKeyframesMobile('in', cssVariablePositionBottomInternal),
            '@keyframes out': getKeyframesMobile('out', cssVariablePositionBottomInternal),
        },
        hydrated: {
            animation: `${duration} $in ${motionEasingIn} forwards`,
        },
        [toastCloseClassName]: {
            animation: addImportantToRule(`${ANIMATION_DURATION} $out ${motionEasingOut} forwards`),
        },
    });
};

const getComponentCss = (size, theme) => {
    return getCss({
        '@global': {
            ':host': {
                position: 'relative',
                display: 'inline-block',
                verticalAlign: 'top',
                ...addImportantToEachRule({
                    outline: 0,
                    maxWidth: '100%',
                    maxHeight: '100%',
                    boxSizing: 'content-box', // needed for correct height calculation when padding is set on host (e.g. custom click area)
                    ...(size !== 'inherit' && {
                        height: 'clamp(0.63rem, 0.42vw + 0.5rem, 1rem)',
                        // workaround for Safari to optimize image rendering
                        '@supports (height: round(down, 1px, 1px))': {
                            height: 'round(down, clamp(0.63rem, 0.42vw + 0.5rem, 1rem), 1px)',
                        },
                    }),
                    ...colorSchemeStyles,
                    ...hostHiddenStyles,
                }),
            },
            'a, svg': {
                display: 'block',
                maxWidth: '100%',
                maxHeight: '100%',
                height: 'inherit',
            },
            a: {
                textDecoration: 'none',
                '&::before': {
                    // needs to be defined always to have correct custom click area
                    content: '""',
                    position: 'absolute',
                    inset: 0,
                    borderRadius: '1px',
                },
                ...getFocusJssStyle('light', { pseudo: true }), // TODO: we need to support theme
            },
            svg: isHighContrastMode
                ? {
                    fill: getHighContrastColors().canvasTextColor,
                }
                : {
                    fill: getThemedColors(theme).primaryColor,
                    ...prefersColorSchemeDarkMediaQuery(theme, {
                        fill: getThemedColors('dark').primaryColor,
                    }),
                },
        },
    });
};

export { getComponentCss$15 as getAccordionCss, getComponentCss$14 as getBannerCss, getComponentCss$10 as getButtonCss, getComponentCss$13 as getButtonGroupCss, getComponentCss$12 as getButtonPureCss, getComponentCss$11 as getButtonTileCss, getComponentCss$$ as getCarouselCss, getComponentCss$_ as getCheckboxWrapperCss, getComponentCss$Z as getContentWrapperCss, getComponentCss$Y as getCrestCss, getComponentCss$X as getDisplayCss, getComponentCss$W as getDividerCss, getComponentCss$U as getFieldsetCss, getComponentCss$V as getFieldsetWrapperCss, getComponentCss$S as getFlexCss, getComponentCss$T as getFlexItemCss, getComponentCss$P as getFlyoutCss, getComponentCss$R as getFlyoutNavigationCss, getComponentCss$Q as getFlyoutNavigationItemCss, getFunctionalComponentLabelStyles, getFunctionalComponentLoadingMessageStyles, getFunctionalComponentRequiredStyles, getFunctionalComponentStateMessageStyles, getComponentCss$N as getGridCss, getComponentCss$O as getGridItemCss, getComponentCss$M as getHeadingCss, getComponentCss$L as getHeadlineCss, getComponentCss$K as getIconCss, getComponentCss$J as getInlineNotificationCss, getComponentCss$H as getLinkCss, getComponentCss$I as getLinkPureCss, getComponentCss$H as getLinkSocialCss, getComponentCss$E as getLinkTileCss, getComponentCss$G as getLinkTileModelSignatureCss, getComponentCss$F as getLinkTileProductCss, getComponentCss$D as getMarqueCss, getComponentCss$C as getModalCss, getComponentCss$B as getModelSignatureCss, getComponentCss$z as getMultiSelectCss, getComponentCss$A as getMultiSelectOptionCss, getComponentCss$y as getPaginationCss, getComponentCss$x as getPinCodeCss, getComponentCss$w as getPopoverCss, getComponentCss$v as getRadioButtonWrapperCss, getComponentCss$u as getScrollerCss, getComponentCss$s as getSegmentedControlCss, getComponentCss$t as getSegmentedControlItemCss, getComponentCss$o as getSelectCss, getComponentCss$p as getSelectOptionCss, getComponentCss$q as getSelectWrapperCss, getComponentCss$r as getSelectWrapperDropdownCss, getComponentCss$n as getSpinnerCss, getComponentCss$l as getStepperHorizontalCss, getComponentCss$m as getStepperHorizontalItemCss, getComponentCss$k as getSwitchCss, getComponentCss$j as getTableBodyCss, getComponentCss$i as getTableCellCss, getComponentCss$h as getTableCss, getComponentCss$g as getTableHeadCellCss, getComponentCss$e as getTableHeadCss, getComponentCss$f as getTableHeadRowCss, getComponentCss$d as getTableRowCss, getComponentCss$c as getTabsBarCss, getComponentCss$a as getTabsCss, getComponentCss$b as getTabsItemCss, getComponentCss$8 as getTagCss, getComponentCss$9 as getTagDismissibleCss, getComponentCss$4 as getTextCss, getComponentCss$7 as getTextFieldWrapperCss, getComponentCss$6 as getTextListCss, getComponentCss$5 as getTextListItemCss, getComponentCss$3 as getTextareaWrapperCss, getComponentCss$1 as getToastCss, getComponentCss as getWordmarkCss };
