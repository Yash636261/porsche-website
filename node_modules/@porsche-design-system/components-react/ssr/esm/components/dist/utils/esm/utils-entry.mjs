function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

var _typeof$1 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isBrowser = (typeof window === "undefined" ? "undefined" : _typeof$1(window)) === "object" && (typeof document === "undefined" ? "undefined" : _typeof$1(document)) === 'object' && document.nodeType === 9;

function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}

function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : String(i);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

var plainObjectConstrurctor = {}.constructor;
function cloneStyle(style) {
  if (style == null || typeof style !== 'object') return style;
  if (Array.isArray(style)) return style.map(cloneStyle);
  if (style.constructor !== plainObjectConstrurctor) return style;
  var newStyle = {};

  for (var name in style) {
    newStyle[name] = cloneStyle(style[name]);
  }

  return newStyle;
}

/**
 * Create a rule instance.
 */

function createRule(name, decl, options) {
  if (name === void 0) {
    name = 'unnamed';
  }

  var jss = options.jss;
  var declCopy = cloneStyle(decl);
  var rule = jss.plugins.onCreateRule(name, declCopy, options);
  if (rule) return rule; // It is an at-rule and it has no instance.

  if (name[0] === '@') ;

  return null;
}

var join$1 = function join(value, by) {
  var result = '';

  for (var i = 0; i < value.length; i++) {
    // Remove !important from the value, it will be readded later.
    if (value[i] === '!important') break;
    if (result) result += by;
    result += value[i];
  }

  return result;
};
/**
 * Converts JSS array value to a CSS string.
 *
 * `margin: [['5px', '10px']]` > `margin: 5px 10px;`
 * `border: ['1px', '2px']` > `border: 1px, 2px;`
 * `margin: [['5px', '10px'], '!important']` > `margin: 5px 10px !important;`
 * `color: ['red', !important]` > `color: red !important;`
 */


var toCssValue = function toCssValue(value) {
  if (!Array.isArray(value)) return value;
  var cssValue = ''; // Support space separated values via `[['5px', '10px']]`.

  if (Array.isArray(value[0])) {
    for (var i = 0; i < value.length; i++) {
      if (value[i] === '!important') break;
      if (cssValue) cssValue += ', ';
      cssValue += join$1(value[i], ' ');
    }
  } else cssValue = join$1(value, ', '); // Add !important, because it was ignored.


  if (value[value.length - 1] === '!important') {
    cssValue += ' !important';
  }

  return cssValue;
};

function getWhitespaceSymbols(options) {
  if (options && options.format === false) {
    return {
      linebreak: '',
      space: ''
    };
  }

  return {
    linebreak: '\n',
    space: ' '
  };
}

/**
 * Indent a string.
 * http://jsperf.com/array-join-vs-for
 */

function indentStr(str, indent) {
  var result = '';

  for (var index = 0; index < indent; index++) {
    result += '  ';
  }

  return result + str;
}
/**
 * Converts a Rule to CSS string.
 */


function toCss(selector, style, options) {
  if (options === void 0) {
    options = {};
  }

  var result = '';
  if (!style) return result;
  var _options = options,
      _options$indent = _options.indent,
      indent = _options$indent === void 0 ? 0 : _options$indent;
  var fallbacks = style.fallbacks;

  if (options.format === false) {
    indent = -Infinity;
  }

  var _getWhitespaceSymbols = getWhitespaceSymbols(options),
      linebreak = _getWhitespaceSymbols.linebreak,
      space = _getWhitespaceSymbols.space;

  if (selector) indent++; // Apply fallbacks first.

  if (fallbacks) {
    // Array syntax {fallbacks: [{prop: value}]}
    if (Array.isArray(fallbacks)) {
      for (var index = 0; index < fallbacks.length; index++) {
        var fallback = fallbacks[index];

        for (var prop in fallback) {
          var value = fallback[prop];

          if (value != null) {
            if (result) result += linebreak;
            result += indentStr(prop + ":" + space + toCssValue(value) + ";", indent);
          }
        }
      }
    } else {
      // Object syntax {fallbacks: {prop: value}}
      for (var _prop in fallbacks) {
        var _value = fallbacks[_prop];

        if (_value != null) {
          if (result) result += linebreak;
          result += indentStr(_prop + ":" + space + toCssValue(_value) + ";", indent);
        }
      }
    }
  }

  for (var _prop2 in style) {
    var _value2 = style[_prop2];

    if (_value2 != null && _prop2 !== 'fallbacks') {
      if (result) result += linebreak;
      result += indentStr(_prop2 + ":" + space + toCssValue(_value2) + ";", indent);
    }
  } // Allow empty style in this case, because properties will be added dynamically.


  if (!result && !options.allowEmpty) return result; // When rule is being stringified before selector was defined.

  if (!selector) return result;
  indent--;
  if (result) result = "" + linebreak + result + linebreak;
  return indentStr("" + selector + space + "{" + result, indent) + indentStr('}', indent);
}

var escapeRegex = /([[\].#*$><+~=|^:(),"'`\s])/g;
var nativeEscape = typeof CSS !== 'undefined' && CSS.escape;
var escape = (function (str) {
  return nativeEscape ? nativeEscape(str) : str.replace(escapeRegex, '\\$1');
});

var BaseStyleRule =
/*#__PURE__*/
function () {
  function BaseStyleRule(key, style, options) {
    this.type = 'style';
    this.isProcessed = false;
    var sheet = options.sheet,
        Renderer = options.Renderer;
    this.key = key;
    this.options = options;
    this.style = style;
    if (sheet) this.renderer = sheet.renderer;else if (Renderer) this.renderer = new Renderer();
  }
  /**
   * Get or set a style property.
   */


  var _proto = BaseStyleRule.prototype;

  _proto.prop = function prop(name, value, options) {
    // It's a getter.
    if (value === undefined) return this.style[name]; // Don't do anything if the value has not changed.

    var force = options ? options.force : false;
    if (!force && this.style[name] === value) return this;
    var newValue = value;

    if (!options || options.process !== false) {
      newValue = this.options.jss.plugins.onChangeValue(value, name, this);
    }

    var isEmpty = newValue == null || newValue === false;
    var isDefined = name in this.style; // Value is empty and wasn't defined before.

    if (isEmpty && !isDefined && !force) return this; // We are going to remove this value.

    var remove = isEmpty && isDefined;
    if (remove) delete this.style[name];else this.style[name] = newValue; // Renderable is defined if StyleSheet option `link` is true.

    if (this.renderable && this.renderer) {
      if (remove) this.renderer.removeProperty(this.renderable, name);else this.renderer.setProperty(this.renderable, name, newValue);
      return this;
    }

    var sheet = this.options.sheet;

    if (sheet && sheet.attached) ;

    return this;
  };

  return BaseStyleRule;
}();
var StyleRule =
/*#__PURE__*/
function (_BaseStyleRule) {
  _inheritsLoose(StyleRule, _BaseStyleRule);

  function StyleRule(key, style, options) {
    var _this;

    _this = _BaseStyleRule.call(this, key, style, options) || this;
    var selector = options.selector,
        scoped = options.scoped,
        sheet = options.sheet,
        generateId = options.generateId;

    if (selector) {
      _this.selectorText = selector;
    } else if (scoped !== false) {
      _this.id = generateId(_assertThisInitialized(_assertThisInitialized(_this)), sheet);
      _this.selectorText = "." + escape(_this.id);
    }

    return _this;
  }
  /**
   * Set selector string.
   * Attention: use this with caution. Most browsers didn't implement
   * selectorText setter, so this may result in rerendering of entire Style Sheet.
   */


  var _proto2 = StyleRule.prototype;

  /**
   * Apply rule to an element inline.
   */
  _proto2.applyTo = function applyTo(renderable) {
    var renderer = this.renderer;

    if (renderer) {
      var json = this.toJSON();

      for (var prop in json) {
        renderer.setProperty(renderable, prop, json[prop]);
      }
    }

    return this;
  }
  /**
   * Returns JSON representation of the rule.
   * Fallbacks are not supported.
   * Useful for inline styles.
   */
  ;

  _proto2.toJSON = function toJSON() {
    var json = {};

    for (var prop in this.style) {
      var value = this.style[prop];
      if (typeof value !== 'object') json[prop] = value;else if (Array.isArray(value)) json[prop] = toCssValue(value);
    }

    return json;
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto2.toString = function toString(options) {
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;
    var opts = link ? _extends({}, options, {
      allowEmpty: true
    }) : options;
    return toCss(this.selectorText, this.style, opts);
  };

  _createClass(StyleRule, [{
    key: "selector",
    set: function set(selector) {
      if (selector === this.selectorText) return;
      this.selectorText = selector;
      var renderer = this.renderer,
          renderable = this.renderable;
      if (!renderable || !renderer) return;
      var hasChanged = renderer.setSelector(renderable, selector); // If selector setter is not implemented, rerender the rule.

      if (!hasChanged) {
        renderer.replaceRule(renderable, this);
      }
    }
    /**
     * Get selector string.
     */
    ,
    get: function get() {
      return this.selectorText;
    }
  }]);

  return StyleRule;
}(BaseStyleRule);
var pluginStyleRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    if (key[0] === '@' || options.parent && options.parent.type === 'keyframes') {
      return null;
    }

    return new StyleRule(key, style, options);
  }
};

var defaultToStringOptions = {
  indent: 1,
  children: true
};
var atRegExp = /@([\w-]+)/;
/**
 * Conditional rule for @media, @supports
 */

var ConditionalRule =
/*#__PURE__*/
function () {
  function ConditionalRule(key, styles, options) {
    this.type = 'conditional';
    this.isProcessed = false;
    this.key = key;
    var atMatch = key.match(atRegExp);
    this.at = atMatch ? atMatch[1] : 'unknown'; // Key might contain a unique suffix in case the `name` passed by user was duplicate.

    this.query = options.name || "@" + this.at;
    this.options = options;
    this.rules = new RuleList(_extends({}, options, {
      parent: this
    }));

    for (var name in styles) {
      this.rules.add(name, styles[name]);
    }

    this.rules.process();
  }
  /**
   * Get a rule.
   */


  var _proto = ConditionalRule.prototype;

  _proto.getRule = function getRule(name) {
    return this.rules.get(name);
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Create and register rule, run plugins.
   */
  ;

  _proto.addRule = function addRule(name, style, options) {
    var rule = this.rules.add(name, style, options);
    if (!rule) return null;
    this.options.jss.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Replace rule, run plugins.
   */
  ;

  _proto.replaceRule = function replaceRule(name, style, options) {
    var newRule = this.rules.replace(name, style, options);
    if (newRule) this.options.jss.plugins.onProcessRule(newRule);
    return newRule;
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    if (options === void 0) {
      options = defaultToStringOptions;
    }

    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;

    if (options.indent == null) options.indent = defaultToStringOptions.indent;
    if (options.children == null) options.children = defaultToStringOptions.children;

    if (options.children === false) {
      return this.query + " {}";
    }

    var children = this.rules.toString(options);
    return children ? this.query + " {" + linebreak + children + linebreak + "}" : '';
  };

  return ConditionalRule;
}();
var keyRegExp = /@container|@media|@supports\s+/;
var pluginConditionalRule = {
  onCreateRule: function onCreateRule(key, styles, options) {
    return keyRegExp.test(key) ? new ConditionalRule(key, styles, options) : null;
  }
};

var defaultToStringOptions$1 = {
  indent: 1,
  children: true
};
var nameRegExp = /@keyframes\s+([\w-]+)/;
/**
 * Rule for @keyframes
 */

var KeyframesRule =
/*#__PURE__*/
function () {
  function KeyframesRule(key, frames, options) {
    this.type = 'keyframes';
    this.at = '@keyframes';
    this.isProcessed = false;
    var nameMatch = key.match(nameRegExp);

    if (nameMatch && nameMatch[1]) {
      this.name = nameMatch[1];
    } else {
      this.name = 'noname';
    }

    this.key = this.type + "-" + this.name;
    this.options = options;
    var scoped = options.scoped,
        sheet = options.sheet,
        generateId = options.generateId;
    this.id = scoped === false ? this.name : escape(generateId(this, sheet));
    this.rules = new RuleList(_extends({}, options, {
      parent: this
    }));

    for (var name in frames) {
      this.rules.add(name, frames[name], _extends({}, options, {
        parent: this
      }));
    }

    this.rules.process();
  }
  /**
   * Generates a CSS string.
   */


  var _proto = KeyframesRule.prototype;

  _proto.toString = function toString(options) {
    if (options === void 0) {
      options = defaultToStringOptions$1;
    }

    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;

    if (options.indent == null) options.indent = defaultToStringOptions$1.indent;
    if (options.children == null) options.children = defaultToStringOptions$1.children;

    if (options.children === false) {
      return this.at + " " + this.id + " {}";
    }

    var children = this.rules.toString(options);
    if (children) children = "" + linebreak + children + linebreak;
    return this.at + " " + this.id + " {" + children + "}";
  };

  return KeyframesRule;
}();
var keyRegExp$1 = /@keyframes\s+/;
var refRegExp$1 = /\$([\w-]+)/g;

var findReferencedKeyframe = function findReferencedKeyframe(val, keyframes) {
  if (typeof val === 'string') {
    return val.replace(refRegExp$1, function (match, name) {
      if (name in keyframes) {
        return keyframes[name];
      }
      return match;
    });
  }

  return val;
};
/**
 * Replace the reference for a animation name.
 */


var replaceRef = function replaceRef(style, prop, keyframes) {
  var value = style[prop];
  var refKeyframe = findReferencedKeyframe(value, keyframes);

  if (refKeyframe !== value) {
    style[prop] = refKeyframe;
  }
};

var pluginKeyframesRule = {
  onCreateRule: function onCreateRule(key, frames, options) {
    return typeof key === 'string' && keyRegExp$1.test(key) ? new KeyframesRule(key, frames, options) : null;
  },
  // Animation name ref replacer.
  onProcessStyle: function onProcessStyle(style, rule, sheet) {
    if (rule.type !== 'style' || !sheet) return style;
    if ('animation-name' in style) replaceRef(style, 'animation-name', sheet.keyframes);
    if ('animation' in style) replaceRef(style, 'animation', sheet.keyframes);
    return style;
  },
  onChangeValue: function onChangeValue(val, prop, rule) {
    var sheet = rule.options.sheet;

    if (!sheet) {
      return val;
    }

    switch (prop) {
      case 'animation':
        return findReferencedKeyframe(val, sheet.keyframes);

      case 'animation-name':
        return findReferencedKeyframe(val, sheet.keyframes);

      default:
        return val;
    }
  }
};

var KeyframeRule =
/*#__PURE__*/
function (_BaseStyleRule) {
  _inheritsLoose(KeyframeRule, _BaseStyleRule);

  function KeyframeRule() {
    return _BaseStyleRule.apply(this, arguments) || this;
  }

  var _proto = KeyframeRule.prototype;

  /**
   * Generates a CSS string.
   */
  _proto.toString = function toString(options) {
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;
    var opts = link ? _extends({}, options, {
      allowEmpty: true
    }) : options;
    return toCss(this.key, this.style, opts);
  };

  return KeyframeRule;
}(BaseStyleRule);
var pluginKeyframeRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    if (options.parent && options.parent.type === 'keyframes') {
      return new KeyframeRule(key, style, options);
    }

    return null;
  }
};

var FontFaceRule =
/*#__PURE__*/
function () {
  function FontFaceRule(key, style, options) {
    this.type = 'font-face';
    this.at = '@font-face';
    this.isProcessed = false;
    this.key = key;
    this.style = style;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */


  var _proto = FontFaceRule.prototype;

  _proto.toString = function toString(options) {
    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;

    if (Array.isArray(this.style)) {
      var str = '';

      for (var index = 0; index < this.style.length; index++) {
        str += toCss(this.at, this.style[index]);
        if (this.style[index + 1]) str += linebreak;
      }

      return str;
    }

    return toCss(this.at, this.style, options);
  };

  return FontFaceRule;
}();
var keyRegExp$2 = /@font-face/;
var pluginFontFaceRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    return keyRegExp$2.test(key) ? new FontFaceRule(key, style, options) : null;
  }
};

var ViewportRule =
/*#__PURE__*/
function () {
  function ViewportRule(key, style, options) {
    this.type = 'viewport';
    this.at = '@viewport';
    this.isProcessed = false;
    this.key = key;
    this.style = style;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */


  var _proto = ViewportRule.prototype;

  _proto.toString = function toString(options) {
    return toCss(this.key, this.style, options);
  };

  return ViewportRule;
}();
var pluginViewportRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    return key === '@viewport' || key === '@-ms-viewport' ? new ViewportRule(key, style, options) : null;
  }
};

var SimpleRule =
/*#__PURE__*/
function () {
  function SimpleRule(key, value, options) {
    this.type = 'simple';
    this.isProcessed = false;
    this.key = key;
    this.value = value;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */
  // eslint-disable-next-line no-unused-vars


  var _proto = SimpleRule.prototype;

  _proto.toString = function toString(options) {
    if (Array.isArray(this.value)) {
      var str = '';

      for (var index = 0; index < this.value.length; index++) {
        str += this.key + " " + this.value[index] + ";";
        if (this.value[index + 1]) str += '\n';
      }

      return str;
    }

    return this.key + " " + this.value + ";";
  };

  return SimpleRule;
}();
var keysMap = {
  '@charset': true,
  '@import': true,
  '@namespace': true
};
var pluginSimpleRule = {
  onCreateRule: function onCreateRule(key, value, options) {
    return key in keysMap ? new SimpleRule(key, value, options) : null;
  }
};

var plugins = [pluginStyleRule, pluginConditionalRule, pluginKeyframesRule, pluginKeyframeRule, pluginFontFaceRule, pluginViewportRule, pluginSimpleRule];

var defaultUpdateOptions = {
  process: true
};
var forceUpdateOptions = {
  force: true,
  process: true
  /**
   * Contains rules objects and allows adding/removing etc.
   * Is used for e.g. by `StyleSheet` or `ConditionalRule`.
   */

};

var RuleList =
/*#__PURE__*/
function () {
  // Rules registry for access by .get() method.
  // It contains the same rule registered by name and by selector.
  // Original styles object.
  // Used to ensure correct rules order.
  function RuleList(options) {
    this.map = {};
    this.raw = {};
    this.index = [];
    this.counter = 0;
    this.options = options;
    this.classes = options.classes;
    this.keyframes = options.keyframes;
  }
  /**
   * Create and register rule.
   *
   * Will not render after Style Sheet was rendered the first time.
   */


  var _proto = RuleList.prototype;

  _proto.add = function add(name, decl, ruleOptions) {
    var _this$options = this.options,
        parent = _this$options.parent,
        sheet = _this$options.sheet,
        jss = _this$options.jss,
        Renderer = _this$options.Renderer,
        generateId = _this$options.generateId,
        scoped = _this$options.scoped;

    var options = _extends({
      classes: this.classes,
      parent: parent,
      sheet: sheet,
      jss: jss,
      Renderer: Renderer,
      generateId: generateId,
      scoped: scoped,
      name: name,
      keyframes: this.keyframes,
      selector: undefined
    }, ruleOptions); // When user uses .createStyleSheet(), duplicate names are not possible, but
    // `sheet.addRule()` opens the door for any duplicate rule name. When this happens
    // we need to make the key unique within this RuleList instance scope.


    var key = name;

    if (name in this.raw) {
      key = name + "-d" + this.counter++;
    } // We need to save the original decl before creating the rule
    // because cache plugin needs to use it as a key to return a cached rule.


    this.raw[key] = decl;

    if (key in this.classes) {
      // E.g. rules inside of @media container
      options.selector = "." + escape(this.classes[key]);
    }

    var rule = createRule(key, decl, options);
    if (!rule) return null;
    this.register(rule);
    var index = options.index === undefined ? this.index.length : options.index;
    this.index.splice(index, 0, rule);
    return rule;
  }
  /**
   * Replace rule.
   * Create a new rule and remove old one instead of overwriting
   * because we want to invoke onCreateRule hook to make plugins work.
   */
  ;

  _proto.replace = function replace(name, decl, ruleOptions) {
    var oldRule = this.get(name);
    var oldIndex = this.index.indexOf(oldRule);

    if (oldRule) {
      this.remove(oldRule);
    }

    var options = ruleOptions;
    if (oldIndex !== -1) options = _extends({}, ruleOptions, {
      index: oldIndex
    });
    return this.add(name, decl, options);
  }
  /**
   * Get a rule by name or selector.
   */
  ;

  _proto.get = function get(nameOrSelector) {
    return this.map[nameOrSelector];
  }
  /**
   * Delete a rule.
   */
  ;

  _proto.remove = function remove(rule) {
    this.unregister(rule);
    delete this.raw[rule.key];
    this.index.splice(this.index.indexOf(rule), 1);
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.index.indexOf(rule);
  }
  /**
   * Run `onProcessRule()` plugins on every rule.
   */
  ;

  _proto.process = function process() {
    var plugins = this.options.jss.plugins; // We need to clone array because if we modify the index somewhere else during a loop
    // we end up with very hard-to-track-down side effects.

    this.index.slice(0).forEach(plugins.onProcessRule, plugins);
  }
  /**
   * Register a rule in `.map`, `.classes` and `.keyframes` maps.
   */
  ;

  _proto.register = function register(rule) {
    this.map[rule.key] = rule;

    if (rule instanceof StyleRule) {
      this.map[rule.selector] = rule;
      if (rule.id) this.classes[rule.key] = rule.id;
    } else if (rule instanceof KeyframesRule && this.keyframes) {
      this.keyframes[rule.name] = rule.id;
    }
  }
  /**
   * Unregister a rule.
   */
  ;

  _proto.unregister = function unregister(rule) {
    delete this.map[rule.key];

    if (rule instanceof StyleRule) {
      delete this.map[rule.selector];
      delete this.classes[rule.key];
    } else if (rule instanceof KeyframesRule) {
      delete this.keyframes[rule.name];
    }
  }
  /**
   * Update the function values with a new data.
   */
  ;

  _proto.update = function update() {
    var name;
    var data;
    var options;

    if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {
      name = arguments.length <= 0 ? undefined : arguments[0];
      data = arguments.length <= 1 ? undefined : arguments[1];
      options = arguments.length <= 2 ? undefined : arguments[2];
    } else {
      data = arguments.length <= 0 ? undefined : arguments[0];
      options = arguments.length <= 1 ? undefined : arguments[1];
      name = null;
    }

    if (name) {
      this.updateOne(this.get(name), data, options);
    } else {
      for (var index = 0; index < this.index.length; index++) {
        this.updateOne(this.index[index], data, options);
      }
    }
  }
  /**
   * Execute plugins, update rule props.
   */
  ;

  _proto.updateOne = function updateOne(rule, data, options) {
    if (options === void 0) {
      options = defaultUpdateOptions;
    }

    var _this$options2 = this.options,
        plugins = _this$options2.jss.plugins,
        sheet = _this$options2.sheet; // It is a rules container like for e.g. ConditionalRule.

    if (rule.rules instanceof RuleList) {
      rule.rules.update(data, options);
      return;
    }

    var style = rule.style;
    plugins.onUpdate(data, rule, sheet, options); // We rely on a new `style` ref in case it was mutated during onUpdate hook.

    if (options.process && style && style !== rule.style) {
      // We need to run the plugins in case new `style` relies on syntax plugins.
      plugins.onProcessStyle(rule.style, rule, sheet); // Update and add props.

      for (var prop in rule.style) {
        var nextValue = rule.style[prop];
        var prevValue = style[prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.

        if (nextValue !== prevValue) {
          rule.prop(prop, nextValue, forceUpdateOptions);
        }
      } // Remove props.


      for (var _prop in style) {
        var _nextValue = rule.style[_prop];
        var _prevValue = style[_prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.

        if (_nextValue == null && _nextValue !== _prevValue) {
          rule.prop(_prop, null, forceUpdateOptions);
        }
      }
    }
  }
  /**
   * Convert rules to a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    var str = '';
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;

    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;

    for (var index = 0; index < this.index.length; index++) {
      var rule = this.index[index];
      var css = rule.toString(options); // No need to render an empty rule.

      if (!css && !link) continue;
      if (str) str += linebreak;
      str += css;
    }

    return str;
  };

  return RuleList;
}();

var StyleSheet =
/*#__PURE__*/
function () {
  function StyleSheet(styles, options) {
    this.attached = false;
    this.deployed = false;
    this.classes = {};
    this.keyframes = {};
    this.options = _extends({}, options, {
      sheet: this,
      parent: this,
      classes: this.classes,
      keyframes: this.keyframes
    });

    if (options.Renderer) {
      this.renderer = new options.Renderer(this);
    }

    this.rules = new RuleList(this.options);

    for (var name in styles) {
      this.rules.add(name, styles[name]);
    }

    this.rules.process();
  }
  /**
   * Attach renderable to the render tree.
   */


  var _proto = StyleSheet.prototype;

  _proto.attach = function attach() {
    if (this.attached) return this;
    if (this.renderer) this.renderer.attach();
    this.attached = true; // Order is important, because we can't use insertRule API if style element is not attached.

    if (!this.deployed) this.deploy();
    return this;
  }
  /**
   * Remove renderable from render tree.
   */
  ;

  _proto.detach = function detach() {
    if (!this.attached) return this;
    if (this.renderer) this.renderer.detach();
    this.attached = false;
    return this;
  }
  /**
   * Add a rule to the current stylesheet.
   * Will insert a rule also after the stylesheet has been rendered first time.
   */
  ;

  _proto.addRule = function addRule(name, decl, options) {
    var queue = this.queue; // Plugins can create rules.
    // In order to preserve the right order, we need to queue all `.addRule` calls,
    // which happen after the first `rules.add()` call.

    if (this.attached && !queue) this.queue = [];
    var rule = this.rules.add(name, decl, options);
    if (!rule) return null;
    this.options.jss.plugins.onProcessRule(rule);

    if (this.attached) {
      if (!this.deployed) return rule; // Don't insert rule directly if there is no stringified version yet.
      // It will be inserted all together when .attach is called.

      if (queue) queue.push(rule);else {
        this.insertRule(rule);

        if (this.queue) {
          this.queue.forEach(this.insertRule, this);
          this.queue = undefined;
        }
      }
      return rule;
    } // We can't add rules to a detached style node.
    // We will redeploy the sheet once user will attach it.


    this.deployed = false;
    return rule;
  }
  /**
   * Replace a rule in the current stylesheet.
   */
  ;

  _proto.replaceRule = function replaceRule(nameOrSelector, decl, options) {
    var oldRule = this.rules.get(nameOrSelector);
    if (!oldRule) return this.addRule(nameOrSelector, decl, options);
    var newRule = this.rules.replace(nameOrSelector, decl, options);

    if (newRule) {
      this.options.jss.plugins.onProcessRule(newRule);
    }

    if (this.attached) {
      if (!this.deployed) return newRule; // Don't replace / delete rule directly if there is no stringified version yet.
      // It will be inserted all together when .attach is called.

      if (this.renderer) {
        if (!newRule) {
          this.renderer.deleteRule(oldRule);
        } else if (oldRule.renderable) {
          this.renderer.replaceRule(oldRule.renderable, newRule);
        }
      }

      return newRule;
    } // We can't replace rules to a detached style node.
    // We will redeploy the sheet once user will attach it.


    this.deployed = false;
    return newRule;
  }
  /**
   * Insert rule into the StyleSheet
   */
  ;

  _proto.insertRule = function insertRule(rule) {
    if (this.renderer) {
      this.renderer.insertRule(rule);
    }
  }
  /**
   * Create and add rules.
   * Will render also after Style Sheet was rendered the first time.
   */
  ;

  _proto.addRules = function addRules(styles, options) {
    var added = [];

    for (var name in styles) {
      var rule = this.addRule(name, styles[name], options);
      if (rule) added.push(rule);
    }

    return added;
  }
  /**
   * Get a rule by name or selector.
   */
  ;

  _proto.getRule = function getRule(nameOrSelector) {
    return this.rules.get(nameOrSelector);
  }
  /**
   * Delete a rule by name.
   * Returns `true`: if rule has been deleted from the DOM.
   */
  ;

  _proto.deleteRule = function deleteRule(name) {
    var rule = typeof name === 'object' ? name : this.rules.get(name);

    if (!rule || // Style sheet was created without link: true and attached, in this case we
    // won't be able to remove the CSS rule from the DOM.
    this.attached && !rule.renderable) {
      return false;
    }

    this.rules.remove(rule);

    if (this.attached && rule.renderable && this.renderer) {
      return this.renderer.deleteRule(rule.renderable);
    }

    return true;
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Deploy pure CSS string to a renderable.
   */
  ;

  _proto.deploy = function deploy() {
    if (this.renderer) this.renderer.deploy();
    this.deployed = true;
    return this;
  }
  /**
   * Update the function values with a new data.
   */
  ;

  _proto.update = function update() {
    var _this$rules;

    (_this$rules = this.rules).update.apply(_this$rules, arguments);

    return this;
  }
  /**
   * Updates a single rule.
   */
  ;

  _proto.updateOne = function updateOne(rule, data, options) {
    this.rules.updateOne(rule, data, options);
    return this;
  }
  /**
   * Convert rules to a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    return this.rules.toString(options);
  };

  return StyleSheet;
}();

var PluginsRegistry =
/*#__PURE__*/
function () {
  function PluginsRegistry() {
    this.plugins = {
      internal: [],
      external: []
    };
    this.registry = {};
  }

  var _proto = PluginsRegistry.prototype;

  /**
   * Call `onCreateRule` hooks and return an object if returned by a hook.
   */
  _proto.onCreateRule = function onCreateRule(name, decl, options) {
    for (var i = 0; i < this.registry.onCreateRule.length; i++) {
      var rule = this.registry.onCreateRule[i](name, decl, options);
      if (rule) return rule;
    }

    return null;
  }
  /**
   * Call `onProcessRule` hooks.
   */
  ;

  _proto.onProcessRule = function onProcessRule(rule) {
    if (rule.isProcessed) return;
    var sheet = rule.options.sheet;

    for (var i = 0; i < this.registry.onProcessRule.length; i++) {
      this.registry.onProcessRule[i](rule, sheet);
    }

    if (rule.style) this.onProcessStyle(rule.style, rule, sheet);
    rule.isProcessed = true;
  }
  /**
   * Call `onProcessStyle` hooks.
   */
  ;

  _proto.onProcessStyle = function onProcessStyle(style, rule, sheet) {
    for (var i = 0; i < this.registry.onProcessStyle.length; i++) {
      rule.style = this.registry.onProcessStyle[i](rule.style, rule, sheet);
    }
  }
  /**
   * Call `onProcessSheet` hooks.
   */
  ;

  _proto.onProcessSheet = function onProcessSheet(sheet) {
    for (var i = 0; i < this.registry.onProcessSheet.length; i++) {
      this.registry.onProcessSheet[i](sheet);
    }
  }
  /**
   * Call `onUpdate` hooks.
   */
  ;

  _proto.onUpdate = function onUpdate(data, rule, sheet, options) {
    for (var i = 0; i < this.registry.onUpdate.length; i++) {
      this.registry.onUpdate[i](data, rule, sheet, options);
    }
  }
  /**
   * Call `onChangeValue` hooks.
   */
  ;

  _proto.onChangeValue = function onChangeValue(value, prop, rule) {
    var processedValue = value;

    for (var i = 0; i < this.registry.onChangeValue.length; i++) {
      processedValue = this.registry.onChangeValue[i](processedValue, prop, rule);
    }

    return processedValue;
  }
  /**
   * Register a plugin.
   */
  ;

  _proto.use = function use(newPlugin, options) {
    if (options === void 0) {
      options = {
        queue: 'external'
      };
    }

    var plugins = this.plugins[options.queue]; // Avoids applying same plugin twice, at least based on ref.

    if (plugins.indexOf(newPlugin) !== -1) {
      return;
    }

    plugins.push(newPlugin);
    this.registry = [].concat(this.plugins.external, this.plugins.internal).reduce(function (registry, plugin) {
      for (var name in plugin) {
        if (name in registry) {
          registry[name].push(plugin[name]);
        }
      }

      return registry;
    }, {
      onCreateRule: [],
      onProcessRule: [],
      onProcessStyle: [],
      onProcessSheet: [],
      onChangeValue: [],
      onUpdate: []
    });
  };

  return PluginsRegistry;
}();

/**
 * Sheets registry to access all instances in one place.
 */

var SheetsRegistry =
/*#__PURE__*/
function () {
  function SheetsRegistry() {
    this.registry = [];
  }

  var _proto = SheetsRegistry.prototype;

  /**
   * Register a Style Sheet.
   */
  _proto.add = function add(sheet) {
    var registry = this.registry;
    var index = sheet.options.index;
    if (registry.indexOf(sheet) !== -1) return;

    if (registry.length === 0 || index >= this.index) {
      registry.push(sheet);
      return;
    } // Find a position.


    for (var i = 0; i < registry.length; i++) {
      if (registry[i].options.index > index) {
        registry.splice(i, 0, sheet);
        return;
      }
    }
  }
  /**
   * Reset the registry.
   */
  ;

  _proto.reset = function reset() {
    this.registry = [];
  }
  /**
   * Remove a Style Sheet.
   */
  ;

  _proto.remove = function remove(sheet) {
    var index = this.registry.indexOf(sheet);
    this.registry.splice(index, 1);
  }
  /**
   * Convert all attached sheets to a CSS string.
   */
  ;

  _proto.toString = function toString(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        attached = _ref.attached,
        options = _objectWithoutPropertiesLoose(_ref, ["attached"]);

    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;

    var css = '';

    for (var i = 0; i < this.registry.length; i++) {
      var sheet = this.registry[i];

      if (attached != null && sheet.attached !== attached) {
        continue;
      }

      if (css) css += linebreak;
      css += sheet.toString(options);
    }

    return css;
  };

  _createClass(SheetsRegistry, [{
    key: "index",

    /**
     * Current highest index number.
     */
    get: function get() {
      return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;
    }
  }]);

  return SheetsRegistry;
}();

/**
 * This is a global sheets registry. Only DomRenderer will add sheets to it.
 * On the server one should use an own SheetsRegistry instance and add the
 * sheets to it, because you need to make sure to create a new registry for
 * each request in order to not leak sheets across requests.
 */

var sheets = new SheetsRegistry();

/* eslint-disable */

/**
 * Now that `globalThis` is available on most platforms
 * (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis#browser_compatibility)
 * we check for `globalThis` first. `globalThis` is necessary for jss
 * to run in Agoric's secure version of JavaScript (SES). Under SES,
 * `globalThis` exists, but `window`, `self`, and `Function('return
 * this')()` are all undefined for security reasons.
 *
 * https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
 */
var globalThis$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' && window.Math === Math ? window : typeof self !== 'undefined' && self.Math === Math ? self : Function('return this')();

var ns = '2f1acc6c3a606b082e5eef5e54414ffb';
if (globalThis$1[ns] == null) globalThis$1[ns] = 0; // Bundle may contain multiple JSS versions at the same time. In order to identify
// the current version with just one short number and use it for classes generation
// we use a counter. Also it is more accurate, because user can manually reevaluate
// the module.

var moduleId = globalThis$1[ns]++;
/**
 * Returns a function which generates unique class names based on counters.
 * When new generator function is created, rule counter is reseted.
 * We need to reset the rule counter for SSR for each request.
 */

var createGenerateId = function createGenerateId(options) {
  if (options === void 0) {
    options = {};
  }

  var ruleCounter = 0;

  var generateId = function generateId(rule, sheet) {
    ruleCounter += 1;

    var jssId = '';
    var prefix = '';

    if (sheet) {
      if (sheet.options.classNamePrefix) {
        prefix = sheet.options.classNamePrefix;
      }

      if (sheet.options.jss.id != null) {
        jssId = String(sheet.options.jss.id);
      }
    }

    if (options.minify) {
      // Using "c" because a number can't be the first char in a class name.
      return "" + (prefix || 'c') + moduleId + jssId + ruleCounter;
    }

    return prefix + rule.key + "-" + moduleId + (jssId ? "-" + jssId : '') + "-" + ruleCounter;
  };

  return generateId;
};

/**
 * Cache the value from the first time a function is called.
 */

var memoize = function memoize(fn) {
  var value;
  return function () {
    if (!value) value = fn();
    return value;
  };
};
/**
 * Get a style property value.
 */


var getPropertyValue = function getPropertyValue(cssRule, prop) {
  try {
    // Support CSSTOM.
    if (cssRule.attributeStyleMap) {
      return cssRule.attributeStyleMap.get(prop);
    }

    return cssRule.style.getPropertyValue(prop);
  } catch (err) {
    // IE may throw if property is unknown.
    return '';
  }
};
/**
 * Set a style property.
 */


var setProperty = function setProperty(cssRule, prop, value) {
  try {
    var cssValue = value;

    if (Array.isArray(value)) {
      cssValue = toCssValue(value);
    } // Support CSSTOM.


    if (cssRule.attributeStyleMap) {
      cssRule.attributeStyleMap.set(prop, cssValue);
    } else {
      var indexOfImportantFlag = cssValue ? cssValue.indexOf('!important') : -1;
      var cssValueWithoutImportantFlag = indexOfImportantFlag > -1 ? cssValue.substr(0, indexOfImportantFlag - 1) : cssValue;
      cssRule.style.setProperty(prop, cssValueWithoutImportantFlag, indexOfImportantFlag > -1 ? 'important' : '');
    }
  } catch (err) {
    // IE may throw if property is unknown.
    return false;
  }

  return true;
};
/**
 * Remove a style property.
 */


var removeProperty = function removeProperty(cssRule, prop) {
  try {
    // Support CSSTOM.
    if (cssRule.attributeStyleMap) {
      cssRule.attributeStyleMap.delete(prop);
    } else {
      cssRule.style.removeProperty(prop);
    }
  } catch (err) {
  }
};
/**
 * Set the selector.
 */


var setSelector = function setSelector(cssRule, selectorText) {
  cssRule.selectorText = selectorText; // Return false if setter was not successful.
  // Currently works in chrome only.

  return cssRule.selectorText === selectorText;
};
/**
 * Gets the `head` element upon the first call and caches it.
 * We assume it can't be null.
 */


var getHead = memoize(function () {
  return document.querySelector('head');
});
/**
 * Find attached sheet with an index higher than the passed one.
 */

function findHigherSheet(registry, options) {
  for (var i = 0; i < registry.length; i++) {
    var sheet = registry[i];

    if (sheet.attached && sheet.options.index > options.index && sheet.options.insertionPoint === options.insertionPoint) {
      return sheet;
    }
  }

  return null;
}
/**
 * Find attached sheet with the highest index.
 */


function findHighestSheet(registry, options) {
  for (var i = registry.length - 1; i >= 0; i--) {
    var sheet = registry[i];

    if (sheet.attached && sheet.options.insertionPoint === options.insertionPoint) {
      return sheet;
    }
  }

  return null;
}
/**
 * Find a comment with "jss" inside.
 */


function findCommentNode(text) {
  var head = getHead();

  for (var i = 0; i < head.childNodes.length; i++) {
    var node = head.childNodes[i];

    if (node.nodeType === 8 && node.nodeValue.trim() === text) {
      return node;
    }
  }

  return null;
}
/**
 * Find a node before which we can insert the sheet.
 */


function findPrevNode(options) {
  var registry = sheets.registry;

  if (registry.length > 0) {
    // Try to insert before the next higher sheet.
    var sheet = findHigherSheet(registry, options);

    if (sheet && sheet.renderer) {
      return {
        parent: sheet.renderer.element.parentNode,
        node: sheet.renderer.element
      };
    } // Otherwise insert after the last attached.


    sheet = findHighestSheet(registry, options);

    if (sheet && sheet.renderer) {
      return {
        parent: sheet.renderer.element.parentNode,
        node: sheet.renderer.element.nextSibling
      };
    }
  } // Try to find a comment placeholder if registry is empty.


  var insertionPoint = options.insertionPoint;

  if (insertionPoint && typeof insertionPoint === 'string') {
    var comment = findCommentNode(insertionPoint);

    if (comment) {
      return {
        parent: comment.parentNode,
        node: comment.nextSibling
      };
    } // If user specifies an insertion point and it can't be found in the document -
  }

  return false;
}
/**
 * Insert style element into the DOM.
 */


function insertStyle(style, options) {
  var insertionPoint = options.insertionPoint;
  var nextNode = findPrevNode(options);

  if (nextNode !== false && nextNode.parent) {
    nextNode.parent.insertBefore(style, nextNode.node);
    return;
  } // Works with iframes and any node types.


  if (insertionPoint && typeof insertionPoint.nodeType === 'number') {
    var insertionPointElement = insertionPoint;
    var parentNode = insertionPointElement.parentNode;
    if (parentNode) parentNode.insertBefore(style, insertionPointElement.nextSibling);
    return;
  }

  getHead().appendChild(style);
}
/**
 * Read jss nonce setting from the page if the user has set it.
 */


var getNonce = memoize(function () {
  var node = document.querySelector('meta[property="csp-nonce"]');
  return node ? node.getAttribute('content') : null;
});

var _insertRule = function insertRule(container, rule, index) {
  try {
    if ('insertRule' in container) {
      container.insertRule(rule, index);
    } // Keyframes rule.
    else if ('appendRule' in container) {
        container.appendRule(rule);
      }
  } catch (err) {
    return false;
  }

  return container.cssRules[index];
};

var getValidRuleInsertionIndex = function getValidRuleInsertionIndex(container, index) {
  var maxIndex = container.cssRules.length; // In case previous insertion fails, passed index might be wrong

  if (index === undefined || index > maxIndex) {
    // eslint-disable-next-line no-param-reassign
    return maxIndex;
  }

  return index;
};

var createStyle = function createStyle() {
  var el = document.createElement('style'); // Without it, IE will have a broken source order specificity if we
  // insert rules after we insert the style tag.
  // It seems to kick-off the source order specificity algorithm.

  el.textContent = '\n';
  return el;
};

var DomRenderer =
/*#__PURE__*/
function () {
  // Will be empty if link: true option is not set, because
  // it is only for use together with insertRule API.
  function DomRenderer(sheet) {
    this.getPropertyValue = getPropertyValue;
    this.setProperty = setProperty;
    this.removeProperty = removeProperty;
    this.setSelector = setSelector;
    this.hasInsertedRules = false;
    this.cssRules = [];
    // There is no sheet when the renderer is used from a standalone StyleRule.
    if (sheet) sheets.add(sheet);
    this.sheet = sheet;

    var _ref = this.sheet ? this.sheet.options : {},
        media = _ref.media,
        meta = _ref.meta,
        element = _ref.element;

    this.element = element || createStyle();
    this.element.setAttribute('data-jss', '');
    if (media) this.element.setAttribute('media', media);
    if (meta) this.element.setAttribute('data-meta', meta);
    var nonce = getNonce();
    if (nonce) this.element.setAttribute('nonce', nonce);
  }
  /**
   * Insert style element into render tree.
   */


  var _proto = DomRenderer.prototype;

  _proto.attach = function attach() {
    // In the case the element node is external and it is already in the DOM.
    if (this.element.parentNode || !this.sheet) return;
    insertStyle(this.element, this.sheet.options); // When rules are inserted using `insertRule` API, after `sheet.detach().attach()`
    // most browsers create a new CSSStyleSheet, except of all IEs.

    var deployed = Boolean(this.sheet && this.sheet.deployed);

    if (this.hasInsertedRules && deployed) {
      this.hasInsertedRules = false;
      this.deploy();
    }
  }
  /**
   * Remove style element from render tree.
   */
  ;

  _proto.detach = function detach() {
    if (!this.sheet) return;
    var parentNode = this.element.parentNode;
    if (parentNode) parentNode.removeChild(this.element); // In the most browsers, rules inserted using insertRule() API will be lost when style element is removed.
    // Though IE will keep them and we need a consistent behavior.

    if (this.sheet.options.link) {
      this.cssRules = [];
      this.element.textContent = '\n';
    }
  }
  /**
   * Inject CSS string into element.
   */
  ;

  _proto.deploy = function deploy() {
    var sheet = this.sheet;
    if (!sheet) return;

    if (sheet.options.link) {
      this.insertRules(sheet.rules);
      return;
    }

    this.element.textContent = "\n" + sheet.toString() + "\n";
  }
  /**
   * Insert RuleList into an element.
   */
  ;

  _proto.insertRules = function insertRules(rules, nativeParent) {
    for (var i = 0; i < rules.index.length; i++) {
      this.insertRule(rules.index[i], i, nativeParent);
    }
  }
  /**
   * Insert a rule into element.
   */
  ;

  _proto.insertRule = function insertRule(rule, index, nativeParent) {
    if (nativeParent === void 0) {
      nativeParent = this.element.sheet;
    }

    if (rule.rules) {
      var parent = rule;
      var latestNativeParent = nativeParent;

      if (rule.type === 'conditional' || rule.type === 'keyframes') {
        var _insertionIndex = getValidRuleInsertionIndex(nativeParent, index); // We need to render the container without children first.


        latestNativeParent = _insertRule(nativeParent, parent.toString({
          children: false
        }), _insertionIndex);

        if (latestNativeParent === false) {
          return false;
        }

        this.refCssRule(rule, _insertionIndex, latestNativeParent);
      }

      this.insertRules(parent.rules, latestNativeParent);
      return latestNativeParent;
    }

    var ruleStr = rule.toString();
    if (!ruleStr) return false;
    var insertionIndex = getValidRuleInsertionIndex(nativeParent, index);

    var nativeRule = _insertRule(nativeParent, ruleStr, insertionIndex);

    if (nativeRule === false) {
      return false;
    }

    this.hasInsertedRules = true;
    this.refCssRule(rule, insertionIndex, nativeRule);
    return nativeRule;
  };

  _proto.refCssRule = function refCssRule(rule, index, cssRule) {
    rule.renderable = cssRule; // We only want to reference the top level rules, deleteRule API doesn't support removing nested rules
    // like rules inside media queries or keyframes

    if (rule.options.parent instanceof StyleSheet) {
      this.cssRules.splice(index, 0, cssRule);
    }
  }
  /**
   * Delete a rule.
   */
  ;

  _proto.deleteRule = function deleteRule(cssRule) {
    var sheet = this.element.sheet;
    var index = this.indexOf(cssRule);
    if (index === -1) return false;
    sheet.deleteRule(index);
    this.cssRules.splice(index, 1);
    return true;
  }
  /**
   * Get index of a CSS Rule.
   */
  ;

  _proto.indexOf = function indexOf(cssRule) {
    return this.cssRules.indexOf(cssRule);
  }
  /**
   * Generate a new CSS rule and replace the existing one.
   */
  ;

  _proto.replaceRule = function replaceRule(cssRule, rule) {
    var index = this.indexOf(cssRule);
    if (index === -1) return false;
    this.element.sheet.deleteRule(index);
    this.cssRules.splice(index, 1);
    return this.insertRule(rule, index);
  }
  /**
   * Get all rules elements.
   */
  ;

  _proto.getRules = function getRules() {
    return this.element.sheet.cssRules;
  };

  return DomRenderer;
}();

var instanceCounter = 0;

var Jss =
/*#__PURE__*/
function () {
  function Jss(options) {
    this.id = instanceCounter++;
    this.version = "10.10.0";
    this.plugins = new PluginsRegistry();
    this.options = {
      id: {
        minify: false
      },
      createGenerateId: createGenerateId,
      Renderer: isBrowser ? DomRenderer : null,
      plugins: []
    };
    this.generateId = createGenerateId({
      minify: false
    });

    for (var i = 0; i < plugins.length; i++) {
      this.plugins.use(plugins[i], {
        queue: 'internal'
      });
    }

    this.setup(options);
  }
  /**
   * Prepares various options, applies plugins.
   * Should not be used twice on the same instance, because there is no plugins
   * deduplication logic.
   */


  var _proto = Jss.prototype;

  _proto.setup = function setup(options) {
    if (options === void 0) {
      options = {};
    }

    if (options.createGenerateId) {
      this.options.createGenerateId = options.createGenerateId;
    }

    if (options.id) {
      this.options.id = _extends({}, this.options.id, options.id);
    }

    if (options.createGenerateId || options.id) {
      this.generateId = this.options.createGenerateId(this.options.id);
    }

    if (options.insertionPoint != null) this.options.insertionPoint = options.insertionPoint;

    if ('Renderer' in options) {
      this.options.Renderer = options.Renderer;
    } // eslint-disable-next-line prefer-spread


    if (options.plugins) this.use.apply(this, options.plugins);
    return this;
  }
  /**
   * Create a Style Sheet.
   */
  ;

  _proto.createStyleSheet = function createStyleSheet(styles, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        index = _options.index;

    if (typeof index !== 'number') {
      index = sheets.index === 0 ? 0 : sheets.index + 1;
    }

    var sheet = new StyleSheet(styles, _extends({}, options, {
      jss: this,
      generateId: options.generateId || this.generateId,
      insertionPoint: this.options.insertionPoint,
      Renderer: this.options.Renderer,
      index: index
    }));
    this.plugins.onProcessSheet(sheet);
    return sheet;
  }
  /**
   * Detach the Style Sheet and remove it from the registry.
   */
  ;

  _proto.removeStyleSheet = function removeStyleSheet(sheet) {
    sheet.detach();
    sheets.remove(sheet);
    return this;
  }
  /**
   * Create a rule without a Style Sheet.
   * [Deprecated] will be removed in the next major version.
   */
  ;

  _proto.createRule = function createRule$1(name, style, options) {
    if (style === void 0) {
      style = {};
    }

    if (options === void 0) {
      options = {};
    }

    // Enable rule without name for inline styles.
    if (typeof name === 'object') {
      return this.createRule(undefined, name, style);
    }

    var ruleOptions = _extends({}, options, {
      name: name,
      jss: this,
      Renderer: this.options.Renderer
    });

    if (!ruleOptions.generateId) ruleOptions.generateId = this.generateId;
    if (!ruleOptions.classes) ruleOptions.classes = {};
    if (!ruleOptions.keyframes) ruleOptions.keyframes = {};

    var rule = createRule(name, style, ruleOptions);

    if (rule) this.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Register plugin. Passed function will be invoked with a rule instance.
   */
  ;

  _proto.use = function use() {
    var _this = this;

    for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
      plugins[_key] = arguments[_key];
    }

    plugins.forEach(function (plugin) {
      _this.plugins.use(plugin);
    });
    return this;
  };

  return Jss;
}();

var createJss = function createJss(options) {
  return new Jss(options);
};

/**
 * SheetsManager is like a WeakMap which is designed to count StyleSheet
 * instances and attach/detach automatically.
 * Used in react-jss.
 */

var SheetsManager =
/*#__PURE__*/
function () {
  function SheetsManager() {
    this.length = 0;
    this.sheets = new WeakMap();
  }

  var _proto = SheetsManager.prototype;

  _proto.get = function get(key) {
    var entry = this.sheets.get(key);
    return entry && entry.sheet;
  };

  _proto.add = function add(key, sheet) {
    if (this.sheets.has(key)) return;
    this.length++;
    this.sheets.set(key, {
      sheet: sheet,
      refs: 0
    });
  };

  _proto.manage = function manage(key) {
    var entry = this.sheets.get(key);

    if (entry) {
      if (entry.refs === 0) {
        entry.sheet.attach();
      }

      entry.refs++;
      return entry.sheet;
    }
    return undefined;
  };

  _proto.unmanage = function unmanage(key) {
    var entry = this.sheets.get(key);

    if (entry) {
      if (entry.refs > 0) {
        entry.refs--;
        if (entry.refs === 0) entry.sheet.detach();
      }
    }
  };

  _createClass(SheetsManager, [{
    key: "size",
    get: function get() {
      return this.length;
    }
  }]);

  return SheetsManager;
}();

/**
* Export a constant indicating if this browser has CSSTOM support.
* https://developers.google.com/web/updates/2018/03/cssom
*/
var hasCSSTOMSupport = typeof CSS === 'object' && CSS != null && 'number' in CSS;

/**
 * Extracts a styles object with only props that contain function values.
 */
function getDynamicStyles(styles) {
  var to = null;

  for (var key in styles) {
    var value = styles[key];
    var type = typeof value;

    if (type === 'function') {
      if (!to) to = {};
      to[key] = value;
    } else if (type === 'object' && value !== null && !Array.isArray(value)) {
      var extracted = getDynamicStyles(value);

      if (extracted) {
        if (!to) to = {};
        to[key] = extracted;
      }
    }
  }

  return to;
}

/**
 * A better abstraction over CSS.
 *
 * @copyright Oleg Isonen (Slobodskoi) / Isonen 2014-present
 * @website https://github.com/cssinjs/jss
 * @license MIT
 */
var index = createJss();

var jss_esm = /*#__PURE__*/Object.freeze({
  __proto__: null,
  RuleList: RuleList,
  SheetsManager: SheetsManager,
  SheetsRegistry: SheetsRegistry,
  create: createJss,
  createGenerateId: createGenerateId,
  createRule: createRule,
  default: index,
  getDynamicStyles: getDynamicStyles,
  hasCSSTOMSupport: hasCSSTOMSupport,
  sheets: sheets,
  toCssValue: toCssValue
});

var at = '@global';
var atPrefix = '@global ';

var GlobalContainerRule =
/*#__PURE__*/
function () {
  function GlobalContainerRule(key, styles, options) {
    this.type = 'global';
    this.at = at;
    this.isProcessed = false;
    this.key = key;
    this.options = options;
    this.rules = new RuleList(_extends({}, options, {
      parent: this
    }));

    for (var selector in styles) {
      this.rules.add(selector, styles[selector]);
    }

    this.rules.process();
  }
  /**
   * Get a rule.
   */


  var _proto = GlobalContainerRule.prototype;

  _proto.getRule = function getRule(name) {
    return this.rules.get(name);
  }
  /**
   * Create and register rule, run plugins.
   */
  ;

  _proto.addRule = function addRule(name, style, options) {
    var rule = this.rules.add(name, style, options);
    if (rule) this.options.jss.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Replace rule, run plugins.
   */
  ;

  _proto.replaceRule = function replaceRule(name, style, options) {
    var newRule = this.rules.replace(name, style, options);
    if (newRule) this.options.jss.plugins.onProcessRule(newRule);
    return newRule;
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    return this.rules.toString(options);
  };

  return GlobalContainerRule;
}();

var GlobalPrefixedRule =
/*#__PURE__*/
function () {
  function GlobalPrefixedRule(key, style, options) {
    this.type = 'global';
    this.at = at;
    this.isProcessed = false;
    this.key = key;
    this.options = options;
    var selector = key.substr(atPrefix.length);
    this.rule = options.jss.createRule(selector, style, _extends({}, options, {
      parent: this
    }));
  }

  var _proto2 = GlobalPrefixedRule.prototype;

  _proto2.toString = function toString(options) {
    return this.rule ? this.rule.toString(options) : '';
  };

  return GlobalPrefixedRule;
}();

var separatorRegExp$1 = /\s*,\s*/g;

function addScope(selector, scope) {
  var parts = selector.split(separatorRegExp$1);
  var scoped = '';

  for (var i = 0; i < parts.length; i++) {
    scoped += scope + " " + parts[i].trim();
    if (parts[i + 1]) scoped += ', ';
  }

  return scoped;
}

function handleNestedGlobalContainerRule(rule, sheet) {
  var options = rule.options,
      style = rule.style;
  var rules = style ? style[at] : null;
  if (!rules) return;

  for (var name in rules) {
    sheet.addRule(name, rules[name], _extends({}, options, {
      selector: addScope(name, rule.selector)
    }));
  }

  delete style[at];
}

function handlePrefixedGlobalRule(rule, sheet) {
  var options = rule.options,
      style = rule.style;

  for (var prop in style) {
    if (prop[0] !== '@' || prop.substr(0, at.length) !== at) continue;
    var selector = addScope(prop.substr(at.length), rule.selector);
    sheet.addRule(selector, style[prop], _extends({}, options, {
      selector: selector
    }));
    delete style[prop];
  }
}
/**
 * Convert nested rules to separate, remove them from original styles.
 */


function jssGlobal() {
  function onCreateRule(name, styles, options) {
    if (!name) return null;

    if (name === at) {
      return new GlobalContainerRule(name, styles, options);
    }

    if (name[0] === '@' && name.substr(0, atPrefix.length) === atPrefix) {
      return new GlobalPrefixedRule(name, styles, options);
    }

    var parent = options.parent;

    if (parent) {
      if (parent.type === 'global' || parent.options.parent && parent.options.parent.type === 'global') {
        options.scoped = false;
      }
    }

    if (!options.selector && options.scoped === false) {
      options.selector = name;
    }

    return null;
  }

  function onProcessRule(rule, sheet) {
    if (rule.type !== 'style' || !sheet) return;
    handleNestedGlobalContainerRule(rule, sheet);
    handlePrefixedGlobalRule(rule, sheet);
  }

  return {
    onCreateRule: onCreateRule,
    onProcessRule: onProcessRule
  };
}

var separatorRegExp = /\s*,\s*/g;
var parentRegExp = /&/g;
var refRegExp = /\$([\w-]+)/g;
/**
 * Convert nested rules to separate, remove them from original styles.
 */

function jssNested() {
  // Get a function to be used for $ref replacement.
  function getReplaceRef(container, sheet) {
    return function (match, key) {
      var rule = container.getRule(key) || sheet && sheet.getRule(key);

      if (rule) {
        return rule.selector;
      }
      return key;
    };
  }

  function replaceParentRefs(nestedProp, parentProp) {
    var parentSelectors = parentProp.split(separatorRegExp);
    var nestedSelectors = nestedProp.split(separatorRegExp);
    var result = '';

    for (var i = 0; i < parentSelectors.length; i++) {
      var parent = parentSelectors[i];

      for (var j = 0; j < nestedSelectors.length; j++) {
        var nested = nestedSelectors[j];
        if (result) result += ', '; // Replace all & by the parent or prefix & with the parent.

        result += nested.indexOf('&') !== -1 ? nested.replace(parentRegExp, parent) : parent + " " + nested;
      }
    }

    return result;
  }

  function getOptions(rule, container, prevOptions) {
    // Options has been already created, now we only increase index.
    if (prevOptions) return _extends({}, prevOptions, {
      index: prevOptions.index + 1
    });
    var nestingLevel = rule.options.nestingLevel;
    nestingLevel = nestingLevel === undefined ? 1 : nestingLevel + 1;

    var options = _extends({}, rule.options, {
      nestingLevel: nestingLevel,
      index: container.indexOf(rule) + 1 // We don't need the parent name to be set options for chlid.

    });

    delete options.name;
    return options;
  }

  function onProcessStyle(style, rule, sheet) {
    if (rule.type !== 'style') return style;
    var styleRule = rule;
    var container = styleRule.options.parent;
    var options;
    var replaceRef;

    for (var prop in style) {
      var isNested = prop.indexOf('&') !== -1;
      var isNestedConditional = prop[0] === '@';
      if (!isNested && !isNestedConditional) continue;
      options = getOptions(styleRule, container, options);

      if (isNested) {
        var selector = replaceParentRefs(prop, styleRule.selector); // Lazily create the ref replacer function just once for
        // all nested rules within the sheet.

        if (!replaceRef) replaceRef = getReplaceRef(container, sheet); // Replace all $refs.

        selector = selector.replace(refRegExp, replaceRef);
        var name = styleRule.key + "-" + prop;

        if ('replaceRule' in container) {
          // for backward compatibility
          container.replaceRule(name, style[prop], _extends({}, options, {
            selector: selector
          }));
        } else {
          container.addRule(name, style[prop], _extends({}, options, {
            selector: selector
          }));
        }
      } else if (isNestedConditional) {
        // Place conditional right after the parent rule to ensure right ordering.
        container.addRule(prop, {}, options).addRule(styleRule.key, style[prop], {
          selector: styleRule.selector
        });
      }

      delete style[prop];
    }

    return style;
  }

  return {
    onProcessStyle: onProcessStyle
  };
}

/* eslint-disable no-var, prefer-template */
var uppercasePattern = /[A-Z]/g;
var msPattern = /^ms-/;
var cache = {};

function toHyphenLower(match) {
  return '-' + match.toLowerCase()
}

function hyphenateStyleName(name) {
  if (cache.hasOwnProperty(name)) {
    return cache[name]
  }

  var hName = name.replace(uppercasePattern, toHyphenLower);
  return (cache[name] = msPattern.test(hName) ? '-' + hName : hName)
}

/**
 * Convert camel cased property names to dash separated.
 */

function convertCase(style) {
  var converted = {};

  for (var prop in style) {
    var key = prop.indexOf('--') === 0 ? prop : hyphenateStyleName(prop);
    converted[key] = style[prop];
  }

  if (style.fallbacks) {
    if (Array.isArray(style.fallbacks)) converted.fallbacks = style.fallbacks.map(convertCase);else converted.fallbacks = convertCase(style.fallbacks);
  }

  return converted;
}
/**
 * Allow camel cased property names by converting them back to dasherized.
 */


function camelCase() {
  function onProcessStyle(style) {
    if (Array.isArray(style)) {
      // Handle rules like @font-face, which can have multiple styles in an array
      for (var index = 0; index < style.length; index++) {
        style[index] = convertCase(style[index]);
      }

      return style;
    }

    return convertCase(style);
  }

  function onChangeValue(value, prop, rule) {
    if (prop.indexOf('--') === 0) {
      return value;
    }

    var hyphenatedProp = hyphenateStyleName(prop); // There was no camel case in place

    if (prop === hyphenatedProp) return value;
    rule.prop(hyphenatedProp, value); // Core will ignore that property value we set the proper one above.

    return null;
  }

  return {
    onProcessStyle: onProcessStyle,
    onChangeValue: onChangeValue
  };
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var _tslib$1 = {};

(function (exports) {

	Object.defineProperty(exports, '__esModule', { value: true });

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */

	exports.__assign = function () {
		exports.__assign =
			Object.assign ||
			function __assign(t) {
				for (var s, i = 1, n = arguments.length; i < n; i++) {
					s = arguments[i];
					for (var p in s)
						if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
				}
				return t;
			};
		return exports.__assign.apply(this, arguments);
	}; 
} (_tslib$1));

var require$$1 = /*@__PURE__*/getAugmentedNamespace(jss_esm);

/**
 * The custom `sort` method for
 * for the [`css-mqpacker`](https://www.npmjs.com/package/css-mqpacker) or
 * [`pleeease`](https://www.npmjs.com/package/pleeease) which using `css-mqpacker`
 * or, perhaps, something else ))
 *
 * @module sort-css-media-queries
 * @author Oleg Dutchenko <dutchenko.o.wezom@gmail.com>
 * @version 1.5.0
 */

// ----------------------------------------
// Private
// ----------------------------------------

const minMaxWidth = /(!?\(\s*min(-device-)?-width)(.|\n)+\(\s*max(-device)?-width/i;
const minWidth = /\(\s*min(-device)?-width/i;
const maxMinWidth = /(!?\(\s*max(-device)?-width)(.|\n)+\(\s*min(-device)?-width/i;
const maxWidth = /\(\s*max(-device)?-width/i;

const isMinWidth = _testQuery(minMaxWidth, maxMinWidth, minWidth);
const isMaxWidth = _testQuery(maxMinWidth, minMaxWidth, maxWidth);

const minMaxHeight = /(!?\(\s*min(-device)?-height)(.|\n)+\(\s*max(-device)?-height/i;
const minHeight = /\(\s*min(-device)?-height/i;
const maxMinHeight = /(!?\(\s*max(-device)?-height)(.|\n)+\(\s*min(-device)?-height/i;
const maxHeight = /\(\s*max(-device)?-height/i;

const isMinHeight = _testQuery(minMaxHeight, maxMinHeight, minHeight);
const isMaxHeight = _testQuery(maxMinHeight, minMaxHeight, maxHeight);

const isPrint = /print/i;
const isPrintOnly = /^print$/i;

const maxValue = Number.MAX_VALUE;

/**
 * Obtain the length of the media request in pixels.
 * Copy from original source `function inspectLength (length)`
 * {@link https://github.com/hail2u/node-css-mqpacker/blob/master/index.js#L58}
 * @private
 * @param {string} length
 * @return {number}
 */
function _getQueryLength (length) {
  length = /(-?\d*\.?\d+)(ch|em|ex|px|rem)/.exec(length);

  if (length === null) {
    return maxValue
  }

  let number = length[1];
  const unit = length[2];

  switch (unit) {
    case 'ch':
      number = parseFloat(number) * 8.8984375;
      break

    case 'em':
    case 'rem':
      number = parseFloat(number) * 16;
      break

    case 'ex':
      number = parseFloat(number) * 8.296875;
      break

    case 'px':
      number = parseFloat(number);
      break
  }

  return +number
}

/**
 * Wrapper for creating test functions
 * @private
 * @param {RegExp} doubleTestTrue
 * @param {RegExp} doubleTestFalse
 * @param {RegExp} singleTest
 * @return {Function}
 */
function _testQuery (doubleTestTrue, doubleTestFalse, singleTest) {
  /**
   * @param {string} query
   * @return {boolean}
   */
  return function (query) {
    if (doubleTestTrue.test(query)) {
      return true
    } else if (doubleTestFalse.test(query)) {
      return false
    }
    return singleTest.test(query)
  }
}

/**
 * @private
 * @param {string} a
 * @param {string} b
 * @return {number|null}
 */
function _testIsPrint (a, b) {
  const isPrintA = isPrint.test(a);
  const isPrintOnlyA = isPrintOnly.test(a);

  const isPrintB = isPrint.test(b);
  const isPrintOnlyB = isPrintOnly.test(b);

  if (isPrintA && isPrintB) {
    if (!isPrintOnlyA && isPrintOnlyB) {
      return 1
    }
    if (isPrintOnlyA && !isPrintOnlyB) {
      return -1
    }
    return a.localeCompare(b)
  }
  if (isPrintA) {
    return 1
  }
  if (isPrintB) {
    return -1
  }

  return null
}

// ----------------------------------------
// Public
// ----------------------------------------

/**
 * Sorting an array with media queries
 * according to the mobile-first methodology.
 * @param {string} a
 * @param {string} b
 * @return {number} 1 / 0 / -1
 */
function sortCSSmq$1 (a, b) {
  const testIsPrint = _testIsPrint(a, b);
  if (testIsPrint !== null) {
    return testIsPrint
  }

  const minA = isMinWidth(a) || isMinHeight(a);
  const maxA = isMaxWidth(a) || isMaxHeight(a);

  const minB = isMinWidth(b) || isMinHeight(b);
  const maxB = isMaxWidth(b) || isMaxHeight(b);

  if (minA && maxB) {
    return -1
  }
  if (maxA && minB) {
    return 1
  }

  let lengthA = _getQueryLength(a);
  let lengthB = _getQueryLength(b);

  if (lengthA === maxValue && lengthB === maxValue) {
    return a.localeCompare(b)
  } else if (lengthA === maxValue) {
    return 1
  } else if (lengthB === maxValue) {
    return -1
  }

  if (lengthA > lengthB) {
    if (maxA) {
      return -1
    }
    return 1
  }

  if (lengthA < lengthB) {
    if (maxA) {
      return 1
    }
    return -1
  }

  return a.localeCompare(b)
}

/**
 * Sorting an array with media queries
 * according to the desktop-first methodology.
 * @param {string} a
 * @param {string} b
 * @return {number} 1 / 0 / -1
 */
sortCSSmq$1.desktopFirst = function (a, b) {
  const testIsPrint = _testIsPrint(a, b);
  if (testIsPrint !== null) {
    return testIsPrint
  }

  const minA = isMinWidth(a) || isMinHeight(a);
  const maxA = isMaxWidth(a) || isMaxHeight(a);

  const minB = isMinWidth(b) || isMinHeight(b);
  const maxB = isMaxWidth(b) || isMaxHeight(b);

  if (minA && maxB) {
    return 1
  }
  if (maxA && minB) {
    return -1
  }

  const lengthA = _getQueryLength(a);
  const lengthB = _getQueryLength(b);

  if (lengthA === maxValue && lengthB === maxValue) {
    return a.localeCompare(b)
  } else if (lengthA === maxValue) {
    return 1
  } else if (lengthB === maxValue) {
    return -1
  }

  if (lengthA > lengthB) {
    if (maxA) {
      return -1
    }
    return 1
  }

  if (lengthA < lengthB) {
    if (maxA) {
      return 1
    }
    return -1
  }

  return -(a.localeCompare(b))
};

// ----------------------------------------
// Exports
// ----------------------------------------

var sortCssMediaQueries = sortCSSmq$1;

var _tslib = _tslib$1;
var jss$1 = require$$1;
var sortCSSmq = sortCssMediaQueries;

function _interopDefaultLegacy(e) {
	return e && typeof e === 'object' && 'default' in e ? e : { default: e };
}

var sortCSSmq__default = /*#__PURE__*/ _interopDefaultLegacy(sortCSSmq);

function isPlainObject(sample) {
	return (
		sample !== null && typeof sample === 'object' && Array.isArray(sample) === false
	);
}
var UN_QUERIED = '__UN_QUERIED';
function recursiveInnerAndGetQueries(pluginOptions, rules) {
	var queries = {
		groups: {},
		groupsSortNames: []
	};
	for (var index = 0; index < rules.length; index++) {
		var rule = rules[index];
		var query =
			rule.type === 'conditional' && typeof rule.query === 'string'
				? rule.query
				: UN_QUERIED;
		if (!queries.groups.hasOwnProperty(query)) {
			queries.groupsSortNames.push(query);
			queries.groups[query] = [];
		}
		queries.groups[query].push(index);
		// eslint-disable-next-line @typescript-eslint/no-use-before-define
		recursive(pluginOptions, rule);
	}
	queries.groupsSortNames.sort(function (a, b) {
		var aWeight = a === UN_QUERIED ? 0 : a.length;
		var bWeight = b === UN_QUERIED ? 0 : b.length;
		if (aWeight > 0 && bWeight > 0) {
			if (pluginOptions.desktopFirst) {
				return sortCSSmq__default['default'].desktopFirst(a, b);
			} else {
				return sortCSSmq__default['default'](a, b);
			}
		} else {
			return aWeight - bWeight;
		}
	});
	return queries;
}
function recursive(pluginOptions, data) {
	if (isPlainObject(data) && data.rules instanceof jss$1.RuleList) {
		data.rules.toString = function (options) {
			if (options === void 0) {
				options = {};
			}
			var str = '';
			var sheet = this.options.sheet;
			var link = sheet ? sheet.options.link : false;
			var _a = recursiveInnerAndGetQueries(pluginOptions, this.index),
				groups = _a.groups,
				groupsSortNames = _a.groupsSortNames;
			for (var i = 0; i < groupsSortNames.length; i++) {
				var groupName = groupsSortNames[i];
				var group = groups[groupsSortNames[i]];
				if (groupName !== UN_QUERIED && pluginOptions.combineMediaQueries) {
					str += '\n' + groupName + ' {';
					for (var i_1 = 0; i_1 < group.length; i_1++) {
						var rule = this.index[group[i_1]];
						var css = rule.rules.toString(
							_tslib.__assign(_tslib.__assign({}, options), {
								indent: (options.indent || 0) + 1
							})
						);
						if (!css && !link) continue;
						if (str) str += '\n';
						str += css;
					}
					str += '\n}\n';
				} else {
					for (var i_2 = 0; i_2 < group.length; i_2++) {
						var rule = this.index[group[i_2]];
						var css = rule.toString(options);
						if (!css && !link) continue;
						if (str) str += '\n';
						str += css;
					}
				}
			}
			return str;
		};
	}
}
function jssCombineAndSortMQ(options) {
	if (options === void 0) {
		options = {};
	}
	return {
		onProcessSheet: function (sheet) {
			recursive(options, sheet);
		}
	};
}

var dist = jssCombineAndSortMQ;

var jssPluginSortMediaQueries = /*@__PURE__*/getDefaultExportFromCjs(dist);

// This class is shared since the popover needs to register a scroll listener to this node in order to hide the popover when the table is scrolled
const scrollAreaClass = 'scroll-area';

/* eslint-disable prefer-arrow/prefer-arrow-functions */
function getClosestHTMLElement(element, selector) {
    return element?.closest(selector);
}

function getHTMLElement(element, selector) {
    return element?.querySelector(selector);
}

const transformSelectorToDirectChildSelector = (selector) => selector
    .split(',')
    .map((part) => ':scope>' + part)
    .join();

/* eslint-disable prefer-arrow/prefer-arrow-functions */
function getDirectChildHTMLElement(element, selector) {
    // querySelector(All) doesn't work with :scope pseudo class and comma separator in jsdom, yet
    // https://github.com/jsdom/jsdom/issues/3141
    // therefore we got a workaround so it works nicely when consumed from jsdom-polyfill package
    return (transformSelectorToDirectChildSelector(selector)
        .split(',')
        .map((sel) => getHTMLElement(element, sel))
        .filter((x) => x)[0] || null // comma separated selector might return null, so we have to filter
    );
}

const hasSpecificDirectChildTag = (host, tag) => {
    const el = getDirectChildHTMLElement(host, ':only-child');
    return !!(el?.matches(tag));
};

const isDisabledOrLoading = (disabled, loading) => {
    return disabled || loading;
};

const parseJSONAttribute = (attribute) => {
    return typeof attribute === 'string'
        ? // input is potentially JSON parsable string, e.g. "{ aria-label: 'Some label' }"
            JSON.parse(attribute
                .replace(/'/g, '"') // convert single quotes to double quotes
                .replace(/[\s"]?([\w-]+)[\s"]?:/g, '"$1":') // wrap keys in double quotes
            )
        : // input is object, e.g. { aria-label: 'Some label' }
            attribute;
};

const hasWindow = typeof window !== 'undefined';
const parseAndGetAriaAttributes = (rawAttributes) => {
    if (rawAttributes) {
        return Object.fromEntries(Object.entries(parseJSONAttribute(rawAttributes)).map(([key, val]) => [
            key,
            // convert booleans to strings so that values are properly set and not just result in attributes without a value when true in jsx
            typeof val === 'boolean' ? `${val}` : val,
        ]));
    }
};
hasWindow && window.matchMedia?.('(forced-colors: active)').matches;

const getButtonBaseAriaAttributes = (isDisabled, isLoading) => {
    return {
        'aria-disabled': isDisabledOrLoading(isDisabled, isLoading) ? 'true' : null,
    };
};
// TODO: Can this be shared with select-wrapper dropdown?
const getComboboxAriaAttributes = (isOpen, isRequired, labelId, descriptionId, dropdownId) => {
    return {
        'aria-labelledby': labelId || null,
        'aria-describedby': descriptionId || null,
        'aria-haspopup': 'listbox',
        'aria-expanded': isOpen ? 'true' : 'false',
        'aria-required': isRequired ? 'true' : 'false',
        'aria-controls': dropdownId,
    };
};
// TODO: Change to aria-labelledby
const getListAriaAttributes = (label, isRequired, hasFilter, isOpen, multiple = false) => {
    return {
        role: 'listbox',
        'aria-label': label,
        ...(isRequired &&
            !hasFilter && {
            'aria-required': 'true',
        }),
        ...(!isOpen && {
            'aria-hidden': 'true',
        }),
        ...(multiple && {
            'aria-multiselectable': 'true',
        }),
    };
};

const attributeMutationMap = new Map();
hasWindow &&
    new MutationObserver((mutations) => {
        mutations
            // reduce array to only entries that have really a changed value
            .filter((mutation) => mutation.oldValue !== mutation.target.getAttribute(mutation.attributeName))
            // remove duplicates so we execute callback only once per node
            .filter((mutation, idx, arr) => arr.findIndex((m) => m.target === mutation.target) === idx)
            .forEach((mutation) => attributeMutationMap.get(mutation.target)?.());
    });

const borderWidthBase = '2px';

const fontFamily = "'Porsche Next','Arial Narrow',Arial,'Heiti SC',SimHei,sans-serif";

const fontHyphenationStyle = {
    overflowWrap: 'break-word',
    hyphens: 'auto',
};

const fontLineHeight = 'calc(6px + 2.125ex)';

const fontSizeTextXSmall = 'clamp(0.81rem, 0.23vw + 0.77rem, 0.88rem)';

const fontSizeTextSmall = '1rem';

const fontWeightRegular = 400;

const fontStyleNormal = 'normal';

const fontVariant = 'normal';

const breakpointBase = 0;

const breakpointXS = 480;

const breakpointS = 760;

const breakpointM = 1000;

const breakpointL = 1300;

const breakpointXL = 1760;

const breakpointXXL = 1920;

const breakpoint = {
    base: breakpointBase,
    xs: breakpointXS,
    s: breakpointS,
    m: breakpointM,
    l: breakpointL,
    xl: breakpointXL,
    xxl: breakpointXXL,
};

const breakpoints = ['base', 'xs', 's', 'm', 'l', 'xl', 'xxl'];

const _textFontPartA = `${fontStyleNormal} ${fontVariant} ${fontWeightRegular} `;
const _textFontPartB = `/${fontLineHeight} ${fontFamily}`;

const textXSmallStyle = {
    font: `${_textFontPartA}${fontSizeTextXSmall}${_textFontPartB}`,
    ...fontHyphenationStyle,
};

const textSmallStyle = {
    font: `${_textFontPartA}${fontSizeTextSmall}${_textFontPartB}`,
    ...fontHyphenationStyle,
};

const mediaQueries = Object.values(breakpoint).map((v) => `(min-width:${v}px)`);
hasWindow && window.matchMedia ? mediaQueries.map(window.matchMedia) : [];

Object.entries(breakpoint).reduce((result, [key, val]) => ({ ...result, [`${val}px`]: key }), {});

const hasVisibleIcon = (iconName, iconSource) => {
    return iconName !== 'none' || !!iconSource;
};

/**
 * Map of observed nodes and their corresponding callback functions.
 */
const observedNodesMap = new Map();
/**
 * Mutation observer for observing changes in the children of observed nodes.
 */
hasWindow &&
    new MutationObserver((mutations) => {
        // there may be race conditions in jsdom-polyfill tests  where the map is already empty when a mutation happens
        if (observedNodesMap.size) {
            const observedNodes = Array.from(observedNodesMap.keys());
            mutations
                // remove duplicates so we execute callback only once per node
                .filter((mutation, idx, arr) => arr.findIndex((m) => m.target === mutation.target) === idx)
                // find all observing parent nodes of mutated node and invoke their callbacks
                .forEach((mutation) => {
                observedNodes
                    .filter((node) => node.contains(mutation.target))
                    .forEach((node) => observedNodesMap.get(node)?.());
            });
        }
    });

const isTouchDevice = () => {
    if (!hasWindow) {
        return;
    }
    return !!('ontouchstart' in window || window.navigator.maxTouchPoints > 0);
};

/* eslint-disable no-undefined,no-param-reassign,no-shadow */

/**
 * Throttle execution of a function. Especially useful for rate limiting
 * execution of handlers on events like resize and scroll.
 *
 * @param {number} delay -                  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher)
 *                                            are most useful.
 * @param {Function} callback -               A function to be executed after delay milliseconds. The `this` context and all arguments are passed through,
 *                                            as-is, to `callback` when the throttled-function is executed.
 * @param {object} [options] -              An object to configure options.
 * @param {boolean} [options.noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds
 *                                            while the throttled-function is being called. If noTrailing is false or unspecified, callback will be executed
 *                                            one final time after the last throttled-function call. (After the throttled-function has not been called for
 *                                            `delay` milliseconds, the internal counter is reset).
 * @param {boolean} [options.noLeading] -   Optional, defaults to false. If noLeading is false, the first throttled-function call will execute callback
 *                                            immediately. If noLeading is true, the first the callback execution will be skipped. It should be noted that
 *                                            callback will never executed if both noLeading = true and noTrailing = true.
 * @param {boolean} [options.debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is
 *                                            false (at end), schedule `callback` to execute after `delay` ms.
 *
 * @returns {Function} A new, throttled, function.
 */
function throttle (delay, callback, options) {
  var _ref = options || {},
      _ref$noTrailing = _ref.noTrailing,
      noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing,
      _ref$noLeading = _ref.noLeading,
      noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading,
      _ref$debounceMode = _ref.debounceMode,
      debounceMode = _ref$debounceMode === void 0 ? undefined : _ref$debounceMode;
  /*
   * After wrapper has stopped being called, this timeout ensures that
   * `callback` is executed at the proper times in `throttle` and `end`
   * debounce modes.
   */


  var timeoutID;
  var cancelled = false; // Keep track of the last time `callback` was executed.

  var lastExec = 0; // Function to clear existing timeout

  function clearExistingTimeout() {
    if (timeoutID) {
      clearTimeout(timeoutID);
    }
  } // Function to cancel next exec


  function cancel(options) {
    var _ref2 = options || {},
        _ref2$upcomingOnly = _ref2.upcomingOnly,
        upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;

    clearExistingTimeout();
    cancelled = !upcomingOnly;
  }
  /*
   * The `wrapper` function encapsulates all of the throttling / debouncing
   * functionality and when executed will limit the rate at which `callback`
   * is executed.
   */


  function wrapper() {
    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
      arguments_[_key] = arguments[_key];
    }

    var self = this;
    var elapsed = Date.now() - lastExec;

    if (cancelled) {
      return;
    } // Execute `callback` and update the `lastExec` timestamp.


    function exec() {
      lastExec = Date.now();
      callback.apply(self, arguments_);
    }
    /*
     * If `debounceMode` is true (at begin) this is used to clear the flag
     * to allow future `callback` executions.
     */


    function clear() {
      timeoutID = undefined;
    }

    if (!noLeading && debounceMode && !timeoutID) {
      /*
       * Since `wrapper` is being called for the first time and
       * `debounceMode` is true (at begin), execute `callback`
       * and noLeading != true.
       */
      exec();
    }

    clearExistingTimeout();

    if (debounceMode === undefined && elapsed > delay) {
      if (noLeading) {
        /*
         * In throttle mode with noLeading, if `delay` time has
         * been exceeded, update `lastExec` and schedule `callback`
         * to execute after `delay` ms.
         */
        lastExec = Date.now();

        if (!noTrailing) {
          timeoutID = setTimeout(debounceMode ? clear : exec, delay);
        }
      } else {
        /*
         * In throttle mode without noLeading, if `delay` time has been exceeded, execute
         * `callback`.
         */
        exec();
      }
    } else if (noTrailing !== true) {
      /*
       * In trailing throttle mode, since `delay` time has not been
       * exceeded, schedule `callback` to execute `delay` ms after most
       * recent execution.
       *
       * If `debounceMode` is true (at begin), schedule `clear` to execute
       * after `delay` ms.
       *
       * If `debounceMode` is false (at end), schedule `callback` to
       * execute after `delay` ms.
       */
      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
    }
  }

  wrapper.cancel = cancel; // Return the wrapper function.

  return wrapper;
}

/* eslint-disable no-undefined */
/**
 * Debounce execution of a function. Debouncing, unlike throttling,
 * guarantees that a function is only executed a single time, either at the
 * very beginning of a series of calls, or at the very end.
 *
 * @param {number} delay -               A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param {Function} callback -          A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
 *                                        to `callback` when the debounced-function is executed.
 * @param {object} [options] -           An object to configure options.
 * @param {boolean} [options.atBegin] -  Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds
 *                                        after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.
 *                                        (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).
 *
 * @returns {Function} A new, debounced function.
 */

function debounce (delay, callback, options) {
  var _ref = options || {},
      _ref$atBegin = _ref.atBegin,
      atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;

  return throttle(delay, callback, {
    debounceMode: atBegin !== false
  });
}
debounce(800, (el, ariaElement) => {
    ariaElement.innerText = `You have ${el.maxLength - el.value.length} out of ${el.maxLength} characters left`;
});

const getRole = (state) => {
    return state === 'error' ? 'alert' : state === 'success' ? 'status' : null;
};

const isWithinForm = (host) => !!getClosestHTMLElement(host, 'form');

const getCDNBaseURL = () => global.PORSCHE_DESIGN_SYSTEM_CDN_URL + "/porsche-design-system";

const CRESTS_MANIFEST = { "porscheCrest": { "1x": { "png": "porsche-crest.min.d76137cf8cf94822b7aedb534ba88418@1x.png", "webp": "porsche-crest.min.0d0cc89ae5ee57c4c15bd0dbbcbfe5d0@1x.webp" }, "2x": { "png": "porsche-crest.min.8a292fbd35a5155789ddd011585e05c4@2x.png", "webp": "porsche-crest.min.2245c45e99be5a46b4b56e73c43d5c63@2x.webp" }, "3x": { "png": "porsche-crest.min.18d6f02003b0829bac939fade88fd4e6@3x.png", "webp": "porsche-crest.min.19b429278b158b5cb5aa6ce80751e3fe@3x.webp" } } };

const ICONS_MANIFEST = { "360": "360.min.d3b2874981886b5ebece31655f92a3ad.svg", "accessibility": "accessibility.min.39472992434d3aae116c950714e80d26.svg", "active-cabin-ventilation": "active-cabin-ventilation.min.60422415604862b604bab5d59a4cf9ca.svg", "add": "add.min.8a2cc9683690995a35bbe3b21c444afb.svg", "adjust": "adjust.min.faf70ff09f41b20ca5c914871f92ee9b.svg", "arrow-double-down": "arrow-double-down.min.3a5683124626fe51505380524ffbddd5.svg", "arrow-double-left": "arrow-double-left.min.cf7261542e67b89fe8b146ee4c3748ed.svg", "arrow-double-right": "arrow-double-right.min.4291829dcf9bfb5fc9156199a51c61eb.svg", "arrow-double-up": "arrow-double-up.min.e67ff8a2cfe8807f663346cca9b403a0.svg", "arrow-down": "arrow-down.min.86fc100227a564b214f4fe07e8401728.svg", "arrow-first": "arrow-first.min.bc51317ecf4953a664870ebab5059775.svg", "arrow-head-down": "arrow-head-down.min.31c010019ab8911fed67bef461ce8b40.svg", "arrow-head-left": "arrow-head-left.min.4723607b9add50ee55a343bdf26ff315.svg", "arrow-head-right": "arrow-head-right.min.c2b5cd82e92920af36c9be86dc321999.svg", "arrow-head-up": "arrow-head-up.min.e8f62967ee5ecb865e1399ffa3235ac0.svg", "arrow-last": "arrow-last.min.72553c4284717d4961f8bcf8d51e0303.svg", "arrow-left": "arrow-left.min.06c8246bf60d457bc3f2ff8866053de2.svg", "arrow-right": "arrow-right.min.c5cbce45d98d6d1178cc72ea8bfbfa10.svg", "arrow-up": "arrow-up.min.deb76e3aacfb1059ef9f5130adb143b4.svg", "augmented-reality": "augmented-reality.min.f776f8a44e469a2a7f54f3f59e15fa3d.svg", "battery-empty": "battery-empty.min.8594e37d3e67a95b85eb9935f02e69cf.svg", "battery-empty-co2": "battery-empty-co2.min.ee19666b8773be60f2a84b37754a3d1f.svg", "battery-full": "battery-full.min.4c75acb5a64a6dd3116ede7b1859a6d6.svg", "bell": "bell.min.22f7cdeffa6e2a1524c7358b3c045380.svg", "bookmark": "bookmark.min.9d6982fc89822602454c2b1e21aeb1b9.svg", "bookmark-filled": "bookmark-filled.min.9f96a8e4d19a90f288cab4298075fbfe.svg", "broadcast": "broadcast.min.694edb52b13117621b406ca1d1e8a50d.svg", "calculator": "calculator.min.2518729352d3709e488e71dcbf449247.svg", "calendar": "calendar.min.bc89af56fd76ad2e64d30dfc6f385cf4.svg", "camera": "camera.min.c54204c4294683703245cd4ffff8aac4.svg", "car": "car.min.458d137c81fd14019ca67b225ce85b53.svg", "car-battery": "car-battery.min.651ee52abbb40a656842df198a1de7ec.svg", "card": "card.min.572e3adcb01df8f9feb499fac6611b52.svg", "charging-active": "charging-active.min.421bdd011bfc2e8ff4cc2b5adad2a36a.svg", "charging-state": "charging-state.min.26a4894b3de9b3b8676b803dea2f388a.svg", "charging-station": "charging-station.min.bcbf9bed92bce0100d5322bdec4b9887.svg", "chart": "chart.min.fef87221f35a78ff17bbc3d96b773e33.svg", "chat": "chat.min.733ae126444c50779d6d22e9f51dd739.svg", "check": "check.min.e1930a3d5427c6e8e41af7bf8edec8bb.svg", "city": "city.min.a99b88b51adda8244a2c72953a2f4ab4.svg", "climate": "climate.min.5d52b2880552275d9032afc0fa2b7296.svg", "climate-control": "climate-control.min.1d895777024f7feac7efc8a21fae2434.svg", "clock": "clock.min.04a827c1f9bb35bedaacc7eeb82d03fc.svg", "close": "close.min.565f6a718b632a173b7a74eb9cb84378.svg", "closed-caption": "closed-caption.min.e7b74862b113c39c5d5f8457a22f4540.svg", "co2-class": "co2-class.min.3b7529f015b928dc86e3b03e933ad3ef.svg", "co2-emission": "co2-emission.min.1a0e315ed17c2bd3a0356bfc12fc440b.svg", "compare": "compare.min.9c23d6a10728833095ea6e49e93d9169.svg", "configurate": "configurate.min.224bd9e2517456659ff569d85cd7f3f8.svg", "copy": "copy.min.b0a10014b18914ec494e8b3e192476ec.svg", "country-road": "country-road.min.d96dabea56a3d002575d59798c12402c.svg", "cubic-capacity": "cubic-capacity.min.cbda5779c4ff38cf4cd96ca39d148282.svg", "delete": "delete.min.65becfbcc48b9492a58f4d3897dec899.svg", "disable": "disable.min.c0ebae661732da2c4b6bdafdc3efb312.svg", "document": "document.min.d2db26d7049ab2180361c7ce40f52d57.svg", "download": "download.min.052783a619244de5e2f34e6300182f54.svg", "duration": "duration.min.4dcbb8fe5db34911a2d0301e2399def8.svg", "edit": "edit.min.8236867e0975bbf4127fbf8047e3ba38.svg", "email": "email.min.eb8ff02812a48c5098d3c40614e8d9d7.svg", "error-filled": "error-filled.min.e9745fe44ade7ee515da8ea964ec4c66.svg", "exclamation": "exclamation.min.69832f14c6f80b43de1628f87efb4933.svg", "external": "external.min.1d85320339ea25db0324e74be0f632e2.svg", "filter": "filter.min.60f168332c7550dfdf714ed0507877b0.svg", "fingerprint": "fingerprint.min.698297df3e9555c61463be51340356ac.svg", "flash": "flash.min.e1ed63ec33d28aaa9cdf78d45df1eb8e.svg", "fuel-station": "fuel-station.min.7149b2be5528908900cbc4c9a2654150.svg", "garage": "garage.min.05bd3f8eae4ba0bb1a758ba272789ad4.svg", "gift": "gift.min.091131a27cb0703b194952a6a6208548.svg", "globe": "globe.min.9e186f3da4fa55382f84c7b66235f47a.svg", "grid": "grid.min.eb7c2ddc778827955200c41e53abdcec.svg", "heart": "heart.min.9bf1c860a0e4c38cf85d1e82b19ba483.svg", "heart-filled": "heart-filled.min.581fbbce1e8955092aa194dcf8fdfb6e.svg", "highway": "highway.min.938feb5bf2ec2a7ce6f43aadc498aa32.svg", "home": "home.min.2bdc01bb7c9b39fa5ef5a81c8c3f9f49.svg", "horn": "horn.min.77105eb430a033a3ffdf21f9fecd32de.svg", "image": "image.min.851c64681e1950312a934a723ca04a85.svg", "increase": "increase.min.45bfe421e86192da37c8cca4917c10c2.svg", "information": "information.min.da41162c49566b753b7162fc6b88adb9.svg", "information-filled": "information-filled.min.d9ff41c99234ae53e794900a355268de.svg", "key": "key.min.4f55b5ba22e76cf8426ad6dbe40d0bbc.svg", "leaf": "leaf.min.9fb555963ab3e04de2b2fc3356fb8d54.svg", "leather": "leather.min.e1869beedb7d489f9c88873db7e86878.svg", "light": "light.min.b3df892b730921aa9f34e72d1dc6707f.svg", "list": "list.min.ecaeee96ec6cf2f8c9028ea404113a9e.svg", "locate": "locate.min.61ea8fda8a7f6a61e90382d371882875.svg", "lock": "lock.min.c9bd1029c6fc9bfa37dbcaa1de314151.svg", "lock-open": "lock-open.min.ebce0c0023d1761620e5a9ec86d5f19c.svg", "logo-apple-podcast": "logo-apple-podcast.min.59a2ee9e209fa59584c5e7d1ab15751b.svg", "logo-baidu": "logo-baidu.min.fef8bfc1e79a0ae2a045b85cb6914500.svg", "logo-delicious": "logo-delicious.min.fc2927d4979ffaed1f23160091e0975e.svg", "logo-digg": "logo-digg.min.d7340b3f22cf4a22a8ac3b472c16e0e2.svg", "logo-facebook": "logo-facebook.min.1f2fd90a9f18dd66befe59beb96ecca8.svg", "logo-foursquare": "logo-foursquare.min.3540cfa24d2148b73109be719fda9dc9.svg", "logo-gmail": "logo-gmail.min.adfa4976a690779760813b2d6233044c.svg", "logo-google": "logo-google.min.94c456d4bbaff4762bc237e955208d43.svg", "logo-hatena": "logo-hatena.min.fa24251ddecb3bb3dc88eb272ceb7207.svg", "logo-instagram": "logo-instagram.min.3598c948318e3ca1d3ceb05b2d92ed82.svg", "logo-kaixin": "logo-kaixin.min.589d54db102fd3601a2f6272e95a97ae.svg", "logo-kakaotalk": "logo-kakaotalk.min.a12bd354de347ae378c814bab03019c9.svg", "logo-linkedin": "logo-linkedin.min.037f80d4dcaed74a8ec477c8b41efda4.svg", "logo-naver": "logo-naver.min.3fb9362b5d870bfa2b4828d3ed8f0908.svg", "logo-pinterest": "logo-pinterest.min.bc85460c3acaf569a2dac52c65e0cbb1.svg", "logo-qq": "logo-qq.min.f4964e246a81d4c53e6cd73b27bec6f7.svg", "logo-qq-share": "logo-qq-share.min.206a8aa10c361b42e0ce21187a026b20.svg", "logo-reddit": "logo-reddit.min.d17ea0df5f3ef78dfd4c589ee05f614c.svg", "logo-skyrock": "logo-skyrock.min.c8abe04e7b2108e0043bfbf767502e28.svg", "logo-sohu": "logo-sohu.min.b08a939d35b55af30a260e7cd4a0ec86.svg", "logo-spotify": "logo-spotify.min.45a99bb091d15e4ee8972c924a0bccd7.svg", "logo-tecent": "logo-tecent.min.46a3a54e2eefb01152fc5bbcf669bb50.svg", "logo-telegram": "logo-telegram.min.624fca36dd6f6c5b64bce6e617372d77.svg", "logo-tiktok": "logo-tiktok.min.7829ba5442928dac099150730224cb05.svg", "logo-tumblr": "logo-tumblr.min.01b11e20074f291f48ad3b8b8b6c3614.svg", "logo-twitter": "logo-twitter.min.5f2490acc4b03eea7f270a750595de71.svg", "logo-viber": "logo-viber.min.646a1bd7d9ddfa36e88ac8167ceb3a62.svg", "logo-vk": "logo-vk.min.3efece5db847af4330a6e8443f63ee69.svg", "logo-wechat": "logo-wechat.min.cd991e932478b2c59f2ec06087e7c24d.svg", "logo-weibo": "logo-weibo.min.7cb2bb1ff4fbb20d389b51acaf36dc3b.svg", "logo-whatsapp": "logo-whatsapp.min.c2c7058b2c0a5b258ac1490e6cd0788a.svg", "logo-x": "logo-x.min.5f2490acc4b03eea7f270a750595de71.svg", "logo-xing": "logo-xing.min.29d25a181d0bd4b4c8f19df1543b92d9.svg", "logo-yahoo": "logo-yahoo.min.e7af46e796bdbfc6420ce2be575e728a.svg", "logo-youku": "logo-youku.min.aae99a44e06894fd39e2e727062ac922.svg", "logo-youtube": "logo-youtube.min.ff07c3f9edd380237a3696ad52922c78.svg", "logout": "logout.min.6fee5a3178d5dc1822872ce7a5498bc2.svg", "map": "map.min.e56d3b260f79967149f12759c2bff74b.svg", "menu-dots-horizontal": "menu-dots-horizontal.min.94e0804e3a5a30a577cab6296ad8d15d.svg", "menu-dots-vertical": "menu-dots-vertical.min.7ec3f5be33dd3459d7a9bed9fdbe22d3.svg", "menu-lines": "menu-lines.min.e3322162121fb57b7109e6c245865e77.svg", "minus": "minus.min.00cca11ec9ce4bd913abba2059c3f10b.svg", "mobile": "mobile.min.00021b016be7e9f085c9a674b00228af.svg", "moon": "moon.min.1bb08960549b5862c853d13a259e51b3.svg", "oil-can": "oil-can.min.4cc2d96f9754e9f708a07836eba07d03.svg", "parking-brake": "parking-brake.min.285b4ba85166dd00b8a6c2e6833e5c88.svg", "parking-light": "parking-light.min.3f11c8f7dbbba49b0c68eea92e97bd5e.svg", "pause": "pause.min.dd29b256b73311abf1549ed16fe7a47b.svg", "phone": "phone.min.cd54f3670e32d37ea41484f6fd45ddaa.svg", "pin": "pin.min.6cf04e89e5946856f6ae8f526425ef8f.svg", "pin-filled": "pin-filled.min.e3a46a4efb0d4041ebafff08ecbdca59.svg", "play": "play.min.65ffffba05432a3f804eb6c537fb71ef.svg", "plug": "plug.min.289db9e36a8ba1dbf5a8e8d387ed8871.svg", "plus": "plus.min.3fbdce4b03fe2c2d1ae489f0dd916f7b.svg", "preheating": "preheating.min.7e8b645163d47293eb7d79f5d6870911.svg", "printer": "printer.min.1df1993070df56c82cdfcc01e9c6f23e.svg", "purchase": "purchase.min.693f7b82c23721fe4bf15a6f8f50b80e.svg", "push-pin": "push-pin.min.a5a47f392030bb24a5b4b985061a5181.svg", "push-pin-off": "push-pin-off.min.2f4b9c8bfb787e48d75a3dd95e38da19.svg", "qr": "qr.min.1facfc2c9b70057552904fe123674746.svg", "question": "question.min.5868a129a8aa88e5504ef2351bfd234f.svg", "racing-flag": "racing-flag.min.c5993e8842a9d4155cc1272358efde84.svg", "refresh": "refresh.min.b4853591c524d0dc7924e60314494ccf.svg", "replay": "replay.min.a3e6361394e1c9432bfb5f9a4b5833ca.svg", "reset": "reset.min.e1ce71f684b6e83b9ed8182389bd407f.svg", "roof-closed": "roof-closed.min.faf6177214e68591bb9911050870103c.svg", "roof-open": "roof-open.min.4314d86b9159ead78bc46622c1c4d3ac.svg", "route": "route.min.784e30085f543fdeb9158cb27c7cb38e.svg", "rss": "rss.min.32a204b2df59ef3fc3bd13effa76b4d2.svg", "save": "save.min.2481cb4d8d04b3ee6b26547a4b8b57ac.svg", "screen": "screen.min.c17978f44a7bf9f7d80f178fd2b7d116.svg", "search": "search.min.1a2481bb5b7acefdb7f69d34d5b2887a.svg", "send": "send.min.544f2b90e562b8582808f735846b1351.svg", "share": "share.min.f92604f534cee4ed9753d1976855908a.svg", "shopping-bag": "shopping-bag.min.3f91a9bcd921ce9d850499c3c5af34fc.svg", "shopping-bag-filled": "shopping-bag-filled.min.abf6c983207c87279f5f6bc26c3ef7d4.svg", "shopping-cart": "shopping-cart.min.05a6c651afb21246daba2e941e8366cc.svg", "shopping-cart-filled": "shopping-cart-filled.min.0e5a79dd87cc0ea1f4c72d5b04aa505e.svg", "sidelights": "sidelights.min.44ca975194d22ac2dc893395256b1678.svg", "snowflake": "snowflake.min.889d8b279ac98abfd0c74cf90b9e3c68.svg", "sort": "sort.min.1629148e7e80ced04d9615b51664e07b.svg", "stack": "stack.min.e71da4fb0445267fa13bff9cfa1fbd16.svg", "star": "star.min.4c5bb15a9c3d7136351e3953805df3c8.svg", "star-filled": "star-filled.min.942167258f7a37f163c03313c5c85eaa.svg", "steering-wheel": "steering-wheel.min.1738194edd71e78e6f8937142bf5d1ef.svg", "stopwatch": "stopwatch.min.932f9fa49916e38a99d2b23511d7f114.svg", "subtract": "subtract.min.43807211256225261ea0cecebc3197fc.svg", "success": "success.min.441faa611fe5d97d758f557ab5438826.svg", "success-filled": "success-filled.min.629e31bb0384825a875c627f5d9f8a37.svg", "sun": "sun.min.7bd259f3f639ac8476a348e2a79ffce3.svg", "switch": "switch.min.bbaf816c7c6982a3714f6e121266dd44.svg", "tablet": "tablet.min.a5e47c3362c7d22fcb44d8cd99f89793.svg", "tachometer": "tachometer.min.4f2563b806263118f75d365f38d26d79.svg", "tire": "tire.min.6ebb3d5a396401e734ae63c06aaaf198.svg", "truck": "truck.min.17f20699b0ebf6f63b418e863410553a.svg", "upload": "upload.min.7b886aa894be24d3549089563361a008.svg", "user": "user.min.255f5ec972caaecfb41b024847a9bbef.svg", "user-filled": "user-filled.min.f35ca1e5ba7d3984ea638b8d92fd3663.svg", "user-group": "user-group.min.27dd137a75974dabf3f60c90591b54c7.svg", "user-manual": "user-manual.min.0b87e500e3d747e67be964c47a3ae312.svg", "video": "video.min.3725461133a7f2a081a5aa4d27b96921.svg", "view": "view.min.78e4839028a721c3efcd47dfdbc8e4bf.svg", "view-off": "view-off.min.041d6453bd984055a91fd70ae251a2c8.svg", "volume-off": "volume-off.min.1bedd2b4a901feda38454b1d495f84e7.svg", "volume-up": "volume-up.min.c6b1b9ca042830cdf31e9b7ca0351bd1.svg", "warning": "warning.min.471ca57c6eef0711bfaa40a6791297ee.svg", "warning-filled": "warning-filled.min.df35246b8e94f696eefc1b2122a77a50.svg", "weight": "weight.min.4f0f06e26c83b4fa29e82e0de9153775.svg", "wifi": "wifi.min.3b4e78e9f4375afd8ada69a3a418a6c4.svg", "work": "work.min.302501dba39782f9a59d3766f57762b2.svg", "wrench": "wrench.min.91a2a4a766ea46cc53898fa4680099b5.svg", "wrenches": "wrenches.min.e06308f102cb227a9fcba2553151bae5.svg", "zoom-in": "zoom-in.min.38a97db3e6a00ce671ee7643679793be.svg", "zoom-out": "zoom-out.min.8dd4c51836b1262285122df30abd8f37.svg" };

const MARQUES_MANIFEST = { "porscheMarqueTrademark": { "medium": { "1x": { "png": "porsche-marque-trademark.medium.min.da075315857e239ff46bf4c150648ff0@1x.png", "webp": "porsche-marque-trademark.medium.min.5c6af9aa7946fea34f60c8f8c95d0188@1x.webp" }, "2x": { "png": "porsche-marque-trademark.medium.min.aa801f42028b1c385a5e26ae115da598@2x.png", "webp": "porsche-marque-trademark.medium.min.fff6e9b91481cc5b1fc6c9b62987ccaf@2x.webp" }, "3x": { "png": "porsche-marque-trademark.medium.min.824818d15eaf445f50e0a2391613f214@3x.png", "webp": "porsche-marque-trademark.medium.min.f67092ff6b5f4ecb4add73d6ae153db0@3x.webp" } }, "small": { "1x": { "png": "porsche-marque-trademark.small.min.020244b41a29323e2a7932a264514cdf@1x.png", "webp": "porsche-marque-trademark.small.min.783639706bead66b2d56e3b8b64bd61f@1x.webp" }, "2x": { "png": "porsche-marque-trademark.small.min.92184fae44511ceda8320443c17110b1@2x.png", "webp": "porsche-marque-trademark.small.min.760a57efa93d4e7e16e26128ec7ead46@2x.webp" }, "3x": { "png": "porsche-marque-trademark.small.min.fd545cea4298f5d797246d5805711646@3x.png", "webp": "porsche-marque-trademark.small.min.1726036a7829347e1e24d1eb54fc0d64@3x.webp" } } }, "porscheMarque": { "medium": { "1x": { "png": "porsche-marque.medium.min.a98627440b05154565f9f9dfc1ad6187@1x.png", "webp": "porsche-marque.medium.min.fa908e4dfdc5536b0e933e1670d20e1f@1x.webp" }, "2x": { "png": "porsche-marque.medium.min.089d6dd560fff7a2bf613ae6d528990e@2x.png", "webp": "porsche-marque.medium.min.7f0893dc57f2607a2cb0b817d96cb985@2x.webp" }, "3x": { "png": "porsche-marque.medium.min.2cb874345ef290831c929f6caabfeef8@3x.png", "webp": "porsche-marque.medium.min.3534cf066b4e2e737dca62de495f9616@3x.webp" } }, "small": { "1x": { "png": "porsche-marque.small.min.ac2042736af5512cf547c89fa7924c4f@1x.png", "webp": "porsche-marque.small.min.005debed5bf72cf0a9a791b1521f5e1d@1x.webp" }, "2x": { "png": "porsche-marque.small.min.22f1e9dc90399d9a5287eda689b60dba@2x.png", "webp": "porsche-marque.small.min.df4317325d04ffef28c7839aa6d499a0@2x.webp" }, "3x": { "png": "porsche-marque.small.min.49209245f04eadef8817b9bbae80d3e1@3x.png", "webp": "porsche-marque.small.min.cfd6149aaa3bc5b3b522538e5f650890@3x.webp" } } }, "porscheMarque75": { "medium": { "1x": { "png": "porsche-marque75.medium.min.0a02e2256062de963f2fef2c02d20200@1x.png", "webp": "porsche-marque75.medium.min.99b2d657558f0531d639782974e8fd06@1x.webp" }, "2x": { "png": "porsche-marque75.medium.min.1d41ecfb8f5277d3f4bd65d25d22eea3@2x.png", "webp": "porsche-marque75.medium.min.e32580cd1ac179e354ed8fcb31694168@2x.webp" }, "3x": { "png": "porsche-marque75.medium.min.373bcb5f89d31c8b6084e66e902b9f4c@3x.png", "webp": "porsche-marque75.medium.min.4a003d1e5e81db062bf92d52ba797087@3x.webp" } }, "small": { "1x": { "png": "porsche-marque75.small.min.f5b37fe12cd4487432ff77fdd8469f7d@1x.png", "webp": "porsche-marque75.small.min.146b06cffe2b11c07f3113a51f337b98@1x.webp" }, "2x": { "png": "porsche-marque75.small.min.20d86908f2190640a6f24fce1ee49035@2x.png", "webp": "porsche-marque75.small.min.025770f8db54857874c130999b370ed8@2x.webp" }, "3x": { "png": "porsche-marque75.small.min.e89b13e14a088a273107bf1057f7f67d@3x.png", "webp": "porsche-marque75.small.min.a725d2ec7bd07be17afd8feb2589b156@3x.webp" } } } };

const MODEL_SIGNATURES_MANIFEST = { "718": "718.min.d92dc0fe91e67bd51120d91c5cd1eb2f.svg", "911": "911.min.5c462658f9d472e90a139173414e8fdd.svg", "boxster": "boxster.min.5e7b22a1fa25004a4f97807d57f32b21.svg", "cayenne": "cayenne.min.4026ba6b335cc98e10592f900cf731e1.svg", "cayman": "cayman.min.c634f6f3de1d67610b2e4230e60337fb.svg", "macan": "macan.min.e38fbf34ed4f00066620901babd99af0.svg", "panamera": "panamera.min.d35913b252657f7c5cfcae74cfd61b26.svg", "taycan": "taycan.min.ba4e7c3cb86a78d626d4463b81be0f23.svg", "turbo-s": "turbo-s.min.8201d60c1b5e00daf9e23784fd199111.svg", "turbo": "turbo.min.cfde5de85fdc84be597dfad4402c5f6f.svg" };

// NOTE: handpicked selection of plugins from jss-preset-default
createJss({
    plugins: [
        jssGlobal(),
        jssNested(),
        camelCase(),
        jssPluginSortMediaQueries({ combineMediaQueries: true }),
    ],
});
const supportsConstructableStylesheets = () => {
    try {
        return typeof new CSSStyleSheet().replaceSync === 'function';
    }
    catch {
        return false;
    }
};
// determine it once
supportsConstructableStylesheets();
const isScrollable = (isPrevHidden, isNextHidden) => {
    return !(isPrevHidden && isNextHidden);
};

/**
 * Checks if the current environment supports the native Popover API.
 *
 * @returns {boolean} `true` if the native Popover API is supported, `false` otherwise.
 */
const supportsNativePopover = () => {
    if (!hasWindow) {
        return false;
    }
    return HTMLElement.prototype.hasOwnProperty('popover');
};
// determine it once
supportsNativePopover();

const hasDocument = typeof document !== 'undefined';

const isThemeDark = (theme) => {
    return theme === 'dark';
};
const headerSlot = 'header';
const anchorSlot = 'anchor';

const formatObjectOutput = (value) => {
    return JSON.stringify(value)
        .replace(/"([a-zA-Z?]+)":/g, '$1:') // remove double quotes from keys
        .replace(/([,:{])/g, '$1 ') // add space after following: ,:{
        .replace(/(})/g, ' $1') // add space before following: }
        .replace(/^"(.+)"$/, '$1'); // remove wrapping double quotes
};
'value, ' +
    formatObjectOutput(breakpoints.reduce((prev, key) => ({ ...prev, [key + (key !== 'base' ? '?' : '')]: 'value' }), {})).replace(/"/g, '');

const HEADING_TAGS = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
const getButtonPureAriaAttributes = (isDisabled, isLoading, aria) => {
    return {
        ...parseAndGetAriaAttributes(aria),
        ...getButtonBaseAriaAttributes(isDisabled, isLoading),
    };
};

const getButtonAriaAttributes = (isDisabled, isLoading, aria) => {
    return {
        ...parseAndGetAriaAttributes(aria),
        ...getButtonBaseAriaAttributes(isDisabled, isLoading),
    };
};
// Infinite bullets will be shown if the total number of bullets is greater than this value
const INFINITE_BULLET_THRESHOLD = 5;
const isInfinitePagination = (amountOfPages) => {
    return amountOfPages > INFINITE_BULLET_THRESHOLD;
};

const buildCrestSrcSet = (format) => {
    return Object.entries(CRESTS_MANIFEST.porscheCrest)
        .map(([resolution, fileName]) => `${getCDNBaseURL()}/crest/${fileName[format]} ${resolution}`)
        .join();
};
const buildCrestImgSrc = () => {
    return `${getCDNBaseURL()}/crest/${CRESTS_MANIFEST.porscheCrest['2x'].png}`;
};
const crestSize = {
    width: 30,
    height: 40,
};

const DISPLAY_TAGS = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
const displaySizeToTagMap = {
    small: 'h3',
    medium: 'h2',
    large: 'h1',
    inherit: 'h1',
};
const getDisplayTagType = (host, size, tag) => {
    if (hasSpecificDirectChildTag(host, DISPLAY_TAGS.join())) {
        return 'div';
    }
    else if (tag) {
        return tag;
    }
    else {
        return displaySizeToTagMap[size] || 'h1';
    }
};
const headingSizeToTagMap = {
    small: 'h6',
    medium: 'h5',
    large: 'h4',
    'x-large': 'h3',
    'xx-large': 'h2',
    inherit: 'h2',
};
const getHeadingTagType = (host, size, tag) => {
    if (hasSpecificDirectChildTag(host, HEADING_TAGS.join())) {
        return 'div';
    }
    else if (tag) {
        return tag;
    }
    else {
        return headingSizeToTagMap[size] || 'h2';
    }
};
const HEADLINE_TAGS = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
const variantToTagMap = {
    'large-title': 'h1',
    'headline-1': 'h1',
    'headline-2': 'h2',
    'headline-3': 'h3',
    'headline-4': 'h4',
    'headline-5': 'h5',
};
const getHeadlineTagType = (host, variant, tag) => {
    if (hasSpecificDirectChildTag(host, HEADLINE_TAGS.join())) {
        return 'div';
    }
    else if (tag) {
        return tag;
    }
    else {
        return variantToTagMap[variant] || 'h1';
    }
};
const isUrl = (str) => str?.length > 0 && /(\/)/.test(str);
const DEFAULT_ICON_NAME = 'arrow-right';
// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
const buildIconUrl = (iconNameOrSource = DEFAULT_ICON_NAME) => {
    if (iconNameOrSource === null) {
        return buildIconUrl(DEFAULT_ICON_NAME);
    }
    else if (isUrl(iconNameOrSource)) {
        return iconNameOrSource;
    }
    else if (ICONS_MANIFEST[iconNameOrSource]) {
        return `${getCDNBaseURL()}/icons/${ICONS_MANIFEST[iconNameOrSource]}`;
    }
    return buildIconUrl(DEFAULT_ICON_NAME);
};
const getInlineNotificationIconName = (state) => {
    const stateToIconMap = {
        neutral: 'information-filled', // deprecated
        info: 'information-filled',
        warning: 'warning-filled',
        success: 'success-filled',
        error: 'error-filled',
    };
    return stateToIconMap[state];
};
const getContentAriaAttributes = (state, labelId, descriptionId) => {
    const isAlert = state === 'warning' || state === 'error';
    return {
        role: isAlert ? 'alert' : 'status',
        'aria-live': isAlert ? 'assertive' : 'polite',
        'aria-labelledby': labelId,
        'aria-describedby': descriptionId,
    };
};
const getInnerManifest = (variant, trademark) => MARQUES_MANIFEST[variant === '75-years' ? 'porscheMarque75' : `porscheMarque${trademark ? 'Trademark' : ''}`];
const buildSrcSet = (innerManifest, size, format) => 
// eslint-disable-next-line @typescript-eslint/no-unsafe-argument
Object.entries(innerManifest[size])
    .map(([resolution, fileName]) => `${getCDNBaseURL()}/marque/${fileName[format]} ${resolution}`)
    .join();
const buildImgSrc = (innerManifest) => `${getCDNBaseURL()}/marque/${innerManifest.medium['2x'].png}`;
const getSvgUrl = (model) => {
    return `${getCDNBaseURL()}/model-signatures/${MODEL_SIGNATURES_MANIFEST[model]}`;
};
const modelSignatureHeight = 36;

const INTERNAL_MULTI_SELECT_SLOT = 'internal-select';
const getSelectedOptions = (options) => options.filter((option) => option.selected);
const getSelectedOptionValues = (options) => options.filter((option) => option.selected).map((option) => option.value);
var ItemType;
(function (ItemType) {
    ItemType[ItemType["PAGE"] = 0] = "PAGE";
    ItemType[ItemType["ELLIPSIS"] = 1] = "ELLIPSIS";
    ItemType[ItemType["PREVIOUS"] = 2] = "PREVIOUS";
    ItemType[ItemType["NEXT"] = 3] = "NEXT";
})(ItemType || (ItemType = {}));
const ellipsisItem = {
    type: ItemType.ELLIPSIS,
    isActive: false,
};
const createPreviousPageLink = (options) => {
    const { activePage } = options;
    return {
        type: ItemType.PREVIOUS,
        value: Math.max(1, activePage - 1),
        isActive: activePage > 1,
    };
};
const createNextPageLink = (options) => {
    const { activePage, pageTotal } = options;
    return {
        type: ItemType.NEXT,
        value: Math.min(pageTotal, activePage + 1),
        isActive: activePage < pageTotal,
    };
};
const createPageFunctionFactory = ({ activePage }) => {
    return (pageNumber) => ({
        type: ItemType.PAGE,
        value: pageNumber,
        isActive: pageNumber === activePage,
        isBeforeCurrent: pageNumber === activePage - 1,
        isBeforeBeforeCurrent: pageNumber === activePage - 2,
        isAfterCurrent: pageNumber === activePage + 1,
        isAfterAfterCurrent: pageNumber === activePage + 2,
    });
};
const createRange = (start, end) => Array.from(Array(end - start + 1), (_, i) => i + start);
const createPaginationItems = (options) => {
    const { pageTotal, activePage, showLastPage } = options;
    const pageRange = 1;
    const boundaryPagesRange = 1;
    const ellipsisSize = 1;
    const paginationItems = [createPreviousPageLink(options)];
    const createPage = createPageFunctionFactory(options);
    // Simplify generation of pages if number of available items is equal or greater than total pages to show
    if (1 + 2 * ellipsisSize + 2 * boundaryPagesRange >= pageTotal) {
        const allPages = createRange(1, pageTotal).map(createPage);
        paginationItems.push(...allPages);
    }
    else {
        // Add first page
        paginationItems.push(createPage(1));
        // Calculate group of middle pages
        const middlePagesStart = Math.min(Math.max(activePage - pageRange, 2 + ellipsisSize), pageTotal - ellipsisSize - 2 - (showLastPage ? 1 : 0));
        const middlePagesEnd = middlePagesStart + 2;
        const middlePages = createRange(middlePagesStart, middlePagesEnd).map(createPage);
        // Calculate and add ellipsis before group of middle pages
        const firstEllipsisPageNumber = middlePagesStart - 1;
        const showPageInsteadOfFirstEllipsis = firstEllipsisPageNumber === 2;
        const firstEllipsisOrPage = showPageInsteadOfFirstEllipsis ? createPage(firstEllipsisPageNumber) : ellipsisItem;
        if (showPageInsteadOfFirstEllipsis && pageTotal > 5) {
            paginationItems.push(ellipsisItem);
        }
        paginationItems.push(firstEllipsisOrPage);
        // Add group of middle pages
        paginationItems.push(...middlePages);
        // Calculate and add ellipsis after group of middle pages
        const lastEllipsisPageNumber = middlePagesEnd + 1;
        const showPageInsteadOfLastEllipsis = lastEllipsisPageNumber === pageTotal - (showLastPage ? 1 : 0);
        const lastEllipsisOrPage = showPageInsteadOfLastEllipsis ? createPage(lastEllipsisPageNumber) : ellipsisItem;
        paginationItems.push(lastEllipsisOrPage);
        if (showPageInsteadOfLastEllipsis && pageTotal > 5) {
            paginationItems.push(ellipsisItem);
        }
        // Add last page
        if (showLastPage) {
            paginationItems.push(createPage(pageTotal));
        }
    }
    paginationItems.push(createNextPageLink(options));
    return paginationItems;
};
const getCurrentActivePage = (activePage, totalPages) => {
    // Obviously we can't be on a negative or 0 page.
    if (activePage < 1) {
        activePage = 1;
    }
    // If the user has done something like /page/99999 we want to clamp that back down.
    if (activePage > totalPages) {
        activePage = totalPages;
    }
    return activePage;
};
const getTotalPages = (totalItemsCount, itemsPerPage) => {
    if (totalItemsCount < 1) {
        totalItemsCount = 1;
    }
    if (itemsPerPage < 1) {
        itemsPerPage = 1;
    }
    return Math.ceil(totalItemsCount / itemsPerPage);
};
/**
 * Determines if the current input element corresponds to the first non-filled input
 *
 * @param {number} index - The index of the current input element.
 * @param {string} value - The input value.
 * @param {number} length - The total number of input elements.
 * @returns {boolean} - True if the current input should have a specific identifier, indicating it corresponds to the first non-filled input; otherwise, false.
 */
const isCurrentInput = (index, value, length) => {
    if (!value) {
        return index === 0; // No value entered at all: set current-input id on the first input element
    }
    const firstWhitespaceIndex = value.indexOf(' ');
    if (firstWhitespaceIndex === -1) {
        return index === length - 1; // All inputs have a value: set current-input id on the last input element
    }
    return index === firstWhitespaceIndex; // Some value is entered: set current-input id on the first input element which does not have a value
};

const getButtonAttributes = (isSelected, isDisabled) => ({
    ...getButtonBaseAriaAttributes(isDisabled, false),
    ...parseAndGetAriaAttributes({ 'aria-pressed': isSelected }),
});
const getIconColor = (isDisabled) => {
    return !isDisabled ? 'primary' : 'contrast-medium';
};

const ITEM_PADDING = '17px';
const { font: BUTTON_FONT } = textSmallStyle;
const { font: LABEL_FONT } = textXSmallStyle;
const ICON_SIZE = '1.5rem';
const ICON_MARGIN = '.25rem';
['auto', ...Array.from(Array(25), (_, i) => i + 1)];
// Expect Porsche Next to be available and use sans-serif (wide font for safety buffer) as fallback
const tempFont = 'Porsche Next, sans-serif';
// temporary dom node to measure max-width of children content
// All width relevant styling has to be kept in sync with the button of the p-segmented-control-item
const tempDiv = hasDocument ? document.createElement('div') : undefined;
if (tempDiv) {
    tempDiv.style.position = 'absolute';
    tempDiv.style.visibility = 'hidden';
    tempDiv.style.padding = `0 ${ITEM_PADDING}`; // Uses the largest possible padding of the item
    tempDiv.style.border = `${borderWidthBase} solid`;
    tempDiv.style.boxSizing = 'border-box';
    tempDiv.style.font = BUTTON_FONT.replace(fontFamily, tempFont);
}
const tempLabel = hasDocument ? document.createElement('div') : undefined;
if (tempLabel) {
    tempLabel.style.font = LABEL_FONT.replace(fontFamily, tempFont);
}
const tempIcon = hasDocument ? document.createElement('div') : undefined;
if (tempIcon) {
    tempIcon.style.display = 'inline-block';
    tempIcon.style.width = ICON_SIZE;
    tempIcon.style.marginRight = ICON_MARGIN;
}
const getSelectedOptionMap = (arr) => arr.find((item) => item.selected);
const isCustomDropdown = (filter, native) => {
    if (filter) {
        return true;
    }
    else if (native) {
        return false;
    }
    else {
        return !isTouchDevice();
    }
};

const INTERNAL_SELECT_SLOT = 'internal-select';
const getSelectedOptionString = (options) => options.find((option) => option.selected)?.textContent ?? '';
const isStateCompleteOrWarning = (state) => {
    return state === 'complete' || state === 'warning';
};
const getStepperHorizontalIconName = (state) => {
    return state === 'complete' ? 'success' : 'warning';
};

const getSwitchButtonAriaAttributes = (isDisabled, isLoading, isChecked) => {
    return {
        ...getButtonBaseAriaAttributes(isDisabled, isLoading),
        'aria-checked': isChecked ? 'true' : 'false',
    };
};
const isSortable = (active, direction) => {
    return active !== undefined && direction !== undefined;
};

const getThemeForIcon = (color, theme) => {
    return color === 'neutral-contrast-high' || color === 'primary' ? (isThemeDark(theme) ? 'light' : 'dark') : theme;
};
const isType = (inputType, typeToValidate) => inputType === typeToValidate;
const hasLocateAction = (icon) => icon === 'locate';
// eslint-disable-next-line no-underscore-dangle
const _hasShowPickerSupport = () => {
    return (hasDocument &&
        'showPicker' in HTMLInputElement.prototype &&
        // TODO: it would be better to determinate support by checking for existence of "calendar-picker-indicator"
        !!window.navigator.userAgent.match(/chrome|chromium|crios|edg/i));
};
const hasShowPickerSupport = _hasShowPickerSupport();
const showCustomCalendarOrTimeIndicator = (isCalendar, isTime) => {
    return hasShowPickerSupport && (isCalendar || isTime);
};
const isListTypeOrdered = (type) => type !== 'unordered';

const TEXT_TAGS = ['p', 'span', 'div', 'address', 'blockquote', 'figcaption', 'cite', 'time', 'legend'];
const getTextTagType = (host, tag) => {
    if (hasSpecificDirectChildTag(host, TEXT_TAGS.join())) {
        return 'div';
    }
    else {
        return tag;
    }
};

export { DISPLAY_TAGS, HEADING_TAGS, HEADLINE_TAGS, INTERNAL_MULTI_SELECT_SLOT, INTERNAL_SELECT_SLOT, ItemType, TEXT_TAGS, _hasShowPickerSupport, anchorSlot, attributeMutationMap, buildCrestImgSrc, buildCrestSrcSet, buildIconUrl, buildImgSrc, buildSrcSet, createPaginationItems, createRange, crestSize, displaySizeToTagMap, getButtonAriaAttributes, getButtonAttributes, getButtonBaseAriaAttributes, getButtonPureAriaAttributes, getCDNBaseURL, getClosestHTMLElement, getComboboxAriaAttributes, getContentAriaAttributes, getCurrentActivePage, getDirectChildHTMLElement, getDisplayTagType, getHTMLElement, getHeadingTagType, getHeadlineTagType, getIconColor, getInlineNotificationIconName, getInnerManifest, getListAriaAttributes, getRole, getSelectedOptionMap, getSelectedOptionString, getSelectedOptionValues, getSelectedOptions, getStepperHorizontalIconName, getSvgUrl, getSwitchButtonAriaAttributes, getTextTagType, getThemeForIcon, getTotalPages, hasDocument, hasLocateAction, hasSpecificDirectChildTag, hasVisibleIcon, hasWindow, headerSlot, isCurrentInput, isCustomDropdown, isDisabledOrLoading, isInfinitePagination, isListTypeOrdered, isScrollable, isSortable, isStateCompleteOrWarning, isThemeDark, isTouchDevice, isType, isUrl, isWithinForm, modelSignatureHeight, observedNodesMap, parseAndGetAriaAttributes, parseJSONAttribute, scrollAreaClass, showCustomCalendarOrTimeIndicator, supportsConstructableStylesheets, supportsNativePopover, tempDiv, tempIcon, tempLabel };
